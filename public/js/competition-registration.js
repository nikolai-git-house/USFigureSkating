(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["/js/competition-registration"],{

/***/ "./node_modules/card-validator/index.js":
/*!**********************************************!*\
  !*** ./node_modules/card-validator/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {
  number: __webpack_require__(/*! ./src/card-number */ "./node_modules/card-validator/src/card-number.js"),
  expirationDate: __webpack_require__(/*! ./src/expiration-date */ "./node_modules/card-validator/src/expiration-date.js"),
  expirationMonth: __webpack_require__(/*! ./src/expiration-month */ "./node_modules/card-validator/src/expiration-month.js"),
  expirationYear: __webpack_require__(/*! ./src/expiration-year */ "./node_modules/card-validator/src/expiration-year.js"),
  cvv: __webpack_require__(/*! ./src/cvv */ "./node_modules/card-validator/src/cvv.js"),
  postalCode: __webpack_require__(/*! ./src/postal-code */ "./node_modules/card-validator/src/postal-code.js"),
  creditCardType: __webpack_require__(/*! credit-card-type */ "./node_modules/credit-card-type/index.js")
};


/***/ }),

/***/ "./node_modules/card-validator/src/card-number.js":
/*!********************************************************!*\
  !*** ./node_modules/card-validator/src/card-number.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var luhn10 = __webpack_require__(/*! ./luhn-10 */ "./node_modules/card-validator/src/luhn-10.js");
var getCardTypes = __webpack_require__(/*! credit-card-type */ "./node_modules/credit-card-type/index.js");

function verification(card, isPotentiallyValid, isValid) {
  return {card: card, isPotentiallyValid: isPotentiallyValid, isValid: isValid};
}

function cardNumber(value, options) {
  var potentialTypes, cardType, isPotentiallyValid, isValid, i, maxLength;

  options = options || {};

  if (typeof value === 'number') {
    value = String(value);
  }

  if (typeof value !== 'string') { return verification(null, false, false); }

  value = value.replace(/\-|\s/g, '');

  if (!/^\d*$/.test(value)) { return verification(null, false, false); }

  potentialTypes = getCardTypes(value);

  if (potentialTypes.length === 0) {
    return verification(null, false, false);
  } else if (potentialTypes.length !== 1) {
    return verification(null, true, false);
  }

  cardType = potentialTypes[0];

  if (cardType.type === getCardTypes.types.UNIONPAY && options.luhnValidateUnionPay !== true) {
    isValid = true;
  } else {
    isValid = luhn10(value);
  }

  maxLength = Math.max.apply(null, cardType.lengths);

  for (i = 0; i < cardType.lengths.length; i++) {
    if (cardType.lengths[i] === value.length) {
      isPotentiallyValid = value.length !== maxLength || isValid;
      return verification(cardType, isPotentiallyValid, isValid);
    }
  }

  return verification(cardType, value.length < maxLength, false);
}

module.exports = cardNumber;


/***/ }),

/***/ "./node_modules/card-validator/src/cvv.js":
/*!************************************************!*\
  !*** ./node_modules/card-validator/src/cvv.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var DEFAULT_LENGTH = 3;

function includes(array, thing) {
  var i = 0;

  for (; i < array.length; i++) {
    if (thing === array[i]) { return true; }
  }

  return false;
}

function max(array) {
  var maximum = DEFAULT_LENGTH;
  var i = 0;

  for (; i < array.length; i++) {
    maximum = array[i] > maximum ? array[i] : maximum;
  }

  return maximum;
}

function verification(isValid, isPotentiallyValid) {
  return {isValid: isValid, isPotentiallyValid: isPotentiallyValid};
}

function cvv(value, maxLength) {
  maxLength = maxLength || DEFAULT_LENGTH;
  maxLength = maxLength instanceof Array ? maxLength : [maxLength];

  if (typeof value !== 'string') { return verification(false, false); }
  if (!/^\d*$/.test(value)) { return verification(false, false); }
  if (includes(maxLength, value.length)) { return verification(true, true); }
  if (value.length < Math.min.apply(null, maxLength)) { return verification(false, true); }
  if (value.length > max(maxLength)) { return verification(false, false); }

  return verification(true, true);
}

module.exports = cvv;


/***/ }),

/***/ "./node_modules/card-validator/src/expiration-date.js":
/*!************************************************************!*\
  !*** ./node_modules/card-validator/src/expiration-date.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var parseDate = __webpack_require__(/*! ./parse-date */ "./node_modules/card-validator/src/parse-date.js");
var expirationMonth = __webpack_require__(/*! ./expiration-month */ "./node_modules/card-validator/src/expiration-month.js");
var expirationYear = __webpack_require__(/*! ./expiration-year */ "./node_modules/card-validator/src/expiration-year.js");

function verification(isValid, isPotentiallyValid, month, year) {
  return {
    isValid: isValid,
    isPotentiallyValid: isPotentiallyValid,
    month: month,
    year: year
  };
}

function expirationDate(value, maxElapsedYear) {
  var date, monthValid, yearValid, isValidForThisYear;

  if (typeof value === 'string') {
    value = value.replace(/^(\d\d) (\d\d(\d\d)?)$/, '$1/$2');
    date = parseDate(value);
  } else if (value !== null && typeof value === 'object') {
    date = {
      month: String(value.month),
      year: String(value.year)
    };
  } else {
    return verification(false, false, null, null);
  }

  monthValid = expirationMonth(date.month);
  yearValid = expirationYear(date.year, maxElapsedYear);

  if (monthValid.isValid) {
    if (yearValid.isCurrentYear) {
      isValidForThisYear = monthValid.isValidForThisYear;
      return verification(isValidForThisYear, isValidForThisYear, date.month, date.year);
    }

    if (yearValid.isValid) {
      return verification(true, true, date.month, date.year);
    }
  }

  if (monthValid.isPotentiallyValid && yearValid.isPotentiallyValid) {
    return verification(false, true, null, null);
  }

  return verification(false, false, null, null);
}

module.exports = expirationDate;


/***/ }),

/***/ "./node_modules/card-validator/src/expiration-month.js":
/*!*************************************************************!*\
  !*** ./node_modules/card-validator/src/expiration-month.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function verification(isValid, isPotentiallyValid, isValidForThisYear) {
  return {
    isValid: isValid,
    isPotentiallyValid: isPotentiallyValid,
    isValidForThisYear: isValidForThisYear || false
  };
}

function expirationMonth(value) {
  var month, result;
  var currentMonth = new Date().getMonth() + 1;

  if (typeof value !== 'string') {
    return verification(false, false);
  }
  if (value.replace(/\s/g, '') === '' || value === '0') {
    return verification(false, true);
  }
  if (!/^\d*$/.test(value)) {
    return verification(false, false);
  }

  month = parseInt(value, 10);

  if (isNaN(value)) {
    return verification(false, false);
  }

  result = month > 0 && month < 13;

  return verification(result, result, result && month >= currentMonth);
}

module.exports = expirationMonth;


/***/ }),

/***/ "./node_modules/card-validator/src/expiration-year.js":
/*!************************************************************!*\
  !*** ./node_modules/card-validator/src/expiration-year.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var DEFAULT_VALID_NUMBER_OF_YEARS_IN_THE_FUTURE = 19;

function verification(isValid, isPotentiallyValid, isCurrentYear) {
  return {
    isValid: isValid,
    isPotentiallyValid: isPotentiallyValid,
    isCurrentYear: isCurrentYear || false
  };
}

function expirationYear(value, maxElapsedYear) {
  var currentFirstTwo, currentYear, firstTwo, len, twoDigitYear, valid, isCurrentYear;

  maxElapsedYear = maxElapsedYear || DEFAULT_VALID_NUMBER_OF_YEARS_IN_THE_FUTURE;

  if (typeof value !== 'string') {
    return verification(false, false);
  }
  if (value.replace(/\s/g, '') === '') {
    return verification(false, true);
  }
  if (!/^\d*$/.test(value)) {
    return verification(false, false);
  }

  len = value.length;

  if (len < 2) {
    return verification(false, true);
  }

  currentYear = new Date().getFullYear();

  if (len === 3) {
    // 20x === 20x
    firstTwo = value.slice(0, 2);
    currentFirstTwo = String(currentYear).slice(0, 2);
    return verification(false, firstTwo === currentFirstTwo);
  }

  if (len > 4) {
    return verification(false, false);
  }

  value = parseInt(value, 10);
  twoDigitYear = Number(String(currentYear).substr(2, 2));

  if (len === 2) {
    isCurrentYear = twoDigitYear === value;
    valid = value >= twoDigitYear && value <= twoDigitYear + maxElapsedYear;
  } else if (len === 4) {
    isCurrentYear = currentYear === value;
    valid = value >= currentYear && value <= currentYear + maxElapsedYear;
  }

  return verification(valid, valid, isCurrentYear);
}

module.exports = expirationYear;


/***/ }),

/***/ "./node_modules/card-validator/src/lib/is-array.js":
/*!*********************************************************!*\
  !*** ./node_modules/card-validator/src/lib/is-array.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// Polyfill taken from <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray#Polyfill>.

module.exports = Array.isArray || function (arg) {
  return Object.prototype.toString.call(arg) === '[object Array]';
};


/***/ }),

/***/ "./node_modules/card-validator/src/luhn-10.js":
/*!****************************************************!*\
  !*** ./node_modules/card-validator/src/luhn-10.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * Luhn algorithm implementation in JavaScript
 * Copyright (c) 2009 Nicholas C. Zakas
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */


function luhn10(identifier) {
  var sum = 0;
  var alt = false;
  var i = identifier.length - 1;
  var num;

  while (i >= 0) {
    num = parseInt(identifier.charAt(i), 10);

    if (alt) {
      num *= 2;
      if (num > 9) {
        num = (num % 10) + 1; // eslint-disable-line no-extra-parens
      }
    }

    alt = !alt;

    sum += num;

    i--;
  }

  return sum % 10 === 0;
}

module.exports = luhn10;


/***/ }),

/***/ "./node_modules/card-validator/src/parse-date.js":
/*!*******************************************************!*\
  !*** ./node_modules/card-validator/src/parse-date.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var expirationYear = __webpack_require__(/*! ./expiration-year */ "./node_modules/card-validator/src/expiration-year.js");
var isArray = __webpack_require__(/*! ./lib/is-array */ "./node_modules/card-validator/src/lib/is-array.js");

function parseDate(value) {
  var month, len, year, yearValid;

  if (/\//.test(value)) {
    value = value.split(/\s*\/\s*/g);
  } else if (/\s/.test(value)) {
    value = value.split(/ +/g);
  }

  if (isArray(value)) {
    return {
      month: value[0],
      year: value.slice(1).join()
    };
  }

  len = value[0] === '0' || value.length > 5 ? 2 : 1;

  if (value[0] === '1') {
    year = value.substr(1);
    yearValid = expirationYear(year);
    if (!yearValid.isPotentiallyValid) {
      len = 2;
    }
  }

  month = value.substr(0, len);

  return {
    month: month,
    year: value.substr(month.length)
  };
}

module.exports = parseDate;


/***/ }),

/***/ "./node_modules/card-validator/src/postal-code.js":
/*!********************************************************!*\
  !*** ./node_modules/card-validator/src/postal-code.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var DEFAULT_MIN_POSTAL_CODE_LENGTH = 3;

function verification(isValid, isPotentiallyValid) {
  return {isValid: isValid, isPotentiallyValid: isPotentiallyValid};
}

function postalCode(value, options) {
  var minLength;

  options = options || {};

  minLength = options.minLength || DEFAULT_MIN_POSTAL_CODE_LENGTH;

  if (typeof value !== 'string') {
    return verification(false, false);
  } else if (value.length < minLength) {
    return verification(false, true);
  }

  return verification(true, true);
}

module.exports = postalCode;


/***/ }),

/***/ "./node_modules/credit-card-type/index.js":
/*!************************************************!*\
  !*** ./node_modules/credit-card-type/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var testOrder;
var types = {};
var customCards = {};
var VISA = 'visa';
var MASTERCARD = 'mastercard';
var AMERICAN_EXPRESS = 'american-express';
var DINERS_CLUB = 'diners-club';
var DISCOVER = 'discover';
var ELO = 'elo';
var JCB = 'jcb';
var UNIONPAY = 'unionpay';
var MAESTRO = 'maestro';
var MIR = 'mir';
var CVV = 'CVV';
var CID = 'CID';
var CVC = 'CVC';
var CVN = 'CVN';
var CVP2 = 'CVP2';
var CVE = 'CVE';
var ORIGINAL_TEST_ORDER = [
  VISA,
  MASTERCARD,
  AMERICAN_EXPRESS,
  DINERS_CLUB,
  DISCOVER,
  JCB,
  UNIONPAY,
  MAESTRO,
  ELO,
  MIR
];

function clone(originalObject, persistPatterns) {
  var dupe, prefixPattern, exactPattern;

  if (!originalObject) { return null; }

  prefixPattern = originalObject.prefixPattern;
  exactPattern = originalObject.exactPattern;
  dupe = JSON.parse(JSON.stringify(originalObject));

  if (persistPatterns) {
    dupe.prefixPattern = prefixPattern;
    dupe.exactPattern = exactPattern;
  } else {
    delete dupe.prefixPattern;
    delete dupe.exactPattern;
  }

  return dupe;
}

testOrder = clone(ORIGINAL_TEST_ORDER);

types[VISA] = {
  niceType: 'Visa',
  type: VISA,
  prefixPattern: /^4/,
  exactPattern: new RegExp('^' +
    '4' +
    '(?!' +
      '31274|51416|57393|0117[89]|38935|5763[12]' + // Elo cards
    ')\\d{5,}' +
  '$'),
  gaps: [4, 8, 12],
  lengths: [16, 18, 19],
  code: {
    name: CVV,
    size: 3
  }
};

types[MASTERCARD] = {
  niceType: 'Mastercard',
  type: MASTERCARD,
  prefixPattern: /^(5|5[1-5]|2|22|222|222[1-9]|2[3-6]|27|27[0-2]|2720)$/,
  exactPattern: /^(5[1-5]|222[1-9]|22[3-9]|2[3-6]|27[0-1]|2720)\d*$/,
  gaps: [4, 8, 12],
  lengths: [16],
  code: {
    name: CVC,
    size: 3
  }
};

types[AMERICAN_EXPRESS] = {
  niceType: 'American Express',
  type: AMERICAN_EXPRESS,
  prefixPattern: /^(3|34|37)$/,
  exactPattern: /^3[47]\d*$/,
  isAmex: true,
  gaps: [4, 10],
  lengths: [15],
  code: {
    name: CID,
    size: 4
  }
};

types[DINERS_CLUB] = {
  niceType: 'Diners Club',
  type: DINERS_CLUB,
  prefixPattern: /^(3|3[0689]|30[0-5])$/,
  exactPattern: /^3(0[0-5]|[689])\d*$/,
  gaps: [4, 10],
  lengths: [14, 16, 19],
  code: {
    name: CVV,
    size: 3
  }
};

types[DISCOVER] = {
  niceType: 'Discover',
  type: DISCOVER,
  prefixPattern: /^(6|60|601|6011|65|65\d{1,4}|64|64[4-9])$/,
  exactPattern: new RegExp('^(' +
    '6011' +
    '|' +
    '65' +
      '(?!' + // Elo cards
        '003[1-3]' +
        '|' +
        '003[5-9]|004\\d|005[0-1]' +
        '|' +
        '040[5-9]|04[1-3]\\d' +
        '|' +
        '048[5-9]|049\\d|05[0-2]\\d|053[0-8]' +
        '|' +
        '054[1-9]|05[5-8]\\d|059[0-8]' +
        '|' +
        '070\\d|071[0-8]' +
        '|' +
        '072[0-7]' +
        '|' +
        '090[1-9]|09[1-6]\\d|097[0-8]' +
        '|' +
        '165[2-9]|16[6-7]\\d' +
        '|' +
        '50[0-1]\\d' +
        '|' +
        '502[1-9]|50[3-4]\\d|505[0-8]' +
      ')\\d{4}' +
    '|' +
    '64[4-9]' +
  ')\\d*$'),
  gaps: [4, 8, 12],
  lengths: [16, 19],
  code: {
    name: CID,
    size: 3
  }
};

types[JCB] = {
  niceType: 'JCB',
  type: JCB,
  prefixPattern: /^(2|21|213|2131|1|18|180|1800|3|35)$/,
  exactPattern: /^(2131|1800|35)\d*$/,
  gaps: [4, 8, 12],
  lengths: [16, 17, 18, 19],
  code: {
    name: CVV,
    size: 3
  }
};

types[UNIONPAY] = {
  niceType: 'UnionPay',
  type: UNIONPAY,
  prefixPattern: /^((6|62|62\d|(621(?!83|88|98|99))|622(?!06)|627[0267]\d?|628(?!0|1)|629[1,2])|622018)$/,
  exactPattern: new RegExp('^(' +
    '(' +
      '620' +
      '|' +
      '(621(?!83|88|98|99))' +
      '|' +
      '622(?!06|018)' +
      '|' +
      '62[3-6]' +
      '|' +
      '627[026]' +
      '|' +
      '6277(?!80)\\d{2}' + // Elo card
      '|' +
      '628(?!0|1)' +
      '|' +
      '629[12]' +
    ')\\d*' +

    '|' +

    '622018\\d{12}' +
  ')$'),
  gaps: [4, 8, 12],
  lengths: [16, 17, 18, 19],
  code: {
    name: CVN,
    size: 3
  }
};

types[MAESTRO] = {
  niceType: 'Maestro',
  type: MAESTRO,
  prefixPattern: /^(5|5[06-9]|6\d*)$/,
  exactPattern: new RegExp('^(' +
    '5[6-9]' +
    '|' +
    '50' +
      '(?!' + // Elo card ranges
        '6699|067[0-6][0-9]' +
        '|' +
        '677[0-8]' +
        '|' +
        '9[0-9][0-9][0-9]' +
      ')\\d{4}' +
    '|' +
    '67' +
    '|' +
    '63' +
      '(?!' + // More Elo card ranges
        '6297|6368' +
      ')\\d{4}' +
    ')\\d*$'
  ),
  gaps: [4, 8, 12],
  lengths: [12, 13, 14, 15, 16, 17, 18, 19],
  code: {
    name: CVC,
    size: 3
  }
};

types[ELO] = {
  niceType: 'Elo',
  type: ELO,
  prefixPattern: new RegExp('^(' +
    '[4-6]' +

    '|' +

    '4[035]|4[035]1' +
    '|' +
    '4011|40117|40117[89]' +
    '|' +
    '4312|43127|431274' +
    '|' +
    '438|4389|43893|438935' +
    '|' +
    '4514|45141|451416' +
    '|' +
    '457|457[36]|45739|45763|457393|45763[12]' +

    '|' +

    '50|50[69]' +
    '|' +
    '506[6-7]|50669|5067[0-7]|5067[0-6][0-9]|50677[0-8]' +
    '|' +
    '509[0-9]|509[0-9][0-9]|509[0-9][0-9][0-9]' +

    '|' +

    '6[235]|627|636|65[015]' +
    '|' +
    '6277|62778|627780' +
    '|' +
    '636[23]|63629|636297|63636|636368' +
    '|' +
    '650[0479]' +
    '|' +
    '6500[3-5]|65003[1-3]|65003[5-9]|65004[0-9]65005[01]' +
    '|' +
    '6504[0-3]|65040[5-9]|65041[0-9]' +
    '|' +
    '6505[4-9]|65054[1-9]|6505[5-8][0-9]|65059[0-8]' +
    '|' +
    '6507[0-2]|65070[0-9]|65071[0-8]|65072[0-7]' +
    '|' +
    '6509[0-7]|65090[1-9]|6509[1-6][0-9]|65097[0-8]' +
    '|' +
    '6516|6516[5-7]|65165[2-9]|6516[6-7][0-9]' +
    '|' +
    '6550|6550[0-5]|6550[01][0-9]|65502[1-9]|6550[3-4][0-9]|65505[0-8]' +
  ')$'),
  exactPattern: new RegExp('^(' +
    // Elo only ranges
    '4(31274|51416|57393)' +

    '|' +

    '50(' +
      '4175' +
      '|' +
      '6699|67[0-6][0-9]|677[0-8]' + // 506699-506778
      '|' +
      '9[0-9][0-9][0-9]' + // 509000-509999
    ')' +

    '|' +

    '627780' +

    '|' +

    '636(297|368)' +

    '|' +

    // Dual Branded with Visa
    '4(0117[89]|38935|5763[12])' +

    '|' +

    // Dual Branded with Discover
    '65(' +
      '003[1-3]' + // 650031-650033
      '|' +
      '003[5-9]|004\\d|005[0-1]' + // 650035-650051
      '|' +
      '040[5-9]|04[1-3]\\d' + // 650405-650439
      '|' +
      '048[5-9]|049\\d|05[0-2]\\d|053[0-8]' + // 650485-650538
      '|' +
      '054[1-9]|05[5-8]\\d|059[0-8]' + // 650541-650598
      '|' +
      '070[0-9]|071[0-8]' + // 650700-650718
      '|' +
      '072[0-7]' + // 650720-650727
      '|' +
      '090[1-9]|09[1-6][0-9]|097[0-8]' + // 650901-650978
      '|' +
      '165[2-9]|16[6-7][0-9]' + // 651652-651679
      '|' +
      '50[0-1][0-9]' + // 655000-655019
      '|' +
      '502[1-9]|50[3-4][0-9]|505[0-8]' + // 655021-655058
    ')' +
  ')\\d*$'),
  gaps: [4, 8, 12],
  lengths: [16],
  code: {
    name: CVE,
    size: 3
  }
};

types[MIR] = {
  niceType: 'Mir',
  type: MIR,
  prefixPattern: /^(2|22|220|220[0-4])$/,
  exactPattern: /^(220[0-4])\d*$/,
  gaps: [4, 8, 12],
  lengths: [16, 17, 18, 19],
  code: {
    name: CVP2,
    size: 3
  }
};

function findType(type) {
  return customCards[type] || types[type];
}

function creditCardType(cardNumber) {
  var type, value, i;
  var prefixResults = [];
  var exactResults = [];

  if (!(typeof cardNumber === 'string' || cardNumber instanceof String)) {
    return [];
  }

  for (i = 0; i < testOrder.length; i++) {
    type = testOrder[i];
    value = findType(type);

    if (cardNumber.length === 0) {
      prefixResults.push(clone(value));
      continue;
    }

    if (value.exactPattern.test(cardNumber)) {
      exactResults.push(clone(value));
    } else if (value.prefixPattern.test(cardNumber)) {
      prefixResults.push(clone(value));
    }
  }

  return exactResults.length ? exactResults : prefixResults;
}

creditCardType.getTypeInfo = function (type) {
  return clone(findType(type));
};

function getCardPosition(name, ignoreErrorForNotExisting) {
  var position = testOrder.indexOf(name);

  if (!ignoreErrorForNotExisting && position === -1) {
    throw new Error('"' + name + '" is not a supported card type.');
  }

  return position;
}

creditCardType.removeCard = function (name) {
  var position = getCardPosition(name);

  testOrder.splice(position, 1);
};

creditCardType.addCard = function (config) {
  var existingCardPosition = getCardPosition(config.type, true);

  customCards[config.type] = config;

  if (existingCardPosition === -1) {
    testOrder.push(config.type);
  }
};

creditCardType.updateCard = function (cardType, updates) {
  var clonedCard;
  var originalObject = customCards[cardType] || types[cardType];

  if (!originalObject) {
    throw new Error('"' + cardType + '" is not a recognized type. Use `addCard` instead.');
  }

  if (updates.type && originalObject.type !== updates.type) {
    throw new Error('Cannot overwrite type parameter.');
  }

  clonedCard = clone(originalObject, true);

  Object.keys(clonedCard).forEach(function (key) {
    if (updates[key]) {
      clonedCard[key] = updates[key];
    }
  });

  customCards[clonedCard.type] = clonedCard;
};

creditCardType.changeOrder = function (name, position) {
  var currentPosition = getCardPosition(name);

  testOrder.splice(currentPosition, 1);
  testOrder.splice(position, 0, name);
};

creditCardType.resetModifications = function () {
  testOrder = clone(ORIGINAL_TEST_ORDER);
  customCards = {};
};

creditCardType.types = {
  VISA: VISA,
  MASTERCARD: MASTERCARD,
  AMERICAN_EXPRESS: AMERICAN_EXPRESS,
  DINERS_CLUB: DINERS_CLUB,
  DISCOVER: DISCOVER,
  JCB: JCB,
  UNIONPAY: UNIONPAY,
  MAESTRO: MAESTRO,
  ELO: ELO,
  MIR: MIR
};

module.exports = creditCardType;


/***/ }),

/***/ "./node_modules/es6-promise/auto.js":
/*!******************************************!*\
  !*** ./node_modules/es6-promise/auto.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// This file can be required in Browserify and Node.js for automatic polyfill
// To use it:  require('es6-promise/auto');

module.exports = __webpack_require__(/*! ./ */ "./node_modules/es6-promise/dist/es6-promise.js").polyfill();


/***/ }),

/***/ "./node_modules/es6-promise/dist/es6-promise.js":
/*!******************************************************!*\
  !*** ./node_modules/es6-promise/dist/es6-promise.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process, global) {/*!
 * @overview es6-promise - a tiny implementation of Promises/A+.
 * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
 * @license   Licensed under MIT license
 *            See https://raw.githubusercontent.com/stefanpenner/es6-promise/master/LICENSE
 * @version   v4.2.8+1e68dce6
 */

(function (global, factory) {
	 true ? module.exports = factory() :
	undefined;
}(this, (function () { 'use strict';

function objectOrFunction(x) {
  var type = typeof x;
  return x !== null && (type === 'object' || type === 'function');
}

function isFunction(x) {
  return typeof x === 'function';
}



var _isArray = void 0;
if (Array.isArray) {
  _isArray = Array.isArray;
} else {
  _isArray = function (x) {
    return Object.prototype.toString.call(x) === '[object Array]';
  };
}

var isArray = _isArray;

var len = 0;
var vertxNext = void 0;
var customSchedulerFn = void 0;

var asap = function asap(callback, arg) {
  queue[len] = callback;
  queue[len + 1] = arg;
  len += 2;
  if (len === 2) {
    // If len is 2, that means that we need to schedule an async flush.
    // If additional callbacks are queued before the queue is flushed, they
    // will be processed by this flush that we are scheduling.
    if (customSchedulerFn) {
      customSchedulerFn(flush);
    } else {
      scheduleFlush();
    }
  }
};

function setScheduler(scheduleFn) {
  customSchedulerFn = scheduleFn;
}

function setAsap(asapFn) {
  asap = asapFn;
}

var browserWindow = typeof window !== 'undefined' ? window : undefined;
var browserGlobal = browserWindow || {};
var BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;
var isNode = typeof self === 'undefined' && typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';

// test for web worker but not in IE10
var isWorker = typeof Uint8ClampedArray !== 'undefined' && typeof importScripts !== 'undefined' && typeof MessageChannel !== 'undefined';

// node
function useNextTick() {
  // node version 0.10.x displays a deprecation warning when nextTick is used recursively
  // see https://github.com/cujojs/when/issues/410 for details
  return function () {
    return process.nextTick(flush);
  };
}

// vertx
function useVertxTimer() {
  if (typeof vertxNext !== 'undefined') {
    return function () {
      vertxNext(flush);
    };
  }

  return useSetTimeout();
}

function useMutationObserver() {
  var iterations = 0;
  var observer = new BrowserMutationObserver(flush);
  var node = document.createTextNode('');
  observer.observe(node, { characterData: true });

  return function () {
    node.data = iterations = ++iterations % 2;
  };
}

// web worker
function useMessageChannel() {
  var channel = new MessageChannel();
  channel.port1.onmessage = flush;
  return function () {
    return channel.port2.postMessage(0);
  };
}

function useSetTimeout() {
  // Store setTimeout reference so es6-promise will be unaffected by
  // other code modifying setTimeout (like sinon.useFakeTimers())
  var globalSetTimeout = setTimeout;
  return function () {
    return globalSetTimeout(flush, 1);
  };
}

var queue = new Array(1000);
function flush() {
  for (var i = 0; i < len; i += 2) {
    var callback = queue[i];
    var arg = queue[i + 1];

    callback(arg);

    queue[i] = undefined;
    queue[i + 1] = undefined;
  }

  len = 0;
}

function attemptVertx() {
  try {
    var vertx = Function('return this')().require('vertx');
    vertxNext = vertx.runOnLoop || vertx.runOnContext;
    return useVertxTimer();
  } catch (e) {
    return useSetTimeout();
  }
}

var scheduleFlush = void 0;
// Decide what async method to use to triggering processing of queued callbacks:
if (isNode) {
  scheduleFlush = useNextTick();
} else if (BrowserMutationObserver) {
  scheduleFlush = useMutationObserver();
} else if (isWorker) {
  scheduleFlush = useMessageChannel();
} else if (browserWindow === undefined && "function" === 'function') {
  scheduleFlush = attemptVertx();
} else {
  scheduleFlush = useSetTimeout();
}

function then(onFulfillment, onRejection) {
  var parent = this;

  var child = new this.constructor(noop);

  if (child[PROMISE_ID] === undefined) {
    makePromise(child);
  }

  var _state = parent._state;


  if (_state) {
    var callback = arguments[_state - 1];
    asap(function () {
      return invokeCallback(_state, child, callback, parent._result);
    });
  } else {
    subscribe(parent, child, onFulfillment, onRejection);
  }

  return child;
}

/**
  `Promise.resolve` returns a promise that will become resolved with the
  passed `value`. It is shorthand for the following:

  ```javascript
  let promise = new Promise(function(resolve, reject){
    resolve(1);
  });

  promise.then(function(value){
    // value === 1
  });
  ```

  Instead of writing the above, your code now simply becomes the following:

  ```javascript
  let promise = Promise.resolve(1);

  promise.then(function(value){
    // value === 1
  });
  ```

  @method resolve
  @static
  @param {Any} value value that the returned promise will be resolved with
  Useful for tooling.
  @return {Promise} a promise that will become fulfilled with the given
  `value`
*/
function resolve$1(object) {
  /*jshint validthis:true */
  var Constructor = this;

  if (object && typeof object === 'object' && object.constructor === Constructor) {
    return object;
  }

  var promise = new Constructor(noop);
  resolve(promise, object);
  return promise;
}

var PROMISE_ID = Math.random().toString(36).substring(2);

function noop() {}

var PENDING = void 0;
var FULFILLED = 1;
var REJECTED = 2;

function selfFulfillment() {
  return new TypeError("You cannot resolve a promise with itself");
}

function cannotReturnOwn() {
  return new TypeError('A promises callback cannot return that same promise.');
}

function tryThen(then$$1, value, fulfillmentHandler, rejectionHandler) {
  try {
    then$$1.call(value, fulfillmentHandler, rejectionHandler);
  } catch (e) {
    return e;
  }
}

function handleForeignThenable(promise, thenable, then$$1) {
  asap(function (promise) {
    var sealed = false;
    var error = tryThen(then$$1, thenable, function (value) {
      if (sealed) {
        return;
      }
      sealed = true;
      if (thenable !== value) {
        resolve(promise, value);
      } else {
        fulfill(promise, value);
      }
    }, function (reason) {
      if (sealed) {
        return;
      }
      sealed = true;

      reject(promise, reason);
    }, 'Settle: ' + (promise._label || ' unknown promise'));

    if (!sealed && error) {
      sealed = true;
      reject(promise, error);
    }
  }, promise);
}

function handleOwnThenable(promise, thenable) {
  if (thenable._state === FULFILLED) {
    fulfill(promise, thenable._result);
  } else if (thenable._state === REJECTED) {
    reject(promise, thenable._result);
  } else {
    subscribe(thenable, undefined, function (value) {
      return resolve(promise, value);
    }, function (reason) {
      return reject(promise, reason);
    });
  }
}

function handleMaybeThenable(promise, maybeThenable, then$$1) {
  if (maybeThenable.constructor === promise.constructor && then$$1 === then && maybeThenable.constructor.resolve === resolve$1) {
    handleOwnThenable(promise, maybeThenable);
  } else {
    if (then$$1 === undefined) {
      fulfill(promise, maybeThenable);
    } else if (isFunction(then$$1)) {
      handleForeignThenable(promise, maybeThenable, then$$1);
    } else {
      fulfill(promise, maybeThenable);
    }
  }
}

function resolve(promise, value) {
  if (promise === value) {
    reject(promise, selfFulfillment());
  } else if (objectOrFunction(value)) {
    var then$$1 = void 0;
    try {
      then$$1 = value.then;
    } catch (error) {
      reject(promise, error);
      return;
    }
    handleMaybeThenable(promise, value, then$$1);
  } else {
    fulfill(promise, value);
  }
}

function publishRejection(promise) {
  if (promise._onerror) {
    promise._onerror(promise._result);
  }

  publish(promise);
}

function fulfill(promise, value) {
  if (promise._state !== PENDING) {
    return;
  }

  promise._result = value;
  promise._state = FULFILLED;

  if (promise._subscribers.length !== 0) {
    asap(publish, promise);
  }
}

function reject(promise, reason) {
  if (promise._state !== PENDING) {
    return;
  }
  promise._state = REJECTED;
  promise._result = reason;

  asap(publishRejection, promise);
}

function subscribe(parent, child, onFulfillment, onRejection) {
  var _subscribers = parent._subscribers;
  var length = _subscribers.length;


  parent._onerror = null;

  _subscribers[length] = child;
  _subscribers[length + FULFILLED] = onFulfillment;
  _subscribers[length + REJECTED] = onRejection;

  if (length === 0 && parent._state) {
    asap(publish, parent);
  }
}

function publish(promise) {
  var subscribers = promise._subscribers;
  var settled = promise._state;

  if (subscribers.length === 0) {
    return;
  }

  var child = void 0,
      callback = void 0,
      detail = promise._result;

  for (var i = 0; i < subscribers.length; i += 3) {
    child = subscribers[i];
    callback = subscribers[i + settled];

    if (child) {
      invokeCallback(settled, child, callback, detail);
    } else {
      callback(detail);
    }
  }

  promise._subscribers.length = 0;
}

function invokeCallback(settled, promise, callback, detail) {
  var hasCallback = isFunction(callback),
      value = void 0,
      error = void 0,
      succeeded = true;

  if (hasCallback) {
    try {
      value = callback(detail);
    } catch (e) {
      succeeded = false;
      error = e;
    }

    if (promise === value) {
      reject(promise, cannotReturnOwn());
      return;
    }
  } else {
    value = detail;
  }

  if (promise._state !== PENDING) {
    // noop
  } else if (hasCallback && succeeded) {
    resolve(promise, value);
  } else if (succeeded === false) {
    reject(promise, error);
  } else if (settled === FULFILLED) {
    fulfill(promise, value);
  } else if (settled === REJECTED) {
    reject(promise, value);
  }
}

function initializePromise(promise, resolver) {
  try {
    resolver(function resolvePromise(value) {
      resolve(promise, value);
    }, function rejectPromise(reason) {
      reject(promise, reason);
    });
  } catch (e) {
    reject(promise, e);
  }
}

var id = 0;
function nextId() {
  return id++;
}

function makePromise(promise) {
  promise[PROMISE_ID] = id++;
  promise._state = undefined;
  promise._result = undefined;
  promise._subscribers = [];
}

function validationError() {
  return new Error('Array Methods must be provided an Array');
}

var Enumerator = function () {
  function Enumerator(Constructor, input) {
    this._instanceConstructor = Constructor;
    this.promise = new Constructor(noop);

    if (!this.promise[PROMISE_ID]) {
      makePromise(this.promise);
    }

    if (isArray(input)) {
      this.length = input.length;
      this._remaining = input.length;

      this._result = new Array(this.length);

      if (this.length === 0) {
        fulfill(this.promise, this._result);
      } else {
        this.length = this.length || 0;
        this._enumerate(input);
        if (this._remaining === 0) {
          fulfill(this.promise, this._result);
        }
      }
    } else {
      reject(this.promise, validationError());
    }
  }

  Enumerator.prototype._enumerate = function _enumerate(input) {
    for (var i = 0; this._state === PENDING && i < input.length; i++) {
      this._eachEntry(input[i], i);
    }
  };

  Enumerator.prototype._eachEntry = function _eachEntry(entry, i) {
    var c = this._instanceConstructor;
    var resolve$$1 = c.resolve;


    if (resolve$$1 === resolve$1) {
      var _then = void 0;
      var error = void 0;
      var didError = false;
      try {
        _then = entry.then;
      } catch (e) {
        didError = true;
        error = e;
      }

      if (_then === then && entry._state !== PENDING) {
        this._settledAt(entry._state, i, entry._result);
      } else if (typeof _then !== 'function') {
        this._remaining--;
        this._result[i] = entry;
      } else if (c === Promise$1) {
        var promise = new c(noop);
        if (didError) {
          reject(promise, error);
        } else {
          handleMaybeThenable(promise, entry, _then);
        }
        this._willSettleAt(promise, i);
      } else {
        this._willSettleAt(new c(function (resolve$$1) {
          return resolve$$1(entry);
        }), i);
      }
    } else {
      this._willSettleAt(resolve$$1(entry), i);
    }
  };

  Enumerator.prototype._settledAt = function _settledAt(state, i, value) {
    var promise = this.promise;


    if (promise._state === PENDING) {
      this._remaining--;

      if (state === REJECTED) {
        reject(promise, value);
      } else {
        this._result[i] = value;
      }
    }

    if (this._remaining === 0) {
      fulfill(promise, this._result);
    }
  };

  Enumerator.prototype._willSettleAt = function _willSettleAt(promise, i) {
    var enumerator = this;

    subscribe(promise, undefined, function (value) {
      return enumerator._settledAt(FULFILLED, i, value);
    }, function (reason) {
      return enumerator._settledAt(REJECTED, i, reason);
    });
  };

  return Enumerator;
}();

/**
  `Promise.all` accepts an array of promises, and returns a new promise which
  is fulfilled with an array of fulfillment values for the passed promises, or
  rejected with the reason of the first passed promise to be rejected. It casts all
  elements of the passed iterable to promises as it runs this algorithm.

  Example:

  ```javascript
  let promise1 = resolve(1);
  let promise2 = resolve(2);
  let promise3 = resolve(3);
  let promises = [ promise1, promise2, promise3 ];

  Promise.all(promises).then(function(array){
    // The array here would be [ 1, 2, 3 ];
  });
  ```

  If any of the `promises` given to `all` are rejected, the first promise
  that is rejected will be given as an argument to the returned promises's
  rejection handler. For example:

  Example:

  ```javascript
  let promise1 = resolve(1);
  let promise2 = reject(new Error("2"));
  let promise3 = reject(new Error("3"));
  let promises = [ promise1, promise2, promise3 ];

  Promise.all(promises).then(function(array){
    // Code here never runs because there are rejected promises!
  }, function(error) {
    // error.message === "2"
  });
  ```

  @method all
  @static
  @param {Array} entries array of promises
  @param {String} label optional string for labeling the promise.
  Useful for tooling.
  @return {Promise} promise that is fulfilled when all `promises` have been
  fulfilled, or rejected if any of them become rejected.
  @static
*/
function all(entries) {
  return new Enumerator(this, entries).promise;
}

/**
  `Promise.race` returns a new promise which is settled in the same way as the
  first passed promise to settle.

  Example:

  ```javascript
  let promise1 = new Promise(function(resolve, reject){
    setTimeout(function(){
      resolve('promise 1');
    }, 200);
  });

  let promise2 = new Promise(function(resolve, reject){
    setTimeout(function(){
      resolve('promise 2');
    }, 100);
  });

  Promise.race([promise1, promise2]).then(function(result){
    // result === 'promise 2' because it was resolved before promise1
    // was resolved.
  });
  ```

  `Promise.race` is deterministic in that only the state of the first
  settled promise matters. For example, even if other promises given to the
  `promises` array argument are resolved, but the first settled promise has
  become rejected before the other promises became fulfilled, the returned
  promise will become rejected:

  ```javascript
  let promise1 = new Promise(function(resolve, reject){
    setTimeout(function(){
      resolve('promise 1');
    }, 200);
  });

  let promise2 = new Promise(function(resolve, reject){
    setTimeout(function(){
      reject(new Error('promise 2'));
    }, 100);
  });

  Promise.race([promise1, promise2]).then(function(result){
    // Code here never runs
  }, function(reason){
    // reason.message === 'promise 2' because promise 2 became rejected before
    // promise 1 became fulfilled
  });
  ```

  An example real-world use case is implementing timeouts:

  ```javascript
  Promise.race([ajax('foo.json'), timeout(5000)])
  ```

  @method race
  @static
  @param {Array} promises array of promises to observe
  Useful for tooling.
  @return {Promise} a promise which settles in the same way as the first passed
  promise to settle.
*/
function race(entries) {
  /*jshint validthis:true */
  var Constructor = this;

  if (!isArray(entries)) {
    return new Constructor(function (_, reject) {
      return reject(new TypeError('You must pass an array to race.'));
    });
  } else {
    return new Constructor(function (resolve, reject) {
      var length = entries.length;
      for (var i = 0; i < length; i++) {
        Constructor.resolve(entries[i]).then(resolve, reject);
      }
    });
  }
}

/**
  `Promise.reject` returns a promise rejected with the passed `reason`.
  It is shorthand for the following:

  ```javascript
  let promise = new Promise(function(resolve, reject){
    reject(new Error('WHOOPS'));
  });

  promise.then(function(value){
    // Code here doesn't run because the promise is rejected!
  }, function(reason){
    // reason.message === 'WHOOPS'
  });
  ```

  Instead of writing the above, your code now simply becomes the following:

  ```javascript
  let promise = Promise.reject(new Error('WHOOPS'));

  promise.then(function(value){
    // Code here doesn't run because the promise is rejected!
  }, function(reason){
    // reason.message === 'WHOOPS'
  });
  ```

  @method reject
  @static
  @param {Any} reason value that the returned promise will be rejected with.
  Useful for tooling.
  @return {Promise} a promise rejected with the given `reason`.
*/
function reject$1(reason) {
  /*jshint validthis:true */
  var Constructor = this;
  var promise = new Constructor(noop);
  reject(promise, reason);
  return promise;
}

function needsResolver() {
  throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
}

function needsNew() {
  throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
}

/**
  Promise objects represent the eventual result of an asynchronous operation. The
  primary way of interacting with a promise is through its `then` method, which
  registers callbacks to receive either a promise's eventual value or the reason
  why the promise cannot be fulfilled.

  Terminology
  -----------

  - `promise` is an object or function with a `then` method whose behavior conforms to this specification.
  - `thenable` is an object or function that defines a `then` method.
  - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).
  - `exception` is a value that is thrown using the throw statement.
  - `reason` is a value that indicates why a promise was rejected.
  - `settled` the final resting state of a promise, fulfilled or rejected.

  A promise can be in one of three states: pending, fulfilled, or rejected.

  Promises that are fulfilled have a fulfillment value and are in the fulfilled
  state.  Promises that are rejected have a rejection reason and are in the
  rejected state.  A fulfillment value is never a thenable.

  Promises can also be said to *resolve* a value.  If this value is also a
  promise, then the original promise's settled state will match the value's
  settled state.  So a promise that *resolves* a promise that rejects will
  itself reject, and a promise that *resolves* a promise that fulfills will
  itself fulfill.


  Basic Usage:
  ------------

  ```js
  let promise = new Promise(function(resolve, reject) {
    // on success
    resolve(value);

    // on failure
    reject(reason);
  });

  promise.then(function(value) {
    // on fulfillment
  }, function(reason) {
    // on rejection
  });
  ```

  Advanced Usage:
  ---------------

  Promises shine when abstracting away asynchronous interactions such as
  `XMLHttpRequest`s.

  ```js
  function getJSON(url) {
    return new Promise(function(resolve, reject){
      let xhr = new XMLHttpRequest();

      xhr.open('GET', url);
      xhr.onreadystatechange = handler;
      xhr.responseType = 'json';
      xhr.setRequestHeader('Accept', 'application/json');
      xhr.send();

      function handler() {
        if (this.readyState === this.DONE) {
          if (this.status === 200) {
            resolve(this.response);
          } else {
            reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));
          }
        }
      };
    });
  }

  getJSON('/posts.json').then(function(json) {
    // on fulfillment
  }, function(reason) {
    // on rejection
  });
  ```

  Unlike callbacks, promises are great composable primitives.

  ```js
  Promise.all([
    getJSON('/posts'),
    getJSON('/comments')
  ]).then(function(values){
    values[0] // => postsJSON
    values[1] // => commentsJSON

    return values;
  });
  ```

  @class Promise
  @param {Function} resolver
  Useful for tooling.
  @constructor
*/

var Promise$1 = function () {
  function Promise(resolver) {
    this[PROMISE_ID] = nextId();
    this._result = this._state = undefined;
    this._subscribers = [];

    if (noop !== resolver) {
      typeof resolver !== 'function' && needsResolver();
      this instanceof Promise ? initializePromise(this, resolver) : needsNew();
    }
  }

  /**
  The primary way of interacting with a promise is through its `then` method,
  which registers callbacks to receive either a promise's eventual value or the
  reason why the promise cannot be fulfilled.
   ```js
  findUser().then(function(user){
    // user is available
  }, function(reason){
    // user is unavailable, and you are given the reason why
  });
  ```
   Chaining
  --------
   The return value of `then` is itself a promise.  This second, 'downstream'
  promise is resolved with the return value of the first promise's fulfillment
  or rejection handler, or rejected if the handler throws an exception.
   ```js
  findUser().then(function (user) {
    return user.name;
  }, function (reason) {
    return 'default name';
  }).then(function (userName) {
    // If `findUser` fulfilled, `userName` will be the user's name, otherwise it
    // will be `'default name'`
  });
   findUser().then(function (user) {
    throw new Error('Found user, but still unhappy');
  }, function (reason) {
    throw new Error('`findUser` rejected and we're unhappy');
  }).then(function (value) {
    // never reached
  }, function (reason) {
    // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.
    // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.
  });
  ```
  If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.
   ```js
  findUser().then(function (user) {
    throw new PedagogicalException('Upstream error');
  }).then(function (value) {
    // never reached
  }).then(function (value) {
    // never reached
  }, function (reason) {
    // The `PedgagocialException` is propagated all the way down to here
  });
  ```
   Assimilation
  ------------
   Sometimes the value you want to propagate to a downstream promise can only be
  retrieved asynchronously. This can be achieved by returning a promise in the
  fulfillment or rejection handler. The downstream promise will then be pending
  until the returned promise is settled. This is called *assimilation*.
   ```js
  findUser().then(function (user) {
    return findCommentsByAuthor(user);
  }).then(function (comments) {
    // The user's comments are now available
  });
  ```
   If the assimliated promise rejects, then the downstream promise will also reject.
   ```js
  findUser().then(function (user) {
    return findCommentsByAuthor(user);
  }).then(function (comments) {
    // If `findCommentsByAuthor` fulfills, we'll have the value here
  }, function (reason) {
    // If `findCommentsByAuthor` rejects, we'll have the reason here
  });
  ```
   Simple Example
  --------------
   Synchronous Example
   ```javascript
  let result;
   try {
    result = findResult();
    // success
  } catch(reason) {
    // failure
  }
  ```
   Errback Example
   ```js
  findResult(function(result, err){
    if (err) {
      // failure
    } else {
      // success
    }
  });
  ```
   Promise Example;
   ```javascript
  findResult().then(function(result){
    // success
  }, function(reason){
    // failure
  });
  ```
   Advanced Example
  --------------
   Synchronous Example
   ```javascript
  let author, books;
   try {
    author = findAuthor();
    books  = findBooksByAuthor(author);
    // success
  } catch(reason) {
    // failure
  }
  ```
   Errback Example
   ```js
   function foundBooks(books) {
   }
   function failure(reason) {
   }
   findAuthor(function(author, err){
    if (err) {
      failure(err);
      // failure
    } else {
      try {
        findBoooksByAuthor(author, function(books, err) {
          if (err) {
            failure(err);
          } else {
            try {
              foundBooks(books);
            } catch(reason) {
              failure(reason);
            }
          }
        });
      } catch(error) {
        failure(err);
      }
      // success
    }
  });
  ```
   Promise Example;
   ```javascript
  findAuthor().
    then(findBooksByAuthor).
    then(function(books){
      // found books
  }).catch(function(reason){
    // something went wrong
  });
  ```
   @method then
  @param {Function} onFulfilled
  @param {Function} onRejected
  Useful for tooling.
  @return {Promise}
  */

  /**
  `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same
  as the catch block of a try/catch statement.
  ```js
  function findAuthor(){
  throw new Error('couldn't find that author');
  }
  // synchronous
  try {
  findAuthor();
  } catch(reason) {
  // something went wrong
  }
  // async with promises
  findAuthor().catch(function(reason){
  // something went wrong
  });
  ```
  @method catch
  @param {Function} onRejection
  Useful for tooling.
  @return {Promise}
  */


  Promise.prototype.catch = function _catch(onRejection) {
    return this.then(null, onRejection);
  };

  /**
    `finally` will be invoked regardless of the promise's fate just as native
    try/catch/finally behaves
  
    Synchronous example:
  
    ```js
    findAuthor() {
      if (Math.random() > 0.5) {
        throw new Error();
      }
      return new Author();
    }
  
    try {
      return findAuthor(); // succeed or fail
    } catch(error) {
      return findOtherAuther();
    } finally {
      // always runs
      // doesn't affect the return value
    }
    ```
  
    Asynchronous example:
  
    ```js
    findAuthor().catch(function(reason){
      return findOtherAuther();
    }).finally(function(){
      // author was either found, or not
    });
    ```
  
    @method finally
    @param {Function} callback
    @return {Promise}
  */


  Promise.prototype.finally = function _finally(callback) {
    var promise = this;
    var constructor = promise.constructor;

    if (isFunction(callback)) {
      return promise.then(function (value) {
        return constructor.resolve(callback()).then(function () {
          return value;
        });
      }, function (reason) {
        return constructor.resolve(callback()).then(function () {
          throw reason;
        });
      });
    }

    return promise.then(callback, callback);
  };

  return Promise;
}();

Promise$1.prototype.then = then;
Promise$1.all = all;
Promise$1.race = race;
Promise$1.resolve = resolve$1;
Promise$1.reject = reject$1;
Promise$1._setScheduler = setScheduler;
Promise$1._setAsap = setAsap;
Promise$1._asap = asap;

/*global self*/
function polyfill() {
  var local = void 0;

  if (typeof global !== 'undefined') {
    local = global;
  } else if (typeof self !== 'undefined') {
    local = self;
  } else {
    try {
      local = Function('return this')();
    } catch (e) {
      throw new Error('polyfill failed because global object is unavailable in this environment');
    }
  }

  var P = local.Promise;

  if (P) {
    var promiseToString = null;
    try {
      promiseToString = Object.prototype.toString.call(P.resolve());
    } catch (e) {
      // silently ignored
    }

    if (promiseToString === '[object Promise]' && !P.cast) {
      return;
    }
  }

  local.Promise = Promise$1;
}

// Strange compat..
Promise$1.polyfill = polyfill;
Promise$1.Promise = Promise$1;

return Promise$1;

})));



//# sourceMappingURL=es6-promise.map

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../process/browser.js */ "./node_modules/process/browser.js"), __webpack_require__(/*! ./../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "./node_modules/setimmediate/setImmediate.js":
/*!***************************************************!*\
  !*** ./node_modules/setimmediate/setImmediate.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
    "use strict";

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var registerImmediate;

    function setImmediate(callback) {
      // Callback can either be a function or a string
      if (typeof callback !== "function") {
        callback = new Function("" + callback);
      }
      // Copy function arguments
      var args = new Array(arguments.length - 1);
      for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i + 1];
      }
      // Store and register the task
      var task = { callback: callback, args: args };
      tasksByHandle[nextHandle] = task;
      registerImmediate(nextHandle);
      return nextHandle++;
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function run(task) {
        var callback = task.callback;
        var args = task.args;
        switch (args.length) {
        case 0:
            callback();
            break;
        case 1:
            callback(args[0]);
            break;
        case 2:
            callback(args[0], args[1]);
            break;
        case 3:
            callback(args[0], args[1], args[2]);
            break;
        default:
            callback.apply(undefined, args);
            break;
        }
    }

    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(runIfPresent, 0, handle);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    run(task);
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    function installNextTickImplementation() {
        registerImmediate = function(handle) {
            process.nextTick(function () { runIfPresent(handle); });
        };
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function() {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }

    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function(event) {
            if (event.source === global &&
                typeof event.data === "string" &&
                event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
        } else {
            global.attachEvent("onmessage", onGlobalMessage);
        }

        registerImmediate = function(handle) {
            global.postMessage(messagePrefix + handle, "*");
        };
    }

    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function(event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        registerImmediate = function(handle) {
            channel.port2.postMessage(handle);
        };
    }

    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        registerImmediate = function(handle) {
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
        };
    }

    function installSetTimeoutImplementation() {
        registerImmediate = function(handle) {
            setTimeout(runIfPresent, 0, handle);
        };
    }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if ({}.toString.call(global.process) === "[object process]") {
        // For Node.js before 0.9
        installNextTickImplementation();

    } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
        installPostMessageImplementation();

    } else if (global.MessageChannel) {
        // For web workers, where supported
        installMessageChannelImplementation();

    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        // For IE 6–8
        installReadyStateChangeImplementation();

    } else {
        // For older browsers
        installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/timers-browserify/main.js":
/*!************************************************!*\
  !*** ./node_modules/timers-browserify/main.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var scope = (typeof global !== "undefined" && global) ||
            (typeof self !== "undefined" && self) ||
            window;
var apply = Function.prototype.apply;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) {
  if (timeout) {
    timeout.close();
  }
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(scope, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// setimmediate attaches itself to the global object
__webpack_require__(/*! setimmediate */ "./node_modules/setimmediate/setImmediate.js");
// On some exotic environments, it's not clear which object `setimmediate` was
// able to install onto.  Search each possibility in the same order as the
// `setimmediate` library.
exports.setImmediate = (typeof self !== "undefined" && self.setImmediate) ||
                       (typeof global !== "undefined" && global.setImmediate) ||
                       (this && this.setImmediate);
exports.clearImmediate = (typeof self !== "undefined" && self.clearImmediate) ||
                         (typeof global !== "undefined" && global.clearImmediate) ||
                         (this && this.clearImmediate);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/ts-loader/index.js?!./node_modules/vue-loader/lib/index.js?!./src/js/components/AutoSuggest.vue?vue&type=script&lang=ts&":
/*!*******************************************************************************************************************************************************!*\
  !*** ./node_modules/ts-loader??ref--5!./node_modules/vue-loader/lib??vue-loader-options!./src/js/components/AutoSuggest.vue?vue&type=script&lang=ts& ***!
  \*******************************************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
var __assign = (undefined && undefined.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};

/* harmony default export */ __webpack_exports__["default"] = (vue__WEBPACK_IMPORTED_MODULE_0__["default"].extend({
    props: {
        options: {
            type: Array,
        },
        input_attrs: {
            type: Object,
            default: function () {
                return {};
            }
        },
        restricted: {
            type: Boolean,
            default: false
        },
        initial_value: {
            type: Object,
            required: false
        }
    },
    data: function () {
        return {
            /**
             * User-entered text input
             */
            active_input_text: "",
            /**
             * Index of the active suggestion
             */
            active_suggestion_index: -1,
            /**
             * The active tracked value for the component
             */
            active_value: {
                label: "",
                value: null
            },
            /**
             * Whether to hide the suggestions list
             */
            hide_suggestions: false,
            /**
             * Whether the input is currently focused
             */
            input_focused: false,
            /**
             * Whether an option from suggestions list has been clicked as the most recent action
             */
            option_clicked: false,
            /**
             * Whether the component has been loaded and should start emitting changes
             */
            loaded: false,
            suggestions: [],
            suggestions_debounce: false
        };
    },
    /**
     * Load initial value if present
     */
    created: function () {
        if (this.initial_value) {
            this.active_value = __assign({}, this.initial_value);
            this.active_input_text = this.initial_value.label;
        }
        this.loaded = true;
    },
    methods: {
        /**
         * Handle mousedown on suggestion
         */
        mouseDown: function () {
            this.option_clicked = true;
        },
        /**
         * Handle focus on input
         */
        handleFocus: function () {
            this.input_focused = true;
        },
        /**
         * Handle blur on input
         */
        handleBlur: function () {
            this.input_focused = false;
        },
        /**
         * Handle direct content change on input element
         */
        handleInput: function (event) {
            var _this = this;
            this.suggestions = [];
            this.option_clicked = false;
            this.active_value.value = null;
            this.active_value.label = event.target.value;
            if (this.suggestions_debounce) {
                clearTimeout(this.suggestions_debounce);
            }
            this.suggestions_debounce = window.setTimeout(function () {
                _this.suggestions = _this.getSuggestions();
                _this.suggestions_debounce = false;
            }, 200);
        },
        /**
         * Whether a suggest item is the active suggest item
         */
        isActive: function (index) {
            return index === this.active_suggestion_index;
        },
        /**
         * Handle the user tabbing out of input
         */
        handleTab: function () {
            if (this.hide_suggestions) {
                return;
            }
            if (this.active_suggestion) {
                this.select(this.active_suggestion);
            }
            if (this.suggestions.length === 1) {
                this.select(this.suggestions[0]);
            }
        },
        /**
         * Handle down key event
         */
        handleDown: function () {
            if (this.hide_suggestions) {
                return;
            }
            if (this.active_suggestion_index === this.suggestions.length - 1) {
                return;
            }
            this.active_suggestion_index++;
        },
        /**
         * Handle up key event
         */
        handleUp: function () {
            if (this.hide_suggestions) {
                return;
            }
            if (this.active_suggestion_index === -1) {
                return;
            }
            this.active_suggestion_index--;
        },
        /**
         * Handle enter key event
         */
        handleEnter: function () {
            if (this.active_suggestion) {
                this.select(this.active_suggestion);
            }
        },
        /**
         * Select a form option
         */
        select: function (option) {
            var _this = this;
            this.active_value = __assign({}, option);
            this.active_input_text = option.label;
            vue__WEBPACK_IMPORTED_MODULE_0__["default"].nextTick(function () {
                _this.hide_suggestions = true;
            });
        },
        /**
         * Handle component blur.
         * 1. Hide suggestions list
         * 2. If restricted version, and a valid value not picked, reset the display text
         */
        componentBlur: function () {
            this.hide_suggestions = true;
            if (this.restricted && !this.active_value.value) {
                this.active_input_text = "";
            }
        },
        /**
         * The suggestions based on current input
         */
        getSuggestions: function () {
            var _this = this;
            if (!this.options) {
                return [];
            }
            return this.options.filter(function (option) {
                if (!_this.active_input_text) {
                    return false;
                }
                return option.label.toLowerCase().indexOf(_this.active_input_text.toLowerCase()) !== -1;
            });
        }
    },
    computed: {
        /**
         * The active suggest item, if present
         */
        active_suggestion: function () {
            if (this.active_suggestion_index > -1 && this.active_suggestion_index < this.suggestions.length) {
                return this.suggestions[this.active_suggestion_index];
            }
            return false;
        },
        /**
         * Whether to show suggestions
         */
        show_suggestions: function () {
            if (!this.suggestions.length) {
                return false;
            }
            return !this.hide_suggestions;
        }
    },
    watch: {
        /**
         *  When the user changes the input, start showing results again and reset the active index
         */
        active_input_text: function () {
            this.hide_suggestions = false;
            this.active_suggestion_index = -1;
        },
        /**
         * When active value changes, emit the change
         */
        active_value: {
            handler: function (value) {
                if (!this.loaded) {
                    return;
                }
                if (this.restricted && value.value === null) {
                    this.$emit('input', {
                        label: null,
                        value: null
                    });
                    return;
                }
                this.$emit('input', value);
            },
            deep: true
        },
        /**
         * When input focus changes...
         */
        input_focused: function (value) {
            var _this = this;
            if (value === false) {
                vue__WEBPACK_IMPORTED_MODULE_0__["default"].nextTick(function () {
                    // if blur results from an option click, do nothing
                    if (_this.option_clicked) {
                        return;
                    }
                    //trigger component blur event
                    _this.componentBlur();
                });
            }
        }
    }
}));


/***/ }),

/***/ "./node_modules/ts-loader/index.js?!./node_modules/vue-loader/lib/index.js?!./src/js/components/CompetitionRegistration/CompetitionRegistrationProgress.vue?vue&type=script&lang=ts&":
/*!***************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/ts-loader??ref--5!./node_modules/vue-loader/lib??vue-loader-options!./src/js/components/CompetitionRegistration/CompetitionRegistrationProgress.vue?vue&type=script&lang=ts& ***!
  \***************************************************************************************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _mixins_HasCompetitionRegistrationCompetitionMixin__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../mixins/HasCompetitionRegistrationCompetitionMixin */ "./src/js/mixins/HasCompetitionRegistrationCompetitionMixin.ts");
/* harmony import */ var vue_typed_mixins__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vue-typed-mixins */ "./node_modules/vue-typed-mixins/lib/index.js");
/* harmony import */ var _ProgressBar_vue__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../ProgressBar.vue */ "./src/js/components/ProgressBar.vue");



/* harmony default export */ __webpack_exports__["default"] = (Object(vue_typed_mixins__WEBPACK_IMPORTED_MODULE_1__["default"])(_mixins_HasCompetitionRegistrationCompetitionMixin__WEBPACK_IMPORTED_MODULE_0__["default"]).extend({
    props: {
        active_step: {
            type: Number,
            required: true
        }
    },
    computed: {
        total_registration_steps: function () {
            if (!this.active_competition) {
                return 0;
            }
            if (this.competition.has_partner_events) {
                return 7;
            }
            return 5;
        }
    },
    components: {
        ProgressBar: _ProgressBar_vue__WEBPACK_IMPORTED_MODULE_2__["default"]
    }
}));


/***/ }),

/***/ "./node_modules/ts-loader/index.js?!./node_modules/vue-loader/lib/index.js?!./src/js/components/CompetitionRegistration/CompetitionSearch.vue?vue&type=script&lang=ts&":
/*!*************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/ts-loader??ref--5!./node_modules/vue-loader/lib??vue-loader-options!./src/js/components/CompetitionRegistration/CompetitionSearch.vue?vue&type=script&lang=ts& ***!
  \*************************************************************************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");

/* harmony default export */ __webpack_exports__["default"] = (vue__WEBPACK_IMPORTED_MODULE_0__["default"].extend({
    props: {
        state_options: {
            type: Array,
            required: true
        }
    },
    data: function () {
        return {
            /**
             * The form option selected for the field to search against
             */
            search_field: null,
            /**
             * The options available for the search field
             */
            field_options: [
                {
                    label: "Competition Name",
                    value: "name"
                },
                {
                    label: "City",
                    value: "city"
                },
                {
                    label: "Club Name",
                    value: "club"
                },
                {
                    label: "Date",
                    value: "date"
                },
                {
                    label: "State",
                    value: "state"
                },
            ],
            /**
             * The currently entered search term
             */
            search_term: null
        };
    },
    methods: {
        /**
         * Clear the search
         */
        reset: function () {
            this.search_field = null;
        },
        /**
         * Emit event indicating search value change
         */
        emit: function () {
            this.$emit('input', {
                search_term: this.search_term,
                search_field: this.search_field ? this.search_field.value : null,
            });
        }
    },
    /**
     * Emit event on component update
     */
    updated: function () {
        this.emit();
    },
    watch: {
        /**
         * Clear the search term when the field changes
         */
        search_field: function () {
            this.search_term = null;
        }
    },
    computed: {
        /**
         * The placeholder for the search input
         */
        input_placeholder: function () {
            if (this.search_field) {
                return "Enter " + this.search_field.label;
            }
            return "";
        }
    }
}));


/***/ }),

/***/ "./node_modules/ts-loader/index.js?!./node_modules/vue-loader/lib/index.js?!./src/js/components/CompetitionRegistration/EventRequirementsOverlay.vue?vue&type=script&lang=ts&":
/*!********************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/ts-loader??ref--5!./node_modules/vue-loader/lib??vue-loader-options!./src/js/components/CompetitionRegistration/EventRequirementsOverlay.vue?vue&type=script&lang=ts& ***!
  \********************************************************************************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
var __assign = (undefined && undefined.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};

/* harmony default export */ __webpack_exports__["default"] = (vue__WEBPACK_IMPORTED_MODULE_0__["default"].extend({
    props: {
        requirements_data: {
            type: Object,
            required: true
        }
    },
    data: function () {
        return {
            /**
             * The list of minimum skate tests
             */
            minimum_skate_tests: false,
            /**
             * The list of maximum skate tests
             */
            maximum_skate_tests: false,
            /**
             * The minimum age requirement
             */
            minimum_age: false,
            /**
             * The maximum age requirement
             */
            maximum_age: false
        };
    },
    /**
     * When component created, import requirements data
     */
    created: function () {
        var _a = __assign({}, this.requirements_data.event.requirements), minimum_skate_tests = _a.minimum_skate_tests, maximum_skate_tests = _a.maximum_skate_tests, minimum_age = _a.minimum_age, maximum_age = _a.maximum_age;
        this.minimum_skate_tests = minimum_skate_tests && minimum_skate_tests.length ? minimum_skate_tests : false;
        this.maximum_skate_tests = maximum_skate_tests && maximum_skate_tests.length ? maximum_skate_tests : false;
        this.minimum_age = minimum_age !== null ? minimum_age : false;
        this.maximum_age = maximum_age !== null ? maximum_age : false;
    },
    computed: {
        /**
         * Whether to show the minimum age requirement block
         */
        show_min_age: function () {
            return this.minimum_age !== false;
        },
        /**
         * Whether to show the maximum age requirement block
         */
        show_max_age: function () {
            return this.maximum_age !== false;
        },
        /**
         * Whether to show the maximum skate tests requirement block
         */
        show_max_skate_tests: function () {
            return this.maximum_skate_tests !== false;
        },
        /**
         * Whether to show the minimum skate tests requirement block
         */
        show_min_skate_tests: function () {
            return this.minimum_skate_tests !== false;
        },
        /**
         * Whether to show the entire skate test requirements section
         */
        show_skate_test_requirements: function () {
            return this.show_min_skate_tests || this.show_max_skate_tests;
        },
        /**
         * Whether to show the entire age requirements section
         */
        show_age_requirements: function () {
            return this.show_min_age || this.show_max_age;
        }
    }
}));


/***/ }),

/***/ "./node_modules/ts-loader/index.js?!./node_modules/vue-loader/lib/index.js?!./src/js/components/CompetitionRegistration/EventSelection.vue?vue&type=script&lang=ts&":
/*!**********************************************************************************************************************************************************************************!*\
  !*** ./node_modules/ts-loader??ref--5!./node_modules/vue-loader/lib??vue-loader-options!./src/js/components/CompetitionRegistration/EventSelection.vue?vue&type=script&lang=ts& ***!
  \**********************************************************************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _mixins_EventSelectionMixin__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../mixins/EventSelectionMixin */ "./src/js/mixins/EventSelectionMixin.ts");
/* harmony import */ var vue_typed_mixins__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vue-typed-mixins */ "./node_modules/vue-typed-mixins/lib/index.js");
/* harmony import */ var _EventSelectionEvent_vue__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./EventSelectionEvent.vue */ "./src/js/components/CompetitionRegistration/EventSelectionEvent.vue");



var extendedVue = Object(vue_typed_mixins__WEBPACK_IMPORTED_MODULE_1__["default"])(_mixins_EventSelectionMixin__WEBPACK_IMPORTED_MODULE_0__["default"]);
/* harmony default export */ __webpack_exports__["default"] = (extendedVue.extend({
    components: {
        EventSelectionCard: _EventSelectionEvent_vue__WEBPACK_IMPORTED_MODULE_2__["default"]
    },
    methods: {
        /**
         * Action to perform add event
         */
        addEventAction: function (event) {
            return this.$store.dispatch('competition_registration/addEvent', event);
        },
        /**
         * Action to perform remove event
         */
        removeEventAction: function (event) {
            return this.$store.dispatch('competition_registration/removeEvent', event);
        }
    }
}));


/***/ }),

/***/ "./node_modules/ts-loader/index.js?!./node_modules/vue-loader/lib/index.js?!./src/js/components/CompetitionRegistration/EventSelectionEvent.vue?vue&type=script&lang=ts&":
/*!***************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/ts-loader??ref--5!./node_modules/vue-loader/lib??vue-loader-options!./src/js/components/CompetitionRegistration/EventSelectionEvent.vue?vue&type=script&lang=ts& ***!
  \***************************************************************************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");

/* harmony default export */ __webpack_exports__["default"] = (vue__WEBPACK_IMPORTED_MODULE_0__["default"].extend({
    props: {
        /**
         * The competition to populate the card
         */
        event: {
            type: Object,
            required: true
        }
    }
}));


/***/ }),

/***/ "./node_modules/ts-loader/index.js?!./node_modules/vue-loader/lib/index.js?!./src/js/components/CompetitionRegistration/SelectRepresentation.vue?vue&type=script&lang=ts&":
/*!****************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/ts-loader??ref--5!./node_modules/vue-loader/lib??vue-loader-options!./src/js/components/CompetitionRegistration/SelectRepresentation.vue?vue&type=script&lang=ts& ***!
  \****************************************************************************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");

/* harmony default export */ __webpack_exports__["default"] = (vue__WEBPACK_IMPORTED_MODULE_0__["default"].extend({
    data: function () {
        return {
            /**
             * The active representation type
             */
            representation_type: "home_club",
            /**
             * The active LTS Program
             */
            lts_program: null,
            /**
             * Whether the component is in the process of saving
             */
            saving: false,
            /**
             * Saving error message to display
             */
            save_error: null,
            /**
             * Whether initial component load has completed
             */
            component_loaded: false
        };
    },
    /**
     * Set initial values on component load.
     * If representation has been saved, honor it.
     * If the user doesn't have a home club, default to lts_program
     */
    created: function () {
        var _this = this;
        var existing_representation = this.$store.getters['competition_registration/selected_representation'];
        if (!existing_representation) {
            if (!this.user_club) {
                this.representation_type = "lts_program";
            }
            return;
        }
        this.representation_type = existing_representation.representation_type;
        if (existing_representation.lts_program) {
            //ensure the previously selected organization is still an available value
            for (var i = 0; i < this.lts_programs.length; i++) {
                var argument = this.lts_programs[i];
                if (argument.value === existing_representation.lts_program) {
                    this.lts_program = argument.value;
                }
            }
        }
        //Wait for next tick to prevent reset of initial values
        vue__WEBPACK_IMPORTED_MODULE_0__["default"].nextTick(function () {
            _this.component_loaded = true;
        });
    },
    methods: {
        /**
         * Save the selection
         */
        saveRepresentation: function () {
            var _this = this;
            if (!this.representation_type) {
                return;
            }
            this.saving = true;
            this.save_error = null;
            var representation_selection = {
                representation_type: this.representation_type,
                lts_program: this.lts_program
            };
            this.$store.dispatch('competition_registration/selectRepresentation', representation_selection).then(function () {
                _this.$emit('saved');
                _this.saving = false;
            }).catch(function (save_error) {
                _this.saving = false;
                _this.save_error = save_error;
            });
        }
    },
    computed: {
        /**
         * Active user's profile.  Fetched in parent components. Used for option population
         */
        user_profile: function () {
            return this.$store.getters['user/profile'];
        },
        /**
         * The active user's club, if it exists
         */
        user_club: function () {
            if (!this.user_profile) {
                return null;
            }
            return this.user_profile.home_club;
        },
        /**
         * The active user's lts programs, if they exist
         */
        lts_programs: function () {
            if (!this.user_profile) {
                return [];
            }
            if (this.user_profile.lts_programs) {
                return this.user_profile.lts_programs.programs;
            }
            return [];
        },
        /**
         * Whether to show the secondary set of inputs on the form
         */
        show_sub_organization: function () {
            return this.representation_type === "lts_program";
        },
        /**
         * Whether the save button should be disabled
         */
        save_disabled: function () {
            if (this.saving) {
                return true;
            }
            if (this.representation_type === null) {
                return true;
            }
            if (this.show_sub_organization && this.lts_program === null) {
                return true;
            }
            return false;
        },
        /**
         * Text to display in the button
         */
        button_text: function () {
            return this.saving ? "Saving" : "Save";
        }
    },
    watch: {
        /**
         * Watch representation type change and clear secondary form values
         */
        representation_type: function () {
            if (!this.component_loaded) {
                return;
            }
            this.lts_program = null;
        }
    }
}));


/***/ }),

/***/ "./node_modules/ts-loader/index.js?!./node_modules/vue-loader/lib/index.js?!./src/js/components/DateInput.vue?vue&type=script&lang=ts&":
/*!*****************************************************************************************************************************************************!*\
  !*** ./node_modules/ts-loader??ref--5!./node_modules/vue-loader/lib??vue-loader-options!./src/js/components/DateInput.vue?vue&type=script&lang=ts& ***!
  \*****************************************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");

/* harmony default export */ __webpack_exports__["default"] = (vue__WEBPACK_IMPORTED_MODULE_0__["default"].extend({
    props: {
        initial: {
            required: false
        }
    },
    /**
     * Upon creation, assign default value if present
     */
    created: function () {
        this.value = this.initial ? String(this.initial) : "";
    },
    data: function () {
        return {
            value: "",
        };
    },
    methods: {
        valueChanged: function (value) {
            this.value = value;
        },
        export: function () {
            this.$emit('input', this.formatted);
        }
    },
    updated: function () {
        this.export();
    },
    computed: {
        formatted: function () {
            return this.value;
        }
    },
    watch: {
        /**
         * Watch initial value.  If it changes, update local value
         */
        initial: function () {
            this.value = this.initial ? String(this.initial) : '';
        }
    }
}));


/***/ }),

/***/ "./node_modules/ts-loader/index.js?!./node_modules/vue-loader/lib/index.js?!./src/js/components/EditProfile.vue?vue&type=script&lang=ts&":
/*!*******************************************************************************************************************************************************!*\
  !*** ./node_modules/ts-loader??ref--5!./node_modules/vue-loader/lib??vue-loader-options!./src/js/components/EditProfile.vue?vue&type=script&lang=ts& ***!
  \*******************************************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var vue_typed_mixins__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue-typed-mixins */ "./node_modules/vue-typed-mixins/lib/index.js");
/* harmony import */ var _mixins_FormMixin__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../mixins/FormMixin */ "./src/js/mixins/FormMixin.ts");
/* harmony import */ var _models_Forms_EditProfileFormState__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../models/Forms/EditProfileFormState */ "./src/js/models/Forms/EditProfileFormState.ts");
/* harmony import */ var _models_Forms_EditProfileFormValidator__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../models/Forms/EditProfileFormValidator */ "./src/js/models/Forms/EditProfileFormValidator.ts");
/* harmony import */ var _mixins_HasDataDependencies__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../mixins/HasDataDependencies */ "./src/js/mixins/HasDataDependencies.ts");





/* harmony default export */ __webpack_exports__["default"] = (Object(vue_typed_mixins__WEBPACK_IMPORTED_MODULE_0__["default"])(_mixins_FormMixin__WEBPACK_IMPORTED_MODULE_1__["default"], _mixins_HasDataDependencies__WEBPACK_IMPORTED_MODULE_4__["default"]).extend({
    props: {
        /**
         * The section to display as open when the component loads
         */
        init_section: {
            type: String,
            default: ""
        }
    },
    data: function () {
        return {
            /**
             * The validator to use against the form data
             */
            validator_class: _models_Forms_EditProfileFormValidator__WEBPACK_IMPORTED_MODULE_3__["EditProfileFormValidator"],
            /**
             * State form data class
             */
            form_data: new _models_Forms_EditProfileFormState__WEBPACK_IMPORTED_MODULE_2__["EditProfileFormState"](),
            /**
             * Whether a submission attempt has been made
             */
            dependencies: {
                form_options: false
            },
            /**
             * Whether the component is saving
             */
            saving: false,
            /**
             * Save error on the component
             */
            save_error: null
        };
    },
    /**
     * Import saved profile into form on creation
     */
    created: function () {
        this.form_data.import(this.saved_profile);
    },
    methods: {
        /**
         * Load data needed for the component
         */
        loadData: function () {
            var _this = this;
            return new Promise(function (resolve, reject) {
                _this.$store.dispatch('form_options/fetchEditProfileOptions').then(function () {
                    _this.dependencies.form_options = true;
                    resolve();
                }).catch(function () {
                    reject();
                });
            });
        },
        /**
         * Gender display formatting
         */
        displayGender: function (gender_key) {
            return gender_key.toLowerCase().replace(/^[a-z]/, function (letter) {
                return letter.toUpperCase();
            });
        },
        /**
         * Open all the expandable sections of the form
         */
        openAllAccordions: function () {
            for (var i in this.$children) {
                var $child = this.$children[i];
                if ("open" in $child && typeof $child.open === "function") {
                    $child.open();
                }
            }
        },
        /**
         * Save the active form
         */
        save: function () {
            var _this = this;
            this.submit_attempt = true;
            this.save_error = null;
            // If invalid, open all accordions and scroll to the first error field
            if (!this.valid) {
                this.openAllAccordions();
                this.$nextTick(function () {
                    var first_error_field = _this.$el.querySelector('.form-field.has-error');
                    var error_parent = first_error_field ? first_error_field.parentNode : false;
                    if (error_parent) {
                        error_parent.scrollIntoView();
                    }
                });
                return;
            }
            this.saving = true;
            this.$store.dispatch('user/saveProfile', this.form_data).then(function () {
                _this.$emit('saved');
                _this.saving = false;
            }).catch(function (save_error) {
                _this.saving = false;
                _this.save_error = save_error;
            });
        }
    },
    computed: {
        /**
         * The current user's saved profile
         */
        saved_profile: function () {
            return this.$store.getters['user/profile'];
        },
        /**
         * Name to display for the user
         */
        display_name: function () {
            return this.saved_profile.full_name;
        },
        /**
         * Member number to display for the user
         */
        display_member_number: function () {
            return this.saved_profile.member_number;
        },
        /**
         * Form options for the form inputs
         */
        form_options: function () {
            return this.$store.getters['form_options/edit_profile_options'];
        }
    }
}));


/***/ }),

/***/ "./node_modules/ts-loader/index.js?!./node_modules/vue-loader/lib/index.js?!./src/js/components/ProgressBar.vue?vue&type=script&lang=ts&":
/*!*******************************************************************************************************************************************************!*\
  !*** ./node_modules/ts-loader??ref--5!./node_modules/vue-loader/lib??vue-loader-options!./src/js/components/ProgressBar.vue?vue&type=script&lang=ts& ***!
  \*******************************************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");

/* harmony default export */ __webpack_exports__["default"] = (vue__WEBPACK_IMPORTED_MODULE_0__["default"].extend({
    props: {
        /**
         * The number of total steps
         */
        available_step_count: {
            type: Number,
            required: true,
        },
        /**
         * The current step number
         */
        active_step_number: {
            type: Number,
            required: true,
        },
    },
    computed: {
        /**
         * Calculated total progress percent
         */
        completed_progress_percent: function () {
            return (this.active_step_number) / (this.available_step_count) * 100;
        },
    }
}));


/***/ }),

/***/ "./node_modules/ts-loader/index.js?!./node_modules/vue-loader/lib/index.js?!./src/js/components/SkateTestEquivalency/DisciplineForm.vue?vue&type=script&lang=ts&":
/*!*******************************************************************************************************************************************************************************!*\
  !*** ./node_modules/ts-loader??ref--5!./node_modules/vue-loader/lib??vue-loader-options!./src/js/components/SkateTestEquivalency/DisciplineForm.vue?vue&type=script&lang=ts& ***!
  \*******************************************************************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _mixins_FormMixin__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../mixins/FormMixin */ "./src/js/mixins/FormMixin.ts");
/* harmony import */ var _mixins_HasDataDependencies__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../mixins/HasDataDependencies */ "./src/js/mixins/HasDataDependencies.ts");
/* harmony import */ var vue_typed_mixins__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vue-typed-mixins */ "./node_modules/vue-typed-mixins/lib/index.js");
/* harmony import */ var _models_SkateTestEquivalency_SkateTestDisciplineFormState__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../models/SkateTestEquivalency/SkateTestDisciplineFormState */ "./src/js/models/SkateTestEquivalency/SkateTestDisciplineFormState.ts");
/* harmony import */ var _models_SkateTestEquivalency_SkateTestDisciplineFormValidator__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../models/SkateTestEquivalency/SkateTestDisciplineFormValidator */ "./src/js/models/SkateTestEquivalency/SkateTestDisciplineFormValidator.ts");
/* harmony import */ var _components_AutoSuggest_vue__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../components/AutoSuggest.vue */ "./src/js/components/AutoSuggest.vue");






/* harmony default export */ __webpack_exports__["default"] = (Object(vue_typed_mixins__WEBPACK_IMPORTED_MODULE_2__["default"])(_mixins_FormMixin__WEBPACK_IMPORTED_MODULE_0__["default"], _mixins_HasDataDependencies__WEBPACK_IMPORTED_MODULE_1__["default"]).extend({
    props: {
        existing_data: {
            type: Object,
            default: null
        },
        discipline_key: {
            type: String
        },
        form_test_options: {
            type: Array,
            required: false
        },
        is_equivalency: {
            type: Boolean,
            default: true
        },
        allow_cancel: {
            type: Boolean,
            default: true
        },
        external_error: {
            type: String,
            required: false
        },
        submitting: {
            type: Boolean,
            default: false
        },
        club_autosuggest: {
            type: Object,
            default: function () {
                return {
                    active: false,
                };
            }
        },
    },
    data: function () {
        return {
            dependencies: {
                club_options: false
            },
            form_data: new _models_SkateTestEquivalency_SkateTestDisciplineFormState__WEBPACK_IMPORTED_MODULE_3__["default"](this.is_equivalency),
            validator_class: _models_SkateTestEquivalency_SkateTestDisciplineFormValidator__WEBPACK_IMPORTED_MODULE_4__["SkateTestDisciplineFormValidator"]
        };
    },
    /**
     * Import existing data if it exists
     */
    created: function () {
        this.form_data.import(this.existing_data);
    },
    methods: {
        loadData: function () {
            var _this = this;
            return new Promise(function (resolve, reject) {
                if (!_this.club_autosuggest.active) {
                    _this.dependencies.club_options = true;
                    resolve();
                    return;
                }
                var promises = [
                    _this.$store.dispatch('form_options/fetchClubs').then(function () {
                        _this.dependencies.club_options = true;
                    }).catch(function () {
                        reject();
                    })
                ];
                Promise.all(promises).then(function () {
                    resolve();
                });
            });
        },
        /**
         * Handle change event on club autosuggest input
         */
        clubChange: function (value) {
            this.form_data.club = value.label;
            this.form_data.club_id = value.value;
        },
        /**
         * Cancel the form
         */
        cancel: function () {
            this.$emit('cancel');
        },
        /**
         * Complete the form
         */
        complete: function () {
            this.submit_attempt = true;
            if (!this.valid) {
                return;
            }
            this.$emit('complete', this.form_data.export());
        }
    },
    computed: {
        /**
         * The minimum selectable test level based on existing selections
         */
        minimum_level: function () {
            if (this.existing_data) {
                return this.existing_data.test.level_id;
            }
            return 0;
        },
        /**
         * Options for the test input
         */
        test_options: function () {
            var _this = this;
            if (this.form_test_options) {
                return this.form_test_options;
            }
            var discipline_options = this.$store.getters['form_options/skate_test_options'](this.discipline_key);
            return discipline_options.filter(function (item) {
                return item.level_id >= _this.minimum_level;
            });
        },
        clubs: function () {
            return this.$store.getters['form_options/clubs'];
        },
        show_auto_suggest: function () {
            return this.club_autosuggest.active;
        }
    },
    components: {
        AutoSuggest: _components_AutoSuggest_vue__WEBPACK_IMPORTED_MODULE_5__["default"]
    }
}));


/***/ }),

/***/ "./node_modules/ts-loader/index.js?!./node_modules/vue-loader/lib/index.js?!./src/js/components/SkateTestHistory/SkateTestHistory.vue?vue&type=script&lang=ts&":
/*!*****************************************************************************************************************************************************************************!*\
  !*** ./node_modules/ts-loader??ref--5!./node_modules/vue-loader/lib??vue-loader-options!./src/js/components/SkateTestHistory/SkateTestHistory.vue?vue&type=script&lang=ts& ***!
  \*****************************************************************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");

/**
 * Component for displaying current state of user's skate test history, and controls to modify it
 */
/* harmony default export */ __webpack_exports__["default"] = (vue__WEBPACK_IMPORTED_MODULE_0__["default"].extend({
    props: {
        /**
         * Function to handle the removal of a self-reported test.
         * Overrides default test removal flow
         */
        delete_handler: {
            type: Function,
            required: false
        }
    },
    data: function () {
        return {
            /**
             * The indicies representing the location of a test.
             * First item is the index of the discipline in the discipline list
             * Second item is the test index in the test loop within the discipline list
             */
            active_remove_indices: null,
            /**
             * The active error message returned by the delete handler
             */
            error_message: ""
        };
    },
    methods: {
        /**
         * Whether a test item, indicated by discipline and test indices, is the the item currently in the process
         * of being deleted
         */
        isActiveItem: function (test_indices) {
            if (!this.active_remove_indices || test_indices.length !== 2 || this.active_remove_indices.length !== 2) {
                return false;
            }
            return (test_indices[0] === this.active_remove_indices[0] &&
                test_indices[1] === this.active_remove_indices[1]);
        },
        /**
         * The error associated with a test item, indicated by discipline and test indices
         */
        testError: function (test_indices) {
            if (!this.error_message || !this.isActiveItem(test_indices)) {
                return false;
            }
            return this.error_message;
        },
        /**
         * Add a new test.  Update state to launch the form to add test.
         */
        addTest: function (discipline) {
            this.error_message = "";
            this.$store.commit('skate_test_history/setActiveDiscipline', discipline);
        },
        /**
         * Remove an existing test
         */
        removeTest: function (discipline, test, test_indices) {
            var _this = this;
            this.active_remove_indices = test_indices;
            this.error_message = "";
            if (this.delete_handler) {
                this.delete_handler(discipline, test).then(function () {
                    _this.active_remove_indices = null;
                }).catch(function (error_message) {
                    _this.error_message = error_message;
                });
                return;
            }
            this.$store.dispatch('skate_test_history/removeTest', { discipline: discipline, test: test }).then(function () {
                _this.active_remove_indices = null;
            }).catch(function (error_message) {
                _this.error_message = error_message;
            });
        },
        /**
         * Whether the actions to add a new test should be disabled.
         * When no tests are available
         */
        disableDisciplineActions: function (discipline) {
            return discipline.available_tests.length < 1;
        }
    },
    computed: {
        /**
         * The discipline data for the discipline loop
         */
        disciplines: function () {
            if (!this.user_skate_test_history) {
                return [];
            }
            return this.user_skate_test_history.disciplines;
        },
        /**
         * The active user's skate test history
         */
        user_skate_test_history: function () {
            return this.$store.getters['skate_test_history/user_skate_test_history'];
        },
        /**
         * The list of disciplines containing self reported tests
         */
        self_reported_test_disciplines: function () {
            return this.$store.getters['skate_test_history/user_self_reported_test_disciplines'];
        }
    }
}));


/***/ }),

/***/ "./node_modules/ts-loader/index.js?!./node_modules/vue-loader/lib/index.js?!./src/js/pages/CompetitionRegistration/CompetitionRegistrationCoachInformation.vue?vue&type=script&lang=ts&":
/*!******************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/ts-loader??ref--5!./node_modules/vue-loader/lib??vue-loader-options!./src/js/pages/CompetitionRegistration/CompetitionRegistrationCoachInformation.vue?vue&type=script&lang=ts& ***!
  \******************************************************************************************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _store_Modules_MemberSearchState__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../store/Modules/MemberSearchState */ "./src/js/store/Modules/MemberSearchState.ts");
/* harmony import */ var _mixins_HasDataDependencies__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../mixins/HasDataDependencies */ "./src/js/mixins/HasDataDependencies.ts");
/* harmony import */ var _mixins_HasCompetitionRegistrationCompetitionMixin__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../mixins/HasCompetitionRegistrationCompetitionMixin */ "./src/js/mixins/HasCompetitionRegistrationCompetitionMixin.ts");
/* harmony import */ var vue_typed_mixins__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! vue-typed-mixins */ "./node_modules/vue-typed-mixins/lib/index.js");
/* harmony import */ var _services_CompetitionRegistrationService__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../services/CompetitionRegistrationService */ "./src/js/services/CompetitionRegistrationService.ts");
/* harmony import */ var _components_MemberSearch_MemberSearchValidators__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../components/MemberSearch/MemberSearchValidators */ "./src/js/components/MemberSearch/MemberSearchValidators.ts");






/* harmony default export */ __webpack_exports__["default"] = (Object(vue_typed_mixins__WEBPACK_IMPORTED_MODULE_3__["default"])(_mixins_HasCompetitionRegistrationCompetitionMixin__WEBPACK_IMPORTED_MODULE_2__["default"], _mixins_HasDataDependencies__WEBPACK_IMPORTED_MODULE_1__["default"]).extend({
    data: function () {
        return {
            /**
             * Whether search component is active
             */
            search_active: false,
            /**
             * The category for which a partner is being modified
             */
            active_category_id: null,
            /**
             * Whether to disable buttons within the assignment screen
             */
            disable_buttons: false,
            /**
             * Data for the screen itself
             */
            screenData: {
                /**
                 * Whether the user has confirmed their coach selections
                 */
                confirmed: false
            },
            /**
             * The current coach in the process of finding a replacement
             */
            edit_member: null,
            /**
             * Whether the additional information popup is active
             */
            additional_information_popup_active: false,
            /**
             * Whether data needed for component to function has been loaded
             */
            dependencies: {
                competition: false,
                screen_data: false
            },
        };
    },
    methods: {
        /**
         * Load data needed for component to function
         */
        loadData: function () {
            var _this = this;
            return new Promise(function (resolve, reject) {
                var promises = [
                    _this.$store.dispatch('competition_registration/fetchCoachIdentificationScreenData').then(function () {
                        _this.dependencies.screen_data = true;
                        _this.dependencies.competition = true;
                    }).catch(function () {
                        reject();
                    })
                ];
                Promise.all(promises).then(function () {
                    resolve();
                });
            });
        },
        /**
         * Set the ids within member search process to display as already selected
         *
         * Get all the coaches already assigned to the category being modified,
         * including the coach being replaced if replacing a coach
         */
        setCoachSearchBlockedCoachIDs: function (category_id) {
            var block_ids = [];
            for (var i = 0; i < this.coach_identification.length; i++) {
                var coachIdentificationElement = this.coach_identification[i];
                if (coachIdentificationElement.id === category_id) {
                    block_ids = coachIdentificationElement.coaches.map(function (coach_item) {
                        return coach_item.id;
                    });
                    break;
                }
            }
            this.$store.commit('member_search/setBlockedPreviousSelection', block_ids);
        },
        /**
         * Open the coach search component
         */
        openSearch: function () {
            this.search_active = true;
        },
        /**
         * Whether the search component is active.  Used for site overlay logic
         */
        searchActive: function () {
            return this.search_active;
        },
        /**
         * Close the search component.  Used by site overlay
         */
        closeSearch: function () {
            this.search_active = false;
        },
        /**
         * Start the process for adding a coach to a category
         */
        addCoach: function (category_id) {
            this.edit_member = null;
            this.setCoachSearchBlockedCoachIDs(category_id);
            this.active_category_id = category_id;
            this.openSearch();
        },
        /**
         * Start the process for editing a coach within a category
         */
        editCoach: function (_a) {
            var category_id = _a.category_id, member = _a.member;
            this.active_category_id = category_id;
            this.edit_member = member;
            this.setCoachSearchBlockedCoachIDs(category_id);
            this.openSearch();
        },
        /**
         * Initiate coach removal process and respond to result
         */
        doRemoveCoach: function (category_id, member) {
            var _this = this;
            this.disable_buttons = true;
            return new Promise(function (resolve, reject) {
                var coach_id = member.id;
                _this.$store.dispatch('competition_registration/removeCategoryCoach', {
                    coach_id: coach_id,
                    category_id: category_id
                }).then(function () {
                    _this.disable_buttons = false;
                    resolve();
                }).catch(function (error_message) {
                    _this.disable_buttons = false;
                    reject(error_message);
                });
            });
        },
        /**
         * Initiate coach replacement process and respond to result
         */
        doReplaceCoach: function (replacement_id, replacee_id) {
            var _this = this;
            return new Promise(function (resolve, reject) {
                var category_id = _this.active_category_id;
                _this.$store.dispatch('competition_registration/replaceCategoryCoach', {
                    category_id: category_id,
                    coach_id: replacement_id,
                    replace_coach_id: replacee_id
                }).then(function () {
                    resolve();
                }).catch(function (error_message) {
                    reject(error_message);
                });
            });
        },
        /**
         * Initiate coach addition process and respond to result
         */
        doAddCoach: function (coach_id) {
            var _this = this;
            return new Promise(function (resolve, reject) {
                var category_id = _this.active_category_id;
                _this.$store.dispatch('competition_registration/addCategoryCoach', {
                    coach_id: coach_id,
                    category_id: category_id
                }).then(function () {
                    resolve();
                }).catch(function (error_message) {
                    reject(error_message);
                });
            });
        },
        /**
         * Handle the select event on a member from search results
         * Fire proper process based on whether coach is being added as new coach or as a replacement coach
         */
        selectCoach: function (member) {
            var replace_coach_id = this.edit_member ? this.edit_member.id : false;
            if (replace_coach_id) {
                return this.doReplaceCoach(member.id, replace_coach_id);
            }
            return this.doAddCoach(member.id);
        },
        /**
         * Retreat in the competition registration process
         */
        retreat: function () {
            location.assign(this.competition.registration_links.event_selection);
        },
        /**
         * Advance in the competition registration process
         */
        advance: function () {
            if (this.block_continue) {
                return;
            }
            location.assign(this.competition.registration_links.waivers);
        },
    },
    /**
     * Register member search state module and configure it when component is created
     */
    created: function () {
        this.$store.registerModule('member_search', _store_Modules_MemberSearchState__WEBPACK_IMPORTED_MODULE_0__["MemberSearchState"]);
        this.$store.commit('member_search/configure', {
            search_function: _services_CompetitionRegistrationService__WEBPACK_IMPORTED_MODULE_4__["CompetitionRegistrationService"].coachSearch,
            selection_method: this.selectCoach,
            close_method: this.closeSearch,
            ineligible_instruction: "Please choose another coach or leave blank.",
            entity_descriptor: "Coach",
            result_validators: [
                _components_MemberSearch_MemberSearchValidators__WEBPACK_IMPORTED_MODULE_5__["validateResultActive"]
            ]
        });
    },
    computed: {
        /**
         * Header for the search component
         */
        search_header: function () {
            var value = "Coach Search";
            if (this.$store.state.member_search.results_active) {
                value += " Results";
            }
            return value;
        },
        /**
         * The currently configured assignment category list and existing coaches
         */
        coach_identification: function () {
            return this.$store.getters['competition_registration/coach_identification'];
        },
        /**
         * Whether the user has identified at least one coach attending with them
         */
        coach_has_been_identified: function () {
            for (var i = 0; i < this.coach_identification.length; i++) {
                var coachIdentificationElement = this.coach_identification[i];
                if (coachIdentificationElement.coaches.length) {
                    return true;
                }
            }
            return false;
        },
        /**
         * Whether any of the coaches that's been identified is ineligible
         */
        ineligible_coach_selected: function () {
            for (var i = 0; i < this.coach_identification.length; i++) {
                var coachIdentificationElement = this.coach_identification[i];
                for (var j = 0; j < coachIdentificationElement.coaches.length; j++) {
                    var coach = coachIdentificationElement.coaches[j];
                    if (coach.ineligible) {
                        return true;
                    }
                }
            }
            return false;
        },
        /**
         * The active step in the competition registration process.  Depends on whether the competition supports partner events
         */
        active_step_number: function () {
            if (this.active_competition && !this.competition.has_partner_events) {
                return 4;
            }
            return 6;
        },
        /**
         * Whether user should be prevented from continuing in the competition registration process
         * If an ineligible coach has been selected, or if the user hasn't approved the page terms
         */
        block_continue: function () {
            return this.ineligible_coach_selected || !this.screenData.confirmed;
        },
    },
    watch: {
        /**
         * When the set of assigned coaches change, re-require terms agreement
         */
        coach_identification: {
            handler: function () {
                this.screenData.confirmed = false;
            },
            deep: true
        }
    }
}));


/***/ }),

/***/ "./node_modules/ts-loader/index.js?!./node_modules/vue-loader/lib/index.js?!./src/js/pages/CompetitionRegistration/CompetitionRegistrationEventSelection.vue?vue&type=script&lang=ts&":
/*!****************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/ts-loader??ref--5!./node_modules/vue-loader/lib??vue-loader-options!./src/js/pages/CompetitionRegistration/CompetitionRegistrationEventSelection.vue?vue&type=script&lang=ts& ***!
  \****************************************************************************************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _mixins_HasCompetitionRegistrationCompetitionMixin__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../mixins/HasCompetitionRegistrationCompetitionMixin */ "./src/js/mixins/HasCompetitionRegistrationCompetitionMixin.ts");
/* harmony import */ var _mixins_HasDataDependencies__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../mixins/HasDataDependencies */ "./src/js/mixins/HasDataDependencies.ts");
/* harmony import */ var vue_typed_mixins__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vue-typed-mixins */ "./node_modules/vue-typed-mixins/lib/index.js");
/* harmony import */ var _store_Modules_SkateTestHistoryState__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../store/Modules/SkateTestHistoryState */ "./src/js/store/Modules/SkateTestHistoryState.ts");
/* harmony import */ var _components_CompetitionRegistration_EventSelection_vue__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../components/CompetitionRegistration/EventSelection.vue */ "./src/js/components/CompetitionRegistration/EventSelection.vue");





/* harmony default export */ __webpack_exports__["default"] = (Object(vue_typed_mixins__WEBPACK_IMPORTED_MODULE_2__["default"])(_mixins_HasCompetitionRegistrationCompetitionMixin__WEBPACK_IMPORTED_MODULE_0__["default"], _mixins_HasDataDependencies__WEBPACK_IMPORTED_MODULE_1__["default"]).extend({
    data: function () {
        return {
            /**
             * The active partner for which skate tests are being modified
             */
            active_partner: null,
            /**
             * Error resulting from a skate test submission
             */
            skate_test_submit_error: null,
            /**
             * Whether a skate test is in the process of submitting
             */
            submitting_skate_test: false,
            /**
             * Whether an error occurred when loading partner skate test history
             */
            partner_test_load_error: null,
            /**
             * The list index of the partner for which skate test information is being loaded
             * Used for location of error if load results in an error
             */
            loading_skate_test_index: null,
            /**
             * Whether data needed for component to function has been loaded
             */
            dependencies: {
                screen: false,
                competition: false
            },
            /**
             * The PartnerSkateTestSummary item for which requirements overlay is currently active
             */
            active_requirements: null
        };
    },
    /**
     * On component creation, register the skate test history module for partner skate test management
     */
    created: function () {
        this.$store.registerModule('skate_test_history', _store_Modules_SkateTestHistoryState__WEBPACK_IMPORTED_MODULE_3__["SkateTestHistoryState"]);
    },
    methods: {
        /**
         * Load data needed for component to function
         */
        loadData: function () {
            var _this = this;
            return new Promise(function (resolve, reject) {
                var promises = [
                    _this.$store.dispatch('competition_registration/fetchEventSelectionScreenData').then(function () {
                        _this.dependencies.screen = true;
                        _this.dependencies.competition = true;
                    }).catch(function () {
                        reject();
                    })
                ];
                Promise.all(promises).then(function () {
                    resolve();
                });
            });
        },
        /**
         * Whether the event requirements overlay is active
         */
        eventRequirementsActive: function () {
            return this.active_requirements !== null;
        },
        /**
         * Start the process for opening a partner skate test history
         */
        openPartnerSkateTest: function (summary_item, index) {
            var _this = this;
            this.loading_skate_test_index = index;
            this.$store.dispatch('skate_test_history/fetchSkateTestHistory', summary_item.partner.id).then(function () {
                _this.active_partner = summary_item.partner;
                _this.loading_skate_test_index = null;
            }).catch(function () {
                _this.partner_test_load_error = "Error loading skate test history.";
            });
        },
        /**
         * Overlay logic function to determine whether to show the partner skate test takeover
         */
        partnerSkateTestActive: function () {
            return !!this.active_partner;
        },
        /**
         * Handle the close event on the partner skate test overlay.
         * If a discipline form is active, close it.
         * Otherwise completely close the takeover and show the general section of the main component that launched it
         */
        handlePartnerSkateTestOverlayClose: function () {
            if (this.active_test_discipline) {
                this.closeSkateTestDisciplineForm();
                return;
            }
            this.active_partner = null;
            this.scrollToPartnerTests();
        },
        /**
         * Handle close/cancel event on the event requirements overlay
         */
        handleEventRequirementsOverlayClose: function () {
            this.active_requirements = null;
            this.scrollToPartnerTests();
        },
        /**
         * Scroll to the "Partner Skate Test History" section
         */
        scrollToPartnerTests: function () {
            var _this = this;
            this.$nextTick(function () {
                var tests_section = _this.$refs['partner_tests'];
                if (tests_section) {
                    tests_section.scrollIntoView();
                }
            });
        },
        /**
         * Handle close/cancel event on the add skate test form
         */
        closeSkateTestDisciplineForm: function () {
            this.$store.commit('skate_test_history/setActiveDiscipline', null);
        },
        /**
         * Handle the complete event on a skate test form.  Begin submission data flow and respond to submission result
         */
        completeSkateTest: function (test_data) {
            var _this = this;
            this.skate_test_submit_error = null;
            var active_discipline_key = this.active_test_discipline ? this.active_test_discipline.key : null;
            if (!this.active_partner || !active_discipline_key) {
                /**
                 * @note: one should never be able to see the complete test UI without an active partner, but this logic
                 * accommodates the potential for active_partner to be null
                 */
                this.skate_test_submit_error = "Invalid entity.";
                return;
            }
            this.submitting_skate_test = true;
            this.$store.dispatch('competition_registration/addPartnerSkateTest', {
                discipline_key: active_discipline_key,
                test_data: test_data,
                partner_id: this.active_partner.id
            }).then(function () {
                _this.$store.commit('skate_test_history/setActiveDiscipline', null);
                _this.submitting_skate_test = false;
            }).catch(function (error_message) {
                _this.submitting_skate_test = false;
                _this.skate_test_submit_error = error_message;
            });
        },
        /**
         * Handle the remove event on a self-reported skate test.  Begin submission data flow and respond to submission result
         */
        removeSkateTest: function (discipline, test) {
            var _this = this;
            return new Promise(function (resolve, reject) {
                if (!_this.active_partner) {
                    /**
                     * @note: one should never be able to see the remove test UI without an active partner, but this logic
                     * accommodates the potential for active_partner to be null
                     */
                    reject("Invalid entity.");
                    return;
                }
                _this.$store.dispatch('competition_registration/removePartnerSkateTest', {
                    discipline: discipline,
                    test: test,
                    partner_id: _this.active_partner.id
                }).then(function () {
                    resolve();
                }).catch(function (error_message) {
                    reject(error_message);
                });
            });
        },
        /**
         * Whether there's error for a particular partner item in loading skate test history
         */
        partnerSkateTestLoadError: function (index) {
            return this.partner_test_load_error && index === this.loading_skate_test_index;
        },
        /**
         * Advance in the competition registration process
         */
        advance: function () {
            if (this.block_continue) {
                return;
            }
            location.assign(this.competition.registration_links.coach_information);
        },
        /**
         * Retreat in the competition registration process
         * If the competition being registered for has partner events, go back to partner identification
         * Otherwise go back to skate tests
         */
        retreat: function () {
            var retreat_path = this.competition.registration_links.partner_identification;
            if (!this.$store.state.competition_registration.selected_partner_events.length) {
                retreat_path = this.competition.registration_links.partner_events;
            }
            if (!this.competition.has_partner_events) {
                retreat_path = this.competition.registration_links.skate_test;
            }
            location.assign(retreat_path);
        }
    },
    computed: {
        /**
         * The events that are available to display in the component, registered, selected or available
         */
        state_available_events: function () {
            return this.$store.getters['competition_registration/event_selection_events'];
        },
        /**
         * The events that have been selected by the user
         */
        selected_events: function () {
            return this.state_available_events.filter(function (event) {
                return event.is_selected;
            });
        },
        /**
         * List of partner skate test summary items
         */
        partner_skate_test_summary: function () {
            return this.$store.getters['competition_registration/partner_skate_test_summary'];
        },
        /**
         * Whether to show the partner skate test section of the component
         */
        show_partner_tests: function () {
            return this.partner_skate_test_summary.length > 0;
        },
        /**
         * The active skate test history discipline if there is one.
         * Used by add skate test process
         */
        active_test_discipline: function () {
            return this.$store.getters['skate_test_history/active_discipline'];
        },
        /**
         * Partner name for skate test history takeover heading text
         */
        skate_test_takeover_partner_name: function () {
            return this.active_partner ? this.active_partner.name : "";
        },
        /**
         * The "test" input form options for the active skate test history discipline form
         */
        active_skate_test_options: function () {
            return this.$store.getters['skate_test_history/active_discipline_test_options'];
        },
        /**
         * The active step in the competition registration process.  Depends on whether the competition supports partner events
         */
        active_step_number: function () {
            if (this.active_competition && !this.competition.has_partner_events) {
                return 3;
            }
            return 5;
        },
        /**
         * Whether user should be prevented from continuing
         * 1. If the user has selected no events
         * 2. If any of the assigned partners doesn't meet skate test requirements
         */
        block_continue: function () {
            if (this.selected_events.length === 0) {
                return true;
            }
            for (var i = 0; i < this.partner_skate_test_summary.length; i++) {
                var partnerSkateTestSummaryElement = this.partner_skate_test_summary[i];
                if (!partnerSkateTestSummaryElement.partner.meets_requirements) {
                    return true;
                }
            }
            return false;
        },
    },
    components: {
        EventSelection: _components_CompetitionRegistration_EventSelection_vue__WEBPACK_IMPORTED_MODULE_4__["default"]
    }
}));


/***/ }),

/***/ "./node_modules/ts-loader/index.js?!./node_modules/vue-loader/lib/index.js?!./src/js/pages/CompetitionRegistration/CompetitionRegistrationIndex.vue?vue&type=script&lang=ts&":
/*!*******************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/ts-loader??ref--5!./node_modules/vue-loader/lib??vue-loader-options!./src/js/pages/CompetitionRegistration/CompetitionRegistrationIndex.vue?vue&type=script&lang=ts& ***!
  \*******************************************************************************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _services_PaginationService__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../services/PaginationService */ "./src/js/services/PaginationService.ts");
/* harmony import */ var _helpers_CompetitionSearchHelpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../helpers/CompetitionSearchHelpers */ "./src/js/helpers/CompetitionSearchHelpers.ts");
/* harmony import */ var _components_CompetitionRegistration_CompetitionSearch_vue__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../components/CompetitionRegistration/CompetitionSearch.vue */ "./src/js/components/CompetitionRegistration/CompetitionSearch.vue");
/* harmony import */ var _mixins_HasDataDependencies__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../mixins/HasDataDependencies */ "./src/js/mixins/HasDataDependencies.ts");
/* harmony import */ var vue_typed_mixins__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! vue-typed-mixins */ "./node_modules/vue-typed-mixins/lib/index.js");





/* harmony default export */ __webpack_exports__["default"] = (Object(vue_typed_mixins__WEBPACK_IMPORTED_MODULE_4__["default"])(_mixins_HasDataDependencies__WEBPACK_IMPORTED_MODULE_3__["default"]).extend({
    data: function () {
        return {
            /**
             * The active type of events being shown (qual/nonqual)
             */
            active_type: "non_qualifying",
            /**
             * The active page of paginated results
             */
            active_page_index: 0,
            /**
             * The active search (filter) criteria for the competition list
             */
            search_criteria: {
                search_term: null,
                search_field: null
            },
            /**
             * data needed for component to function
             */
            dependencies: {
                competitions: false
            }
        };
    },
    methods: {
        /**
         * Load data needed for component to function
         */
        loadData: function () {
            var _this = this;
            return new Promise(function (resolve, reject) {
                _this.$store.dispatch('competition_registration/fetchCompetitions').then(function () {
                    _this.dependencies.competitions = true;
                    resolve();
                }).catch(function () {
                    reject();
                });
            });
        },
        /**
         * Select whether qualifying or nonqualifying are active
         */
        selectActiveType: function (qualifying_key) {
            this.changeActivePage(0);
            if (this.search_component) {
                this.search_component.reset();
            }
            this.active_type = qualifying_key;
        },
        /**
         * Whether a competition is registered for by the user
         */
        isRegistered: function (competition) {
            return competition.user_registration_status === 'registered';
        },
        /**
         * Whether a competition has an in-progress registration for the current user
         *
         * @deprecated - If CompetitionRegistrationRegistrationCta is being used, this is no longer needed within this component
         */
        isInProgress: function (competition) {
            return competition.user_registration_status === 'in_progress';
        },
        /**
         * Whether a competition is in the late registration window
         *
         * @deprecated - If CompetitionRegistrationRegistrationCta is being used, this is no longer needed within this component
         */
        isLateRegistration: function (competition) {
            return competition.competition_registration_status === 'late';
        },
        /**
         * Whether the competition's registration deadline should show in alert text
         *
         * @deprecated - If CompetitionRegistrationRegistrationCta is being used, this is no longer needed within this component
         */
        hasDeadlineWarning: function (competition) {
            return competition.has_registration_deadline_warning;
        },
        /**
         * Whether a competition is a future competition ('Coming Soon')
         *
         * @deprecated - If CompetitionRegistrationRegistrationCta is being used, this is no longer needed within this component
         */
        isFuture: function (competition) {
            return competition.competition_registration_status === "future";
        },
        /**
         * Whether  competition has a banner for its tile
         */
        hasBanner: function (competition) {
            return this.isRegistered(competition);
        },
        /**
         * The class to apply to a competition CTA button
         *
         * @deprecated - If CompetitionRegistrationRegistrationCta is being used, this is no longer needed within this component
         */
        buttonClass: function (competition) {
            if (this.isLateRegistration(competition)) {
                return "button--action";
            }
            if (this.isInProgress(competition)) {
                return "button--info";
            }
            if (this.isRegistered(competition)) {
                return "button--info";
            }
            return "";
        },
        /**
         * The text to display for a competition CTA button
         *
         * @deprecated - If CompetitionRegistrationRegistrationCta is being used, this is no longer needed within this component
         */
        buttonText: function (competition) {
            if (this.isLateRegistration(competition)) {
                return "Late";
            }
            if (this.isInProgress(competition)) {
                return "Continue Registration";
            }
            if (this.isRegistered(competition)) {
                return "Add Event";
            }
            if (this.isFuture(competition)) {
                return "Coming Soon";
            }
            return "Register Now";
        },
        /**
         * Begin registration process for a competition
         *
         * @deprecated - If CompetitionRegistrationRegistrationCta is being used, this is no longer needed within this component
         */
        beginRegistration: function (competition) {
            location.assign(competition.user_registration_link);
        },
        /**
         * Handle active page change reported by pagination component
         */
        handleActivePageChange: function (page_index) {
            this.active_page_index = page_index;
        },
        /**
         * Set the active page within the component and its dependents
         */
        changeActivePage: function (page_index) {
            this.active_page_index = page_index;
            if (this.pagination_component) {
                this.pagination_component.setActivePage(page_index);
            }
        }
    },
    computed: {
        /**
         * The search component element
         */
        search_component: function () {
            return this.$refs['search'] ? this.$refs['search'] : null;
        },
        /**
         * The pagination component element
         */
        pagination_component: function () {
            return this.$refs['pagination'] ? this.$refs['pagination'] : null;
        },
        /**
         * All available competitions
         */
        available_competitions: function () {
            return this.$store.getters['competition_registration/competition_list'];
        },
        /**
         * All competitions that have passed any active filters
         */
        filtered_competitions: function () {
            var _this = this;
            var qualifying_check = this.active_type === "qualifying";
            return this.available_competitions.filter(function (competition) {
                if (competition.is_qualifying !== qualifying_check) {
                    return false;
                }
                return _helpers_CompetitionSearchHelpers__WEBPACK_IMPORTED_MODULE_1__["CompetitionSearchHelpers"].competitionPassesFilter(competition, _this.search_criteria);
            });
        },
        /**
         * List of state filters for search form.
         * Each unique state value in alpha order for the active competition set (qual/nonqual)
         */
        available_state_filters: function () {
            var _this = this;
            var added_states = [];
            return this.available_competitions.reduce(function (carry, competition) {
                var qualifying_check = _this.active_type === "qualifying";
                if (competition.is_qualifying === qualifying_check) {
                    var competition_state = competition.state;
                    if (added_states.indexOf(competition_state) === -1) {
                        added_states.push(competition_state);
                        carry.push({
                            label: competition_state,
                            value: competition_state
                        });
                    }
                }
                return carry;
            }, []).sort(function (item, item2) {
                return item.value.localeCompare(item2.value);
            });
        },
        /**
         * Paginated competitions that have passed all active filters
         */
        paginated_competitions: function () {
            return _services_PaginationService__WEBPACK_IMPORTED_MODULE_0__["PaginationService"].paginate(this.filtered_competitions, 5);
        },
        /**
         * The set of competitions currently visible on the active pagination page
         */
        visible_competitions: function () {
            return this.paginated_competitions[this.active_page_index];
        },
        /**
         * Whether no competitions are available for the currently active type
         */
        no_active_configured_competitions: function () {
            return this.visible_competitions.length === 0 && !this.search_criteria.search_field;
        },
        /**
         * Whether to show the search form
         */
        show_search: function () {
            return !(this.no_active_configured_competitions);
        },
        /**
         * Whether to show the pagination
         */
        show_pagination: function () {
            return this.visible_competitions.length > 0;
        },
    },
    components: {
        CompetitionSearch: _components_CompetitionRegistration_CompetitionSearch_vue__WEBPACK_IMPORTED_MODULE_2__["default"]
    },
    watch: {
        /**
         * When search term changes, go to first page of paginated results
         */
        "search_criteria.search_term": function () {
            this.changeActivePage(0);
        }
    }
}));


/***/ }),

/***/ "./node_modules/ts-loader/index.js?!./node_modules/vue-loader/lib/index.js?!./src/js/pages/CompetitionRegistration/CompetitionRegistrationOverview.vue?vue&type=script&lang=ts&":
/*!**********************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/ts-loader??ref--5!./node_modules/vue-loader/lib??vue-loader-options!./src/js/pages/CompetitionRegistration/CompetitionRegistrationOverview.vue?vue&type=script&lang=ts& ***!
  \**********************************************************************************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _mixins_HasDataDependencies__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../mixins/HasDataDependencies */ "./src/js/mixins/HasDataDependencies.ts");
/* harmony import */ var _mixins_HasCompetitionRegistrationCompetitionMixin__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../mixins/HasCompetitionRegistrationCompetitionMixin */ "./src/js/mixins/HasCompetitionRegistrationCompetitionMixin.ts");
/* harmony import */ var vue_typed_mixins__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vue-typed-mixins */ "./node_modules/vue-typed-mixins/lib/index.js");



/* harmony default export */ __webpack_exports__["default"] = (Object(vue_typed_mixins__WEBPACK_IMPORTED_MODULE_2__["default"])(_mixins_HasDataDependencies__WEBPACK_IMPORTED_MODULE_0__["default"], _mixins_HasCompetitionRegistrationCompetitionMixin__WEBPACK_IMPORTED_MODULE_1__["default"]).extend({
    props: {
        /**
         * Url to return to when user clicks "back" button
         */
        back_url: {
            type: String,
            required: true
        }
    },
    data: function () {
        return {
            /**
             * data needed for component to function
             */
            dependencies: {
                competition: false,
                prices: false
            },
            screenData: {
                /**
                 * Whether the user has clicked the confirm checkbox
                 */
                confirmed: false
            }
        };
    },
    methods: {
        /**
         * Load data needed for component to function
         */
        loadData: function () {
            var _this = this;
            return new Promise(function (resolve, reject) {
                var promises = [
                    _this.$store.dispatch('competition_registration/fetchCompetitionOverviewScreenData').then(function () {
                        _this.dependencies.prices = true;
                        _this.dependencies.competition = true;
                    }).catch(function () {
                        reject();
                    })
                ];
                Promise.all(promises).then(function () {
                    resolve();
                });
            });
        },
        /**
         * Display formatting for a price
         */
        priceDisplay: function (price) {
            if (price == null) {
                return "";
            }
            return "$" + price;
        },
        /**
         * Whether to show a notice about lack of prices for a particular category
         */
        showPriceNotice: function (price_set) {
            for (var i in price_set) {
                if (i === 'category') {
                    continue;
                }
                if (price_set[i] !== null) {
                    return false;
                }
            }
            return true;
        },
        advance: function () {
            if (this.block_continue) {
                return;
            }
            location.assign(this.competition.registration_links.profile);
        },
        retreat: function () {
            location.assign(this.back_url);
        }
    },
    computed: {
        /**
         * Information to show in the information tray
         */
        registration_information: function () {
            return this.active_competition.information.overview;
        },
        /**
         * The prices for display
         */
        prices: function () {
            return this.$store.getters['competition_registration/active_prices'];
        },
        /**
         * Whether advancing should be blocked
         */
        block_continue: function () {
            return !this.screenData.confirmed;
        }
    }
}));


/***/ }),

/***/ "./node_modules/ts-loader/index.js?!./node_modules/vue-loader/lib/index.js?!./src/js/pages/CompetitionRegistration/CompetitionRegistrationPartnerEvents.vue?vue&type=script&lang=ts&":
/*!***************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/ts-loader??ref--5!./node_modules/vue-loader/lib??vue-loader-options!./src/js/pages/CompetitionRegistration/CompetitionRegistrationPartnerEvents.vue?vue&type=script&lang=ts& ***!
  \***************************************************************************************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _mixins_HasCompetitionRegistrationCompetitionMixin__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../mixins/HasCompetitionRegistrationCompetitionMixin */ "./src/js/mixins/HasCompetitionRegistrationCompetitionMixin.ts");
/* harmony import */ var _mixins_HasDataDependencies__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../mixins/HasDataDependencies */ "./src/js/mixins/HasDataDependencies.ts");
/* harmony import */ var vue_typed_mixins__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vue-typed-mixins */ "./node_modules/vue-typed-mixins/lib/index.js");



/* harmony default export */ __webpack_exports__["default"] = (Object(vue_typed_mixins__WEBPACK_IMPORTED_MODULE_2__["default"])(_mixins_HasCompetitionRegistrationCompetitionMixin__WEBPACK_IMPORTED_MODULE_0__["default"], _mixins_HasDataDependencies__WEBPACK_IMPORTED_MODULE_1__["default"]).extend({
    data: function () {
        return {
            /**
             * data needed for component to function
             */
            dependencies: {
                competition: false
            },
            /**
             * In-component tracking for selected events
             */
            selected_events: [],
            /**
             * Whether the selection is currently being saved
             */
            saving: false,
            /**
             * Error resulting from the save submission
             */
            save_error: null
        };
    },
    methods: {
        /**
         * Load data needed for component to function
         */
        loadData: function () {
            var _this = this;
            return new Promise(function (resolve, reject) {
                _this.$store.dispatch('competition_registration/fetchPartnerEventsScreenData').then(function () {
                    _this.dependencies.competition = true;
                    _this.selected_events = _this.$store.state.competition_registration.selected_partner_events;
                    resolve();
                }).catch(function () {
                    reject();
                });
            });
        },
        retreat: function () {
            location.assign(this.competition.registration_links.skate_test);
        },
        /**
         * Save the selections and advance if successful.
         *    - Advance location dependent on whether partner events are selected or not
         * Display error if submission error.
         *
         */
        advance: function () {
            var _this = this;
            if (this.disable_continue) {
                return;
            }
            this.saving = true;
            this.save_error = null;
            this.$store.dispatch('competition_registration/selectPartnerEvents', this.selected_events)
                .then(function () {
                if (_this.selected_events.length) {
                    location.assign(_this.competition.registration_links.partner_identification);
                    return;
                }
                location.assign(_this.competition.registration_links.event_selection);
            })
                .catch(function (error_message) {
                _this.saving = false;
                _this.save_error = error_message;
            });
        }
    },
    computed: {
        active_competition: function () {
            return this.$store.getters['competition_registration/active_competition'];
        },
        /**
         * The options for the user to select from
         */
        partner_event_options: function () {
            if (!this.active_competition) {
                return [];
            }
            return this.active_competition.available_partner_events;
        },
        /**
         * Whether continue button should be disabled (functionally speaking.  visual state does not change)
         */
        disable_continue: function () {
            return this.saving;
        }
    }
}));


/***/ }),

/***/ "./node_modules/ts-loader/index.js?!./node_modules/vue-loader/lib/index.js?!./src/js/pages/CompetitionRegistration/CompetitionRegistrationPartnerIdentification.vue?vue&type=script&lang=ts&":
/*!***********************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/ts-loader??ref--5!./node_modules/vue-loader/lib??vue-loader-options!./src/js/pages/CompetitionRegistration/CompetitionRegistrationPartnerIdentification.vue?vue&type=script&lang=ts& ***!
  \***********************************************************************************************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _store_Modules_MemberSearchState__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../store/Modules/MemberSearchState */ "./src/js/store/Modules/MemberSearchState.ts");
/* harmony import */ var _services_CompetitionRegistrationService__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../services/CompetitionRegistrationService */ "./src/js/services/CompetitionRegistrationService.ts");
/* harmony import */ var _mixins_HasDataDependencies__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../mixins/HasDataDependencies */ "./src/js/mixins/HasDataDependencies.ts");
/* harmony import */ var _mixins_HasCompetitionRegistrationCompetitionMixin__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../mixins/HasCompetitionRegistrationCompetitionMixin */ "./src/js/mixins/HasCompetitionRegistrationCompetitionMixin.ts");
/* harmony import */ var vue_typed_mixins__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! vue-typed-mixins */ "./node_modules/vue-typed-mixins/lib/index.js");
/* harmony import */ var _components_MemberSearch_MemberSearchValidators__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../components/MemberSearch/MemberSearchValidators */ "./src/js/components/MemberSearch/MemberSearchValidators.ts");






/* harmony default export */ __webpack_exports__["default"] = (Object(vue_typed_mixins__WEBPACK_IMPORTED_MODULE_4__["default"])(_mixins_HasCompetitionRegistrationCompetitionMixin__WEBPACK_IMPORTED_MODULE_3__["default"], _mixins_HasDataDependencies__WEBPACK_IMPORTED_MODULE_2__["default"]).extend({
    data: function () {
        return {
            /**
             * Whether search component is active
             */
            search_active: false,
            /**
             * The category for which a partner is being modified
             */
            active_category_id: null,
            /**
             * Whether to disable buttons within the assignment screen
             */
            disable_buttons: false,
            /**
             * Whether data needed for component to function has been loaded
             */
            dependencies: {
                screen_data: false,
                competition: false
            }
        };
    },
    methods: {
        /**
         * Load data needed for component to function
         */
        loadData: function () {
            var _this = this;
            return new Promise(function (resolve, reject) {
                var promises = [
                    _this.$store.dispatch('competition_registration/fetchPartnerIdentificationScreenData').then(function () {
                        _this.dependencies.competition = true;
                        _this.dependencies.screen_data = true;
                        resolve();
                    }).catch(function () {
                        reject();
                    }),
                ];
                Promise.all(promises).then(function () {
                    resolve();
                });
            });
        },
        /**
         * Begin the process for adding a partner to a category
         */
        addPartner: function (category_id) {
            this.active_category_id = category_id;
            this.$store.commit('member_search/setBlockedPreviousSelection', []);
            this.openSearch();
        },
        /**
         * Begin the process for editing a partner for a category
         */
        editPartner: function (_a) {
            var category_id = _a.category_id, member = _a.member;
            this.active_category_id = category_id;
            this.$store.commit('member_search/setBlockedPreviousSelection', [member.id]);
            this.openSearch();
        },
        /**
         * Remove a partner from a category
         */
        removePartner: function (category_id, member) {
            var _this = this;
            this.disable_buttons = true;
            return new Promise(function (resolve, reject) {
                var member_id = member.id;
                _this.$store.dispatch('competition_registration/removeCategoryPartner', {
                    member_id: member_id,
                    category_id: category_id
                }).then(function () {
                    _this.disable_buttons = false;
                    resolve();
                }).catch(function (error_message) {
                    _this.disable_buttons = false;
                    reject(error_message);
                });
            });
        },
        /**
         * Open the search component
         */
        openSearch: function () {
            this.search_active = true;
        },
        /**
         * Whether the search component is active.  Used for site overlay logic
         */
        searchActive: function () {
            return this.search_active;
        },
        /**
         * Close the search component.  Used by site overlay
         */
        closeSearch: function () {
            this.search_active = false;
        },
        /**
         * Handle the select event on a member from search results
         * Param generic type (MemberSearchResult vs PartnerMemberSearchResult)for Member Search functionality compatibility
         */
        selectMember: function (member) {
            var _this = this;
            return new Promise(function (resolve, reject) {
                var category_id = _this.active_category_id;
                var member_id = member.id;
                _this.$store.dispatch('competition_registration/addCategoryPartner', {
                    member_id: member_id,
                    category_id: category_id
                }).then(function () {
                    resolve();
                }).catch(function (error_message) {
                    reject(error_message);
                });
            });
        },
        /**
         * Validate that a search result has the opposite gender of the active user
         */
        validateSearchResultGender: function (member_result) {
            if (this.active_user_gender && member_result.gender === this.active_user_gender) {
                return "Must be opposite gender";
            }
            return false;
        },
        /**
         * Retreat in the competition registration process
         */
        retreat: function () {
            location.assign(this.competition.registration_links.partner_events);
        },
        /**
         * Advance in the competition registration process
         */
        advance: function () {
            if (this.block_continue) {
                return;
            }
            location.assign(this.competition.registration_links.event_selection);
        },
    },
    /**
     * Register member search state module and configure it when component is created
     */
    created: function () {
        this.$store.registerModule('member_search', _store_Modules_MemberSearchState__WEBPACK_IMPORTED_MODULE_0__["MemberSearchState"]);
        this.$store.commit('member_search/configure', {
            search_function: _services_CompetitionRegistrationService__WEBPACK_IMPORTED_MODULE_1__["CompetitionRegistrationService"].partnerSearch,
            selection_method: this.selectMember,
            close_method: this.closeSearch,
            ineligible_instruction: "Please select another partner.",
            entity_descriptor: "Partner",
            result_validators: [
                this.validateSearchResultGender,
                _components_MemberSearch_MemberSearchValidators__WEBPACK_IMPORTED_MODULE_5__["validateResultActive"]
            ]
        });
    },
    computed: {
        /**
         * Header for the search component
         */
        search_header: function () {
            var value = "Partner Search";
            if (this.$store.state.member_search.results_active) {
                value += " Results";
            }
            return value;
        },
        /**
         * The list of categories to which partners can be assigned, along with their currently assigned partner
         */
        identification_categories: function () {
            return this.$store.getters['competition_registration/partner_identification'];
        },
        /**
         * identification_categories mapped to structure consumable by member assignment component
         */
        event_categories: function () {
            return this.identification_categories.map(function (category) {
                return {
                    id: category.id,
                    name: category.name,
                    member_limit: 1,
                    members: category.partner ? [category.partner] : [],
                };
            });
        },
        /**
         * The active user's gender
         */
        active_user_gender: function () {
            var active_user_profile = this.$store.getters['user/profile'];
            if (active_user_profile) {
                return active_user_profile.gender;
            }
            return null;
        },
        /**
         * Whether user should be prevented from continuing in the competition registration process
         * If a category doesn't have a partner assigned, or if the partner is ineligible
         */
        block_continue: function () {
            for (var i = 0; i < this.identification_categories.length; i++) {
                var identificationCategory = this.identification_categories[i];
                if (!identificationCategory.partner) {
                    return true;
                }
                if (identificationCategory.partner.ineligible) {
                    return true;
                }
            }
            return false;
        }
    }
}));


/***/ }),

/***/ "./node_modules/ts-loader/index.js?!./node_modules/vue-loader/lib/index.js?!./src/js/pages/CompetitionRegistration/CompetitionRegistrationSkateTests.vue?vue&type=script&lang=ts&":
/*!************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/ts-loader??ref--5!./node_modules/vue-loader/lib??vue-loader-options!./src/js/pages/CompetitionRegistration/CompetitionRegistrationSkateTests.vue?vue&type=script&lang=ts& ***!
  \************************************************************************************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _store_Modules_SkateTestHistoryState__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../store/Modules/SkateTestHistoryState */ "./src/js/store/Modules/SkateTestHistoryState.ts");
/* harmony import */ var vue_typed_mixins__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vue-typed-mixins */ "./node_modules/vue-typed-mixins/lib/index.js");
/* harmony import */ var _mixins_HasDataDependencies__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../mixins/HasDataDependencies */ "./src/js/mixins/HasDataDependencies.ts");
/* harmony import */ var _mixins_HasCompetitionRegistrationCompetitionMixin__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../mixins/HasCompetitionRegistrationCompetitionMixin */ "./src/js/mixins/HasCompetitionRegistrationCompetitionMixin.ts");




/* harmony default export */ __webpack_exports__["default"] = (Object(vue_typed_mixins__WEBPACK_IMPORTED_MODULE_1__["default"])(_mixins_HasDataDependencies__WEBPACK_IMPORTED_MODULE_2__["default"], _mixins_HasCompetitionRegistrationCompetitionMixin__WEBPACK_IMPORTED_MODULE_3__["default"]).extend({
    data: function () {
        return {
            /**
             * Error message resulting from a submission
             */
            test_submit_error: null,
            /**
             * Whether a test is in the process of being submitted
             */
            submitting_test: false,
            /**
             * data needed for component to function
             */
            dependencies: {
                skate_test: false,
                competition: false
            }
        };
    },
    created: function () {
        this.$store.registerModule('skate_test_history', _store_Modules_SkateTestHistoryState__WEBPACK_IMPORTED_MODULE_0__["SkateTestHistoryState"]);
    },
    methods: {
        /**
         * Load data needed for component to function
         */
        loadData: function () {
            var _this = this;
            return new Promise(function (resolve, reject) {
                var promises = [
                    _this.$store.dispatch('competition_registration/fetchSkateTestsScreenData').then(function () {
                        _this.dependencies.skate_test = true;
                        _this.dependencies.competition = true;
                    }).catch(function () {
                        reject();
                    })
                ];
                Promise.all(promises).then(function () {
                    resolve();
                });
            });
        },
        /**
         * Whether the skate test form overlay should be active
         */
        skateTestActive: function () {
            return !!this.active_discipline;
        },
        /**
         * Close the skate test form overlay
         */
        closeSkateTest: function () {
            if (this.submitting_test) {
                return;
            }
            this.test_submit_error = null;
            this.$store.commit('skate_test_history/setActiveDiscipline', null);
        },
        /**
         * Respond to completion event on skate test discipline form.
         *  - Submit information
         *  - Close form
         *  Log error on submission failure
         */
        completeSkateTest: function (test_data) {
            var _this = this;
            this.submitting_test = true;
            this.test_submit_error = null;
            this.$store.dispatch('skate_test_history/saveTest', test_data).then(function () {
                _this.$store.commit('skate_test_history/setActiveDiscipline', null);
                _this.submitting_test = false;
            }).catch(function (error_message) {
                _this.submitting_test = false;
                _this.test_submit_error = error_message;
            });
        },
        retreat: function () {
            location.assign(this.competition.registration_links.profile);
        },
        advance: function () {
            if (this.block_continue) {
                return;
            }
            //if competition has partner events
            if (this.competition.has_partner_events) {
                location.assign(this.competition.registration_links.partner_events);
                return;
            }
            location.assign(this.competition.registration_links.event_selection);
        },
    },
    computed: {
        /**
         * The title of the skate test overlay
         */
        takeover_title: function () {
            if (this.active_discipline) {
                return "Add " + this.active_discipline.label;
            }
            return "";
        },
        /**
         * The currently active discipline on state
         */
        active_discipline: function () {
            return this.$store.getters['skate_test_history/active_discipline'];
        },
        /**
         * List of disciplines with self-reported tests
         */
        self_reported_test_disciplines: function () {
            return this.$store.getters['skate_test_history/user_self_reported_test_disciplines'];
        },
        /**
         * Form options for test for the active form instance
         */
        active_test_options: function () {
            return this.$store.getters['skate_test_history/active_discipline_test_options'];
        },
        /**
         * Whether continuing should be blocked
         */
        block_continue: function () {
            return false;
        }
    }
}));


/***/ }),

/***/ "./node_modules/ts-loader/index.js?!./node_modules/vue-loader/lib/index.js?!./src/js/pages/CompetitionRegistration/CompetitionRegistrationSkaterProfile.vue?vue&type=script&lang=ts&":
/*!***************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/ts-loader??ref--5!./node_modules/vue-loader/lib??vue-loader-options!./src/js/pages/CompetitionRegistration/CompetitionRegistrationSkaterProfile.vue?vue&type=script&lang=ts& ***!
  \***************************************************************************************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _mixins_HasCompetitionRegistrationCompetitionMixin__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../mixins/HasCompetitionRegistrationCompetitionMixin */ "./src/js/mixins/HasCompetitionRegistrationCompetitionMixin.ts");
/* harmony import */ var vue_typed_mixins__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vue-typed-mixins */ "./node_modules/vue-typed-mixins/lib/index.js");
/* harmony import */ var _mixins_HasDataDependencies__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../mixins/HasDataDependencies */ "./src/js/mixins/HasDataDependencies.ts");
/* harmony import */ var _components_CompetitionRegistration_SelectRepresentation_vue__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./../../components/CompetitionRegistration/SelectRepresentation.vue */ "./src/js/components/CompetitionRegistration/SelectRepresentation.vue");
/* harmony import */ var _components_EditProfile_vue__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./../../components/EditProfile.vue */ "./src/js/components/EditProfile.vue");
/* harmony import */ var _services_DataDisplayService__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../services/DataDisplayService */ "./src/js/services/DataDisplayService.ts");






/* harmony default export */ __webpack_exports__["default"] = (Object(vue_typed_mixins__WEBPACK_IMPORTED_MODULE_1__["default"])(_mixins_HasDataDependencies__WEBPACK_IMPORTED_MODULE_2__["default"], _mixins_HasCompetitionRegistrationCompetitionMixin__WEBPACK_IMPORTED_MODULE_0__["default"]).extend({
    data: function () {
        return {
            /**
             * Whether profile edit takeover is active
             */
            edit_active: false,
            /**
             * Whether select representation takeover is active
             */
            representation_active: false,
            /**
             * Whether data needed for component to function has been loaded
             */
            dependencies: {
                competition: false,
                profile: false
            },
            /**
             * Data for the screen itself
             */
            screenData: {
                /**
                 * Whether the user has confirmed their information is accurate
                 */
                confirmed: false,
            },
            /**
             * The section of the profile that triggered the beginning of the edit process
             */
            edit_section: null,
            /**
             * Whether default representation selection request is pending
             */
            default_representation_submitting: false,
            /**
             * Error message resulting from default representation selection
             */
            default_representation_error: null
        };
    },
    methods: {
        /**
         * Load data needed for component to function
         */
        loadData: function () {
            var _this = this;
            return new Promise(function (resolve, reject) {
                var promises = [
                    _this.$store.dispatch('competition_registration/fetchProfileScreenData').then(function () {
                        _this.dependencies.profile = true;
                        _this.dependencies.competition = true;
                    }).catch(function () {
                        reject();
                    })
                ];
                Promise.all(promises).then(function () {
                    resolve();
                });
            });
        },
        /**
         * Format gender display
         */
        displayGender: function (gender_key) {
            return _services_DataDisplayService__WEBPACK_IMPORTED_MODULE_5__["DataDisplayService"].capitalize(gender_key);
        },
        /**
         * From a field config, get the display value from user profile
         */
        summaryField: function (field_config) {
            if (!this.active_profile) {
                return null;
            }
            if (field_config.key === "gender") {
                return this.displayGender(this.active_profile.gender);
            }
            return _services_DataDisplayService__WEBPACK_IMPORTED_MODULE_5__["DataDisplayService"].displayFieldFromObject(field_config.key, this.active_profile);
        },
        /**
         * Create a summary list from a source config
         */
        createSummaryList: function (source_config) {
            var _this = this;
            return source_config.reduce(function (carry, item) {
                var display_value = _this.summaryField(item);
                if (display_value) {
                    carry.push({
                        label: item.label,
                        value: display_value
                    });
                }
                return carry;
            }, []);
        },
        /**
         * Overlay logic function to determine whether to show the edit profile takeover
         */
        editActive: function () {
            return this.edit_active;
        },
        /**
         * Close the profile edit takeover
         * Assume data change and unset the confirmation
         */
        closeEdit: function () {
            this.edit_active = false;
            this.screenData.confirmed = false;
        },
        /**
         * Open the profile edit takeover
         */
        openEdit: function (section_key) {
            this.edit_active = true;
            this.edit_section = section_key;
        },
        /**
         *  When a user does not need to select their representation, report default selection
         *  1) If a user has LTS program(s), select the first one.
         *  2) Otherwise, use "home_club"
         */
        selectDefaultRepresentation: function () {
            var _this = this;
            this.default_representation_error = null;
            this.default_representation_submitting = true;
            return new Promise(function (resolve, reject) {
                var lts_program = null;
                var representation_type = "home_club";
                if (_this.lts_programs && _this.lts_programs.programs.length) {
                    lts_program = _this.lts_programs.programs[0].value;
                    representation_type = "lts_program";
                }
                var representation_selection = {
                    representation_type: representation_type,
                    lts_program: lts_program
                };
                _this.$store.dispatch('competition_registration/selectRepresentation', representation_selection).then(function () {
                    _this.default_representation_submitting = false;
                    resolve();
                }).catch(function (save_error) {
                    _this.default_representation_submitting = false;
                    reject(save_error);
                });
            });
        },
        /**
         * Open the representation selection takeover
         */
        openRepresentation: function ($event) {
            var _this = this;
            if (this.editActive()) {
                return;
            }
            if (this.screenData.confirmed) {
                return;
            }
            if (this.default_representation_submitting) {
                return;
            }
            if (!this.representation_selection_required) {
                this.selectDefaultRepresentation().then(function () {
                    _this.screenData.confirmed = true;
                }).catch(function (save_error) {
                    _this.default_representation_error = save_error;
                });
                return;
            }
            $event.preventDefault();
            this.representation_active = true;
        },
        /**
         * Overlay logic function to determine whether to show the representation selection takeover
         */
        representationActive: function () {
            return this.representation_active;
        },
        /**
         * Handle the close without save event from representation takeover
         */
        closeRepresentation: function () {
            var _this = this;
            this.representation_active = false;
            this.$nextTick(function () {
                _this.scrollToActions();
            });
        },
        /**
         * Handle the save event from representation takeover
         */
        saveRepresentation: function () {
            this.screenData.confirmed = true;
            this.closeRepresentation();
        },
        /**
         * Scroll to the page actions block
         */
        scrollToActions: function () {
            this.$refs['actions'].scrollIntoView();
        },
        /**
         * Advance in the competition registration process
         */
        advance: function () {
            if (this.block_continue) {
                return;
            }
            location.assign(this.competition.registration_links.skate_test);
        },
        /**
         * Retreat in the competition registration process
         */
        retreat: function () {
            location.assign(this.competition.registration_links.overview);
        }
    },
    computed: {
        /**
         * Whether a representation selection needs to be completed in general (independent of whether it's been done already)
         */
        representation_selection_required: function () {
            return this.$store.getters['competition_registration/representation_selection_required'];
        },
        /**
         * The profile for the active user
         */
        active_profile: function () {
            return this.$store.getters['user/profile'];
        },
        /**
         * The LTS programs for the active user
         */
        lts_programs: function () {
            return this.$store.getters['user/lts_information'];
        },
        /**
         * Data to populate the profile summary block
         */
        profile_summary: function () {
            return {
                name: this.active_profile ? this.active_profile.full_name : "",
                member_number: this.active_profile ? this.active_profile.member_number : "",
                home_club: this.active_profile ? this.active_profile.home_club : null,
                region_name: this.active_profile ? this.active_profile.region_name : "",
                section_name: this.active_profile ? this.active_profile.section_name : "",
            };
        },
        /**
         * Whether user should be prevented from continuing
         */
        block_continue: function () {
            return !this.screenData.confirmed;
        },
        /**
         * The label:value pairs for the main information data display
         */
        main_summary_data: function () {
            return this.createSummaryList([
                {
                    label: "Prefix",
                    key: "prefix.label"
                },
                {
                    label: "First Name",
                    key: "first_name"
                },
                {
                    label: "Last Name",
                    key: "last_name"
                },
                {
                    label: "Gender",
                    key: "gender"
                },
                {
                    label: "Birth Date",
                    key: "birth_date.formatted"
                },
            ]);
        },
        /**
         * The label:value pairs for the contact data display
         */
        contact_summary_data: function () {
            return this.createSummaryList([
                {
                    label: "Primary Email",
                    key: 'primary_email.value'
                },
                {
                    label: "Primary Phone",
                    key: 'primary_phone.value'
                }
            ]);
        },
    },
    components: {
        SelectRepresentation: _components_CompetitionRegistration_SelectRepresentation_vue__WEBPACK_IMPORTED_MODULE_3__["default"],
        EditProfile: _components_EditProfile_vue__WEBPACK_IMPORTED_MODULE_4__["default"]
    }
}));


/***/ }),

/***/ "./node_modules/ts-loader/index.js?!./node_modules/vue-loader/lib/index.js?!./src/js/pages/CompetitionRegistration/CompetitionRegistrationWaivers.vue?vue&type=script&lang=ts&":
/*!*********************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/ts-loader??ref--5!./node_modules/vue-loader/lib??vue-loader-options!./src/js/pages/CompetitionRegistration/CompetitionRegistrationWaivers.vue?vue&type=script&lang=ts& ***!
  \*********************************************************************************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var vue_typed_mixins__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue-typed-mixins */ "./node_modules/vue-typed-mixins/lib/index.js");
/* harmony import */ var _mixins_HasDataDependencies__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../mixins/HasDataDependencies */ "./src/js/mixins/HasDataDependencies.ts");
/* harmony import */ var _mixins_HasCompetitionRegistrationCompetitionMixin__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../mixins/HasCompetitionRegistrationCompetitionMixin */ "./src/js/mixins/HasCompetitionRegistrationCompetitionMixin.ts");



/* harmony default export */ __webpack_exports__["default"] = (Object(vue_typed_mixins__WEBPACK_IMPORTED_MODULE_0__["default"])(_mixins_HasCompetitionRegistrationCompetitionMixin__WEBPACK_IMPORTED_MODULE_2__["default"], _mixins_HasDataDependencies__WEBPACK_IMPORTED_MODULE_1__["default"]).extend({
    data: function () {
        return {
            /**
             * data needed for component to function
             */
            dependencies: {
                competition: false,
                screen_config: false
            },
            /**
             * Local tracking of waivers information
             */
            waivers: [],
            /**
             * Whether the waivers have been changed
             */
            waivers_changed: false,
            /**
             * Whether the waivers are in the process of saving
             */
            saving: false,
            /**
             * If saving waivers resulted in an error
             */
            save_error: null
        };
    },
    /**
     * On creation, set local waivers data to state waivers
     */
    created: function () {
        this.waivers = this.user_waivers.slice();
    },
    methods: {
        /**
         * Load data needed for component to function
         */
        loadData: function () {
            var _this = this;
            return new Promise(function (resolve, reject) {
                var promises = [
                    _this.$store.dispatch('competition_registration/fetchWaiversScreenData').then(function () {
                        _this.dependencies.screen_config = true;
                        _this.dependencies.competition = true;
                    }).catch(function () {
                        reject();
                    })
                ];
                Promise.all(promises).then(function () {
                    resolve();
                });
            });
        },
        /**
         * Whether a waiver is complete
         */
        isComplete: function (waiver) {
            return !!waiver.status.name && !!waiver.status.relationship;
        },
        /**
         * Save the active waiver data
         */
        saveWaiversData: function () {
            var _this = this;
            this.saving = true;
            return new Promise(function (resolve, reject) {
                _this.$store.dispatch('user/saveWaivers', _this.waivers).then(function () {
                    resolve();
                }).catch(function (error_message) {
                    _this.saving = false;
                    _this.save_error = error_message;
                });
            });
        },
        /**
         * Handle the continue button click. Save waiver data if it's changed and direct to next page
         */
        advance: function () {
            var _this = this;
            if (this.block_continue) {
                return;
            }
            if (!this.waivers_changed) {
                location.assign(this.competition.registration_links.cart);
                return;
            }
            this.saveWaiversData().then(function () {
                location.assign(_this.competition.registration_links.cart);
            });
        },
        /**
         * Handle the "back" button click
         */
        retreat: function () {
            location.assign(this.competition.registration_links.coach_information);
        },
    },
    computed: {
        /**
         * Whether the waivers are complete
         */
        waivers_complete: function () {
            for (var i in this.waivers) {
                var waiver = this.waivers[i];
                if (!waiver.status.name || !waiver.status.relationship) {
                    return false;
                }
            }
            return true;
        },
        /**
         * Whether continue button should be disabled and continuing blocked
         */
        block_continue: function () {
            if (this.saving) {
                return true;
            }
            return !this.waivers_complete;
        },
        /**
         * State-based waiver data
         */
        user_waivers: function () {
            return this.$store.getters['user/waivers'];
        },
        /**
         * Form options for relationship inputs
         */
        relationship_form_options: function () {
            return this.$store.getters['form_options/waiver_relationships'];
        },
        /**
         * The active step in the competition registration process.  Depends on whether the competition supports partner events
         */
        active_step_number: function () {
            if (this.active_competition && !this.competition.has_partner_events) {
                return 5;
            }
            return 7;
        }
    },
    watch: {
        /**
         * When waivers data changes, clear errors and log that data needs to be saved
         */
        waivers: {
            handler: function () {
                this.waivers_changed = true;
                this.save_error = null;
            }, deep: true
        },
        /**
         * When state based waivers change, update local state
         */
        user_waivers: function (value) {
            var _this = this;
            this.waivers = value.slice();
            this.$nextTick(function () {
                _this.waivers_changed = false;
            });
        }
    }
}));


/***/ }),

/***/ "./node_modules/vue-loader/lib/loaders/templateLoader.js?!./node_modules/vue-loader/lib/index.js?!./src/js/components/AutoSuggest.vue?vue&type=template&id=7e45a639&":
/*!********************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./src/js/components/AutoSuggest.vue?vue&type=template&id=7e45a639& ***!
  \********************************************************************************************************************************************************************************************************/
/*! exports provided: render, staticRenderFns */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "render", function() { return render; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "staticRenderFns", function() { return staticRenderFns; });
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c("div", { staticClass: "autosuggest" }, [
    _vm.input_attrs.type === "checkbox"
      ? _c(
          "input",
          _vm._b(
            {
              directives: [
                {
                  name: "model",
                  rawName: "v-model",
                  value: _vm.active_input_text,
                  expression: "active_input_text"
                }
              ],
              attrs: { type: "checkbox" },
              domProps: {
                checked: Array.isArray(_vm.active_input_text)
                  ? _vm._i(_vm.active_input_text, null) > -1
                  : _vm.active_input_text
              },
              on: {
                keydown: [
                  function($event) {
                    if (
                      !("button" in $event) &&
                      _vm._k($event.keyCode, "tab", 9, $event.key, "Tab")
                    ) {
                      return null
                    }
                    return _vm.handleTab($event)
                  },
                  function($event) {
                    if (
                      !("button" in $event) &&
                      _vm._k($event.keyCode, "enter", 13, $event.key, "Enter")
                    ) {
                      return null
                    }
                    return _vm.handleEnter($event)
                  },
                  function($event) {
                    if (
                      !("button" in $event) &&
                      _vm._k($event.keyCode, "up", 38, $event.key, [
                        "Up",
                        "ArrowUp"
                      ])
                    ) {
                      return null
                    }
                    $event.preventDefault()
                    return _vm.handleUp($event)
                  },
                  function($event) {
                    if (
                      !("button" in $event) &&
                      _vm._k($event.keyCode, "down", 40, $event.key, [
                        "Down",
                        "ArrowDown"
                      ])
                    ) {
                      return null
                    }
                    $event.preventDefault()
                    return _vm.handleDown($event)
                  }
                ],
                focus: _vm.handleFocus,
                blur: _vm.handleBlur,
                input: _vm.handleInput,
                change: function($event) {
                  var $$a = _vm.active_input_text,
                    $$el = $event.target,
                    $$c = $$el.checked ? true : false
                  if (Array.isArray($$a)) {
                    var $$v = null,
                      $$i = _vm._i($$a, $$v)
                    if ($$el.checked) {
                      $$i < 0 && (_vm.active_input_text = $$a.concat([$$v]))
                    } else {
                      $$i > -1 &&
                        (_vm.active_input_text = $$a
                          .slice(0, $$i)
                          .concat($$a.slice($$i + 1)))
                    }
                  } else {
                    _vm.active_input_text = $$c
                  }
                }
              }
            },
            "input",
            _vm.input_attrs,
            false
          )
        )
      : _vm.input_attrs.type === "radio"
      ? _c(
          "input",
          _vm._b(
            {
              directives: [
                {
                  name: "model",
                  rawName: "v-model",
                  value: _vm.active_input_text,
                  expression: "active_input_text"
                }
              ],
              attrs: { type: "radio" },
              domProps: { checked: _vm._q(_vm.active_input_text, null) },
              on: {
                keydown: [
                  function($event) {
                    if (
                      !("button" in $event) &&
                      _vm._k($event.keyCode, "tab", 9, $event.key, "Tab")
                    ) {
                      return null
                    }
                    return _vm.handleTab($event)
                  },
                  function($event) {
                    if (
                      !("button" in $event) &&
                      _vm._k($event.keyCode, "enter", 13, $event.key, "Enter")
                    ) {
                      return null
                    }
                    return _vm.handleEnter($event)
                  },
                  function($event) {
                    if (
                      !("button" in $event) &&
                      _vm._k($event.keyCode, "up", 38, $event.key, [
                        "Up",
                        "ArrowUp"
                      ])
                    ) {
                      return null
                    }
                    $event.preventDefault()
                    return _vm.handleUp($event)
                  },
                  function($event) {
                    if (
                      !("button" in $event) &&
                      _vm._k($event.keyCode, "down", 40, $event.key, [
                        "Down",
                        "ArrowDown"
                      ])
                    ) {
                      return null
                    }
                    $event.preventDefault()
                    return _vm.handleDown($event)
                  }
                ],
                focus: _vm.handleFocus,
                blur: _vm.handleBlur,
                input: _vm.handleInput,
                change: function($event) {
                  _vm.active_input_text = null
                }
              }
            },
            "input",
            _vm.input_attrs,
            false
          )
        )
      : _c(
          "input",
          _vm._b(
            {
              directives: [
                {
                  name: "model",
                  rawName: "v-model",
                  value: _vm.active_input_text,
                  expression: "active_input_text"
                }
              ],
              attrs: { type: _vm.input_attrs.type },
              domProps: { value: _vm.active_input_text },
              on: {
                keydown: [
                  function($event) {
                    if (
                      !("button" in $event) &&
                      _vm._k($event.keyCode, "tab", 9, $event.key, "Tab")
                    ) {
                      return null
                    }
                    return _vm.handleTab($event)
                  },
                  function($event) {
                    if (
                      !("button" in $event) &&
                      _vm._k($event.keyCode, "enter", 13, $event.key, "Enter")
                    ) {
                      return null
                    }
                    return _vm.handleEnter($event)
                  },
                  function($event) {
                    if (
                      !("button" in $event) &&
                      _vm._k($event.keyCode, "up", 38, $event.key, [
                        "Up",
                        "ArrowUp"
                      ])
                    ) {
                      return null
                    }
                    $event.preventDefault()
                    return _vm.handleUp($event)
                  },
                  function($event) {
                    if (
                      !("button" in $event) &&
                      _vm._k($event.keyCode, "down", 40, $event.key, [
                        "Down",
                        "ArrowDown"
                      ])
                    ) {
                      return null
                    }
                    $event.preventDefault()
                    return _vm.handleDown($event)
                  }
                ],
                focus: _vm.handleFocus,
                blur: _vm.handleBlur,
                input: [
                  function($event) {
                    if ($event.target.composing) {
                      return
                    }
                    _vm.active_input_text = $event.target.value
                  },
                  _vm.handleInput
                ]
              }
            },
            "input",
            _vm.input_attrs,
            false
          )
        ),
    _vm._v(" "),
    _vm.show_suggestions
      ? _c("div", { staticClass: "autosuggest__suggestions" }, [
          _c("div", { staticClass: "autosuggest__suggestions__content" }, [
            _c(
              "ul",
              { staticClass: "autosuggest__list" },
              _vm._l(_vm.suggestions, function(value, index) {
                return _c(
                  "li",
                  {
                    staticClass: "autosuggest__list__item",
                    class: { active: _vm.isActive(index) },
                    on: {
                      mousedown: _vm.mouseDown,
                      touchstart: _vm.mouseDown,
                      click: function($event) {
                        _vm.select(value)
                      }
                    }
                  },
                  [_vm._v("\n\t\t\t\t\t" + _vm._s(value.label) + "\n\t\t\t\t")]
                )
              })
            )
          ])
        ])
      : _vm._e()
  ])
}
var staticRenderFns = []
render._withStripped = true



/***/ }),

/***/ "./node_modules/vue-loader/lib/loaders/templateLoader.js?!./node_modules/vue-loader/lib/index.js?!./src/js/components/CompetitionRegistration/CompetitionRegistrationProgress.vue?vue&type=template&id=13ec7932&":
/*!****************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./src/js/components/CompetitionRegistration/CompetitionRegistrationProgress.vue?vue&type=template&id=13ec7932& ***!
  \****************************************************************************************************************************************************************************************************************************************************/
/*! exports provided: render, staticRenderFns */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "render", function() { return render; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "staticRenderFns", function() { return staticRenderFns; });
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c("progress-bar", {
    style: { visibility: _vm.total_registration_steps ? "visible" : "hidden" },
    attrs: {
      available_step_count: _vm.total_registration_steps,
      active_step_number: _vm.active_step
    }
  })
}
var staticRenderFns = []
render._withStripped = true



/***/ }),

/***/ "./node_modules/vue-loader/lib/loaders/templateLoader.js?!./node_modules/vue-loader/lib/index.js?!./src/js/components/CompetitionRegistration/EventRequirementsOverlay.vue?vue&type=template&id=45298f29&":
/*!*********************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./src/js/components/CompetitionRegistration/EventRequirementsOverlay.vue?vue&type=template&id=45298f29& ***!
  \*********************************************************************************************************************************************************************************************************************************************/
/*! exports provided: render, staticRenderFns */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "render", function() { return render; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "staticRenderFns", function() { return staticRenderFns; });
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c("div", { staticClass: "event-requirements-overlay" }, [
    _c("div", { staticClass: "competition-registration-takeover" }, [
      _c("div", { staticClass: "competition-registration-takeover__header" }, [
        _c("h2", { staticClass: "competition-registration-takeover__title" }, [
          _vm._v("\n                Event Requirements\n            ")
        ]),
        _vm._v(" "),
        _c(
          "p",
          { staticClass: "competition-registration-takeover__header__lead" },
          [
            _vm._v(
              "\n                Please review the requirements below. Your partner must meet them to be eligible to participate.\n            "
            )
          ]
        ),
        _vm._v(" "),
        _c("hr", {
          staticClass: "competition-registration-takeover__header-divider"
        }),
        _vm._v(" "),
        _c("div", { staticClass: "event-requirements-overlay__header" }, [
          _c(
            "h3",
            { staticClass: "event-requirements-overlay__header__partner-name" },
            [
              _vm._v(
                "\n                    " +
                  _vm._s(_vm.requirements_data.partner.name) +
                  "\n                "
              )
            ]
          ),
          _vm._v(" "),
          _c(
            "ul",
            {
              staticClass:
                "label-list event-requirements-overlay__header__event-details"
            },
            [
              _c("li", [
                _c("span", { staticClass: "label-list__label" }, [
                  _vm._v("Event Name:")
                ]),
                _vm._v(" "),
                _c("span", { staticClass: "label-list__value" }, [
                  _vm._v(_vm._s(_vm.requirements_data.event.name))
                ])
              ])
            ]
          )
        ])
      ]),
      _vm._v(" "),
      _c(
        "div",
        {
          staticClass:
            "competition-registration-takeover__content competition-registration-takeover__content--event-requirements"
        },
        [
          _c("div", { staticClass: "event-requirements-overlay__content" }, [
            _c("div", { staticClass: "grid-container" }, [
              _vm.show_skate_test_requirements
                ? _c("div", { staticClass: "card" }, [
                    _c("div", { staticClass: "card__content" }, [
                      _c("h3", { staticClass: "card__heading" }, [
                        _vm._v(
                          "\n                                Skate Test Requirements:\n                            "
                        )
                      ]),
                      _vm._v(" "),
                      _vm.show_min_skate_tests
                        ? _c("div", { staticClass: "card__section" }, [
                            _c("p", { staticClass: "card__text" }, [
                              _vm._v(
                                "\n                                    Your partner must meet one of the following minimum requirements:\n                                "
                              )
                            ]),
                            _vm._v(" "),
                            _c(
                              "ul",
                              { staticClass: "card__list list list--light" },
                              _vm._l(_vm.minimum_skate_tests, function(
                                minimum_skate_test_requirement
                              ) {
                                return _c("li", [
                                  _c("span", { staticClass: "list__text" }, [
                                    _vm._v(
                                      _vm._s(minimum_skate_test_requirement)
                                    )
                                  ])
                                ])
                              })
                            )
                          ])
                        : _vm._e(),
                      _vm._v(" "),
                      _vm.show_max_skate_tests
                        ? _c("div", { staticClass: "card__section" }, [
                            _c("p", { staticClass: "card__text" }, [
                              _vm._v(
                                "\n                                    Your partner must meet all of the following maximum requirements:\n                                "
                              )
                            ]),
                            _vm._v(" "),
                            _c(
                              "ul",
                              { staticClass: "card__list list list--light" },
                              _vm._l(_vm.maximum_skate_tests, function(
                                maximum_skate_test_requirement
                              ) {
                                return _c("li", [
                                  _c("span", { staticClass: "list__text" }, [
                                    _vm._v(
                                      _vm._s(maximum_skate_test_requirement)
                                    )
                                  ])
                                ])
                              })
                            )
                          ])
                        : _vm._e()
                    ])
                  ])
                : _vm._e(),
              _vm._v(" "),
              _vm.show_age_requirements
                ? _c("div", { staticClass: "card" }, [
                    _c("div", { staticClass: "card__content" }, [
                      _c("h3", { staticClass: "card__heading" }, [
                        _vm._v(
                          "\n                                Age Requirements:\n                            "
                        )
                      ]),
                      _vm._v(" "),
                      _c("div", { staticClass: "card__section" }, [
                        _vm.show_min_age
                          ? _c("p", { staticClass: "card__text" }, [
                              _vm._v(
                                "\n                                    Your partner must be at least\n                                    "
                              ),
                              _c("span", { staticClass: "text--highlight" }, [
                                _vm._v(_vm._s(_vm.minimum_age))
                              ]),
                              _vm._v(
                                "\n                                    years-old.\n                                "
                              )
                            ])
                          : _vm._e(),
                        _vm._v(" "),
                        _vm.show_max_age
                          ? _c("p", { staticClass: "card__text" }, [
                              _vm._v(
                                "\n                                    Your partner can not be older than\n                                    "
                              ),
                              _c("span", { staticClass: "text--highlight" }, [
                                _vm._v(_vm._s(_vm.maximum_age))
                              ]),
                              _vm._v(
                                "\n                                    years-old.\n                                "
                              )
                            ])
                          : _vm._e()
                      ])
                    ])
                  ])
                : _vm._e(),
              _vm._v(" "),
              _c(
                "div",
                { staticClass: "event-requirements-overlay__close" },
                [_vm._t("close-button")],
                2
              )
            ])
          ])
        ]
      )
    ])
  ])
}
var staticRenderFns = []
render._withStripped = true



/***/ }),

/***/ "./node_modules/vue-loader/lib/loaders/templateLoader.js?!./node_modules/vue-loader/lib/index.js?!./src/js/components/CompetitionRegistration/EventSelectionEvent.vue?vue&type=template&id=b8523b16&":
/*!****************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./src/js/components/CompetitionRegistration/EventSelectionEvent.vue?vue&type=template&id=b8523b16& ***!
  \****************************************************************************************************************************************************************************************************************************************/
/*! exports provided: render, staticRenderFns */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "render", function() { return render; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "staticRenderFns", function() { return staticRenderFns; });
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "div",
    {
      staticClass: "event-card",
      class: {
        "event-card--registered": _vm.event.is_registered_for,
        "event-card--selected": _vm.event.is_selected
      }
    },
    [
      _c(
        "div",
        { staticClass: "event-card__content" },
        [
          _c("div", { staticClass: "event-card__details" }, [
            _c("p", { staticClass: "event-card__event-name" }, [
              _vm._v(_vm._s(_vm.event.name))
            ]),
            _vm._v(" "),
            _c("p", { staticClass: "event-card__event-details" }, [
              _vm._v("Judging System:\n\t\t\t\t"),
              _c(
                "span",
                {
                  class: {
                    "ijs-fix": _vm.event.judging_system.toLowerCase() === "ijs"
                  }
                },
                [_vm._v(_vm._s(_vm.event.judging_system))]
              )
            ])
          ]),
          _vm._v(" "),
          _vm._t("actions")
        ],
        2
      ),
      _vm._v(" "),
      _vm._t("error")
    ],
    2
  )
}
var staticRenderFns = []
render._withStripped = true



/***/ }),

/***/ "./node_modules/vue-loader/lib/loaders/templateLoader.js?!./node_modules/vue-loader/lib/index.js?!./src/js/components/DateInput.vue?vue&type=template&id=e6e2c8c0&":
/*!******************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./src/js/components/DateInput.vue?vue&type=template&id=e6e2c8c0& ***!
  \******************************************************************************************************************************************************************************************************/
/*! exports provided: render, staticRenderFns */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "render", function() { return render; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "staticRenderFns", function() { return staticRenderFns; });
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c("input", {
    staticClass: "form-field",
    attrs: { maxlength: "10", type: "text" },
    domProps: { value: _vm.formatted },
    on: {
      input: function($event) {
        _vm.valueChanged($event.target.value)
      }
    }
  })
}
var staticRenderFns = []
render._withStripped = true



/***/ }),

/***/ "./node_modules/vue-loader/lib/loaders/templateLoader.js?!./node_modules/vue-loader/lib/index.js?!./src/js/components/ProgressBar.vue?vue&type=template&id=70fb958a&":
/*!********************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./src/js/components/ProgressBar.vue?vue&type=template&id=70fb958a& ***!
  \********************************************************************************************************************************************************************************************************/
/*! exports provided: render, staticRenderFns */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "render", function() { return render; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "staticRenderFns", function() { return staticRenderFns; });
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c("div", { staticClass: "progress-bar" }, [
    _c("div", { staticClass: "progress-bar__bar" }, [
      _c("span", { staticClass: "progress-bar__track" }, [_vm._v(" ")]),
      _vm._v(" "),
      _c(
        "span",
        {
          staticClass: "progress-bar__progress",
          style: { width: _vm.completed_progress_percent + "%" }
        },
        [_vm._v(" ")]
      )
    ]),
    _vm._v(" "),
    _c("div", { staticClass: "progress-bar__steps" }, [
      _vm._v(
        "\n\t\t" +
          _vm._s(_vm.active_step_number) +
          "/" +
          _vm._s(_vm.available_step_count) +
          "\n\t"
      )
    ])
  ])
}
var staticRenderFns = []
render._withStripped = true



/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "./src/js/CompetitionPortal/_models/ActiveCompetitionSummary.ts":
/*!**********************************************************************!*\
  !*** ./src/js/CompetitionPortal/_models/ActiveCompetitionSummary.ts ***!
  \**********************************************************************/
/*! exports provided: ActiveCompetitionSummary */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ActiveCompetitionSummary", function() { return ActiveCompetitionSummary; });
var ActiveCompetitionSummary = /** @class */ (function () {
    function ActiveCompetitionSummary(params) {
        this.announcement_url = params.announcement_url;
        this.directions = params.directions;
        this.end_date_pretty = params.end_date_pretty;
        this.icon = params.icon;
        this.id = params.id;
        this.name = params.name;
        this.start_date_pretty = params.start_date_pretty;
        this.website_url = params.website_url;
    }
    return ActiveCompetitionSummary;
}());



/***/ }),

/***/ "./src/js/CompetitionPortal/_models/ActiveEntitySummary.ts":
/*!*****************************************************************!*\
  !*** ./src/js/CompetitionPortal/_models/ActiveEntitySummary.ts ***!
  \*****************************************************************/
/*! exports provided: ActiveEntitySummary */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ActiveEntitySummary", function() { return ActiveEntitySummary; });
var ActiveEntitySummary = /** @class */ (function () {
    function ActiveEntitySummary(params) {
        this.compliance = params.compliance;
        this.name = params.name;
    }
    return ActiveEntitySummary;
}());



/***/ }),

/***/ "./src/js/CompetitionPortal/_models/CompetitionPortalCompetitionInformation.ts":
/*!*************************************************************************************!*\
  !*** ./src/js/CompetitionPortal/_models/CompetitionPortalCompetitionInformation.ts ***!
  \*************************************************************************************/
/*! exports provided: CompetitionPortalCompetitionInformation */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CompetitionPortalCompetitionInformation", function() { return CompetitionPortalCompetitionInformation; });
var CompetitionPortalCompetitionInformation = /** @class */ (function () {
    function CompetitionPortalCompetitionInformation(params) {
        this.registered_events = params.registered_events;
        this.practice_ice = params.practice_ice;
    }
    Object.defineProperty(CompetitionPortalCompetitionInformation.prototype, "practice_ice_instructions", {
        get: function () {
            return this.practice_ice.instructions || '';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CompetitionPortalCompetitionInformation.prototype, "practice_ice_terminology", {
        get: function () {
            return this.practice_ice.terminology || '';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CompetitionPortalCompetitionInformation.prototype, "no_practice_ice", {
        get: function () {
            return this.practice_ice.not_offered;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CompetitionPortalCompetitionInformation.prototype, "pricing_message", {
        get: function () {
            return this.practice_ice.pricing_message;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CompetitionPortalCompetitionInformation.prototype, "practice_ice_event_pricing", {
        get: function () {
            return this.practice_ice.event_pricing;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CompetitionPortalCompetitionInformation.prototype, "practice_ice_sales_windows", {
        get: function () {
            return this.practice_ice.sales_windows;
        },
        enumerable: true,
        configurable: true
    });
    return CompetitionPortalCompetitionInformation;
}());



/***/ }),

/***/ "./src/js/CompetitionPortal/_models/CompetitionSelectableEntity.ts":
/*!*************************************************************************!*\
  !*** ./src/js/CompetitionPortal/_models/CompetitionSelectableEntity.ts ***!
  \*************************************************************************/
/*! exports provided: CompetitionSelectableEntity */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CompetitionSelectableEntity", function() { return CompetitionSelectableEntity; });
var __assign = (undefined && undefined.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
var CompetitionSelectableEntity = /** @class */ (function () {
    function CompetitionSelectableEntity(params) {
        this.selection_information = {
            is_selectable: true
        };
        this.id = params.id;
        this.level = params.level || '';
        this.member_number = params.member_number;
        this.membership_status = __assign({}, params.membership_status);
        this.name = params.name;
        this.links = __assign({}, params.links);
    }
    Object.defineProperty(CompetitionSelectableEntity.prototype, "is_selectable", {
        get: function () {
            return this.selection_information.is_selectable;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CompetitionSelectableEntity.prototype, "not_selectable_reason", {
        get: function () {
            if ('is_not_selectable_reason' in this.selection_information && this.selection_information.is_not_selectable_reason) {
                return this.selection_information.is_not_selectable_reason;
            }
            return null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CompetitionSelectableEntity.prototype, "not_selectable_link", {
        get: function () {
            if ('not_selectable_link' in this.selection_information && this.selection_information.not_selectable_link) {
                return this.selection_information.not_selectable_link;
            }
            return null;
        },
        enumerable: true,
        configurable: true
    });
    return CompetitionSelectableEntity;
}());



/***/ }),

/***/ "./src/js/CompetitionPortal/_models/DataNavigationLink.ts":
/*!****************************************************************!*\
  !*** ./src/js/CompetitionPortal/_models/DataNavigationLink.ts ***!
  \****************************************************************/
/*! exports provided: DataNavigationLink */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DataNavigationLink", function() { return DataNavigationLink; });
var DataNavigationLink = /** @class */ (function () {
    /* eslint-disable-next-line jsdoc/require-jsdoc */
    function DataNavigationLink(params) {
        this.label = params.label;
        this.url = params.url;
        this.is_disabled = params.is_disabled;
        if (params.is_complete) {
            this.is_complete = params.is_complete;
        }
        if (params.data) {
            this.data = params.data;
        }
    }
    return DataNavigationLink;
}());



/***/ }),

/***/ "./src/js/CompetitionPortal/_models/index.ts":
/*!***************************************************!*\
  !*** ./src/js/CompetitionPortal/_models/index.ts ***!
  \***************************************************/
/*! exports provided: ActiveCompetitionSummary, ActiveEntitySummary, CompetitionPortalCompetitionInformation, CompetitionSelectableEntity, DataNavigationLink */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _ActiveCompetitionSummary__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ActiveCompetitionSummary */ "./src/js/CompetitionPortal/_models/ActiveCompetitionSummary.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ActiveCompetitionSummary", function() { return _ActiveCompetitionSummary__WEBPACK_IMPORTED_MODULE_0__["ActiveCompetitionSummary"]; });

/* harmony import */ var _ActiveEntitySummary__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ActiveEntitySummary */ "./src/js/CompetitionPortal/_models/ActiveEntitySummary.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ActiveEntitySummary", function() { return _ActiveEntitySummary__WEBPACK_IMPORTED_MODULE_1__["ActiveEntitySummary"]; });

/* harmony import */ var _CompetitionPortalCompetitionInformation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./CompetitionPortalCompetitionInformation */ "./src/js/CompetitionPortal/_models/CompetitionPortalCompetitionInformation.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CompetitionPortalCompetitionInformation", function() { return _CompetitionPortalCompetitionInformation__WEBPACK_IMPORTED_MODULE_2__["CompetitionPortalCompetitionInformation"]; });

/* harmony import */ var _CompetitionSelectableEntity__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./CompetitionSelectableEntity */ "./src/js/CompetitionPortal/_models/CompetitionSelectableEntity.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CompetitionSelectableEntity", function() { return _CompetitionSelectableEntity__WEBPACK_IMPORTED_MODULE_3__["CompetitionSelectableEntity"]; });

/* harmony import */ var _DataNavigationLink__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./DataNavigationLink */ "./src/js/CompetitionPortal/_models/DataNavigationLink.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DataNavigationLink", function() { return _DataNavigationLink__WEBPACK_IMPORTED_MODULE_4__["DataNavigationLink"]; });








/***/ }),

/***/ "./src/js/CompetitionPortal/_services/CompetitionPortalApiService.ts":
/*!***************************************************************************!*\
  !*** ./src/js/CompetitionPortal/_services/CompetitionPortalApiService.ts ***!
  \***************************************************************************/
/*! exports provided: CompetitionPortalApiService */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CompetitionPortalApiService", function() { return CompetitionPortalApiService; });
/* harmony import */ var _services_AbstractAPIService__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../services/AbstractAPIService */ "./src/js/services/AbstractAPIService.ts");
/* harmony import */ var _transformers_CompetitionPortalApiTransformer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../_transformers/CompetitionPortalApiTransformer */ "./src/js/CompetitionPortal/_transformers/CompetitionPortalApiTransformer.ts");
/* harmony import */ var _CompetitionPortalAppService__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./CompetitionPortalAppService */ "./src/js/CompetitionPortal/_services/CompetitionPortalAppService.ts");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/* eslint-disable max-lines */



var CompetitionPortalApiService = /** @class */ (function (_super) {
    __extends(CompetitionPortalApiService, _super);
    function CompetitionPortalApiService() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Fetch data for the the My Teams page
     */
    CompetitionPortalApiService.fetchMyTeams = function () {
        var competition_id = _CompetitionPortalAppService__WEBPACK_IMPORTED_MODULE_2__["CompetitionPortalAppService"].getActiveCompetitionPortalCompetitionId();
        var url = "/api/user/managed-teams/competitions/" + competition_id + "/registered-teams";
        return this.fetchAndTransformResponse({
            url: url,
            /**
             * Transform API data to App Data
             */
            transformResponse: function (response) {
                return _transformers_CompetitionPortalApiTransformer__WEBPACK_IMPORTED_MODULE_1__["CompetitionPortalApiTransformer"].transformFetchMyTeams(response);
            },
            /**
             * Validate API response
             */
            validateResponse: function (response) {
                if (!response.teams) {
                    console.error('teams not provided in response');
                    return false;
                }
                if (!response.competition_summary) {
                    console.error('competition summary not provided in response');
                    return false;
                }
                return true;
            }
        });
    };
    /**
     * Fetch data for the the Competition Portal Main page
     */
    CompetitionPortalApiService.fetchCompetitionMain = function () {
        var competition_id = _CompetitionPortalAppService__WEBPACK_IMPORTED_MODULE_2__["CompetitionPortalAppService"].getActiveCompetitionPortalCompetitionId();
        var team_id = _CompetitionPortalAppService__WEBPACK_IMPORTED_MODULE_2__["CompetitionPortalAppService"].getActiveCompetitionPortalTeamId();
        var url = team_id ? "/api/competitions/" + competition_id + "/teams/" + team_id + "/main" : "/api/competitions/" + competition_id + "/main";
        return _services_AbstractAPIService__WEBPACK_IMPORTED_MODULE_0__["AbstractAPIService"].fetchAndTransformResponse({
            url: url,
            /**
             * Validate that the response is present and is an object
             */
            validateResponse: function (response) {
                var required_props = ['competition'];
                for (var i = 0; i < required_props.length; i++) {
                    var requiredProp = required_props[i];
                    if (!Object.prototype.hasOwnProperty.call(response, requiredProp)) {
                        console.error(requiredProp + " missing from response");
                        return false;
                    }
                }
                return true;
            },
            /**
             * Transform API data to App data
             */
            transformResponse: function (response) {
                return _transformers_CompetitionPortalApiTransformer__WEBPACK_IMPORTED_MODULE_1__["CompetitionPortalApiTransformer"].transformFetchCompetitionMain(response);
            }
        });
    };
    /**
     * Fetch data for the the Select Competition Entity page
     */
    CompetitionPortalApiService.fetchEntitySelect = function () {
        var competition_id = _CompetitionPortalAppService__WEBPACK_IMPORTED_MODULE_2__["CompetitionPortalAppService"].getActiveCompetitionPortalCompetitionId();
        var url = "/api/competitions/" + competition_id + "/entity-select";
        return this.fetchAndTransformResponse({
            url: url,
            /**
             * Transform API data to App Data
             */
            transformResponse: function (response) {
                return _transformers_CompetitionPortalApiTransformer__WEBPACK_IMPORTED_MODULE_1__["CompetitionPortalApiTransformer"].transformFetchEntitySelect(response);
            },
            /**
             * Validate API response
             */
            validateResponse: function (response) {
                var required_props = ['competition_summary', 'entities'];
                for (var i = 0; i < required_props.length; i++) {
                    var requiredProp = required_props[i];
                    if (!Object.prototype.hasOwnProperty.call(response, requiredProp)) {
                        console.error(requiredProp + " missing from response");
                        return false;
                    }
                }
                return true;
            }
        });
    };
    /**
     * Fetch data for the competition documents page
     */
    CompetitionPortalApiService.fetchCompetitionDocuments = function () {
        var competition_id = _CompetitionPortalAppService__WEBPACK_IMPORTED_MODULE_2__["CompetitionPortalAppService"].getActiveCompetitionPortalCompetitionId();
        var team_id = _CompetitionPortalAppService__WEBPACK_IMPORTED_MODULE_2__["CompetitionPortalAppService"].getActiveCompetitionPortalTeamId();
        var url = team_id ? "/api/competitions/" + competition_id + "/teams/" + team_id + "/documents" : "/api/competitions/" + competition_id + "/documents";
        return this.fetchAndTransformResponse({
            url: url,
            /**
             * Transform API data to App Data
             */
            transformResponse: function (response) {
                return _transformers_CompetitionPortalApiTransformer__WEBPACK_IMPORTED_MODULE_1__["CompetitionPortalApiTransformer"].transformFetchCompetitionDocuments(response);
            },
            /**
             * Validate API response
             */
            validateResponse: function (response) {
                if (!response.competition_documents) {
                    console.error('competition documents not provided in response');
                    return false;
                }
                if (!response.competition_summary) {
                    console.error('competition summary not provided in response');
                    return false;
                }
                return true;
            }
        });
    };
    /**
     * Update the completion status on a competition document
     */
    CompetitionPortalApiService.updateCompetitionDocumentCompletion = function (document) {
        var competition_id = _CompetitionPortalAppService__WEBPACK_IMPORTED_MODULE_2__["CompetitionPortalAppService"].getActiveCompetitionPortalCompetitionId();
        var team_id = _CompetitionPortalAppService__WEBPACK_IMPORTED_MODULE_2__["CompetitionPortalAppService"].getActiveCompetitionPortalTeamId();
        var payload = {
            is_complete: !document.is_complete
        };
        var url = team_id ? "/api/competitions/" + competition_id + "/teams/" + team_id + "/documents/" + document.id : "/api/competitions/" + competition_id + "/documents/" + document.id;
        return CompetitionPortalApiService.submitForAPISubmissionResponse({
            error_message: 'Error updating document status',
            method: 'put',
            payload: payload,
            url: url
        });
    };
    /**
     * Fetch data for the the Competition Portal Competition Contacts page
     */
    CompetitionPortalApiService.fetchCompetitionContacts = function () {
        var competition_id = _CompetitionPortalAppService__WEBPACK_IMPORTED_MODULE_2__["CompetitionPortalAppService"].getActiveCompetitionPortalCompetitionId();
        var team_id = _CompetitionPortalAppService__WEBPACK_IMPORTED_MODULE_2__["CompetitionPortalAppService"].getActiveCompetitionPortalTeamId();
        var url = team_id ? "/api/competitions/" + competition_id + "/teams/" + team_id + "/contacts" : "/api/competitions/" + competition_id + "/contacts";
        return _services_AbstractAPIService__WEBPACK_IMPORTED_MODULE_0__["AbstractAPIService"].fetchAndTransformResponse({
            url: url,
            /**
             * Validate that the response contains the proper structures
             */
            validateResponse: function (response) {
                var required_props = ['contacts', 'competition_summary'];
                for (var i = 0; i < required_props.length; i++) {
                    var requiredProp = required_props[i];
                    if (!Object.prototype.hasOwnProperty.call(response, requiredProp)) {
                        console.error(requiredProp + " missing from response");
                        return false;
                    }
                }
                return true;
            },
            /**
             * Transform API data to App data
             */
            transformResponse: function (response) {
                return _transformers_CompetitionPortalApiTransformer__WEBPACK_IMPORTED_MODULE_1__["CompetitionPortalApiTransformer"].transformFetchCompetitionContacts(response);
            }
        });
    };
    /**
     * Fetch data for the Competition Information page
     */
    CompetitionPortalApiService.fetchCompetitionInformation = function () {
        var competition_id = _CompetitionPortalAppService__WEBPACK_IMPORTED_MODULE_2__["CompetitionPortalAppService"].getActiveCompetitionPortalCompetitionId();
        var team_id = _CompetitionPortalAppService__WEBPACK_IMPORTED_MODULE_2__["CompetitionPortalAppService"].getActiveCompetitionPortalTeamId();
        var url = team_id ? "/api/competitions/" + competition_id + "/teams/" + team_id + "/competition-information" : "/api/competitions/" + competition_id + "/competition-information";
        return _services_AbstractAPIService__WEBPACK_IMPORTED_MODULE_0__["AbstractAPIService"].fetchAndTransformResponse({
            url: url,
            /**
             * Validate that the response is present and contains the necessary properties
             */
            validateResponse: function (response) {
                var required_props = ['competition_summary', 'competition_information'];
                for (var i = 0; i < required_props.length; i++) {
                    var requiredProp = required_props[i];
                    if (!Object.prototype.hasOwnProperty.call(response, requiredProp)) {
                        console.error(requiredProp + " missing from response");
                        return false;
                    }
                }
                return true;
            },
            /**
             * Transform API data to App data
             */
            transformResponse: function (response) {
                return _transformers_CompetitionPortalApiTransformer__WEBPACK_IMPORTED_MODULE_1__["CompetitionPortalApiTransformer"].transformFetchCompetitionInformation(response);
            }
        });
    };
    /**
     * Fetch data for the Music & PPC page
     */
    CompetitionPortalApiService.fetchMusicAndPpc = function () {
        var competition_id = _CompetitionPortalAppService__WEBPACK_IMPORTED_MODULE_2__["CompetitionPortalAppService"].getActiveCompetitionPortalCompetitionId();
        var team_id = _CompetitionPortalAppService__WEBPACK_IMPORTED_MODULE_2__["CompetitionPortalAppService"].getActiveCompetitionPortalTeamId();
        var url = team_id ? "/api/competitions/" + competition_id + "/teams/" + team_id + "/music-and-ppc" : "/api/competitions/" + competition_id + "/music-and-ppc";
        return _services_AbstractAPIService__WEBPACK_IMPORTED_MODULE_0__["AbstractAPIService"].fetchAndTransformResponse({
            url: url,
            /**
             * Validate that the response is present and contains the necessary properties
             */
            validateResponse: function (response) {
                var required_props = ['competition_summary', 'competition_information', 'entity_event_segments'];
                for (var i = 0; i < required_props.length; i++) {
                    var requiredProp = required_props[i];
                    if (!Object.prototype.hasOwnProperty.call(response, requiredProp)) {
                        console.error(requiredProp + " missing from response");
                        return false;
                    }
                }
                return true;
            },
            /**
             * Transform API data to App data
             */
            transformResponse: function (response) {
                return _transformers_CompetitionPortalApiTransformer__WEBPACK_IMPORTED_MODULE_1__["CompetitionPortalApiTransformer"].transformFetchMusicAndPpc(response);
            }
        });
    };
    /**
     * Transform a Music & PPC API URL to add support for teams
     */
    CompetitionPortalApiService.transformMusicPpcUrl = function (segment) {
        var competition_id = _CompetitionPortalAppService__WEBPACK_IMPORTED_MODULE_2__["CompetitionPortalAppService"].getActiveCompetitionPortalCompetitionId();
        var team_id = _CompetitionPortalAppService__WEBPACK_IMPORTED_MODULE_2__["CompetitionPortalAppService"].getActiveCompetitionPortalTeamId();
        var replacement = team_id ? "/api/competitions/" + competition_id + "/teams/" + team_id : "/api/competitions/" + competition_id;
        return replacement + "/" + segment;
    };
    /**
     * Fetch data for the Practice Ice Schedule page
     */
    CompetitionPortalApiService.fetchPracticeIceSchedule = function () {
        var competition_id = _CompetitionPortalAppService__WEBPACK_IMPORTED_MODULE_2__["CompetitionPortalAppService"].getActiveCompetitionPortalCompetitionId();
        var team_id = _CompetitionPortalAppService__WEBPACK_IMPORTED_MODULE_2__["CompetitionPortalAppService"].getActiveCompetitionPortalTeamId();
        var url = team_id ? "/api/competitions/" + competition_id + "/teams/" + team_id + "/practice-ice-schedules" : "/api/competitions/" + competition_id + "/practice-ice-schedules";
        return _services_AbstractAPIService__WEBPACK_IMPORTED_MODULE_0__["AbstractAPIService"].fetchAndTransformResponse({
            url: url,
            /**
             * Validate that the response is present and contains the necessary properties
             */
            validateResponse: function (response) {
                var required_props = ['competition_summary', 'cart', 'entity_credits', 'competition_information', 'active_sales_window'];
                for (var i = 0; i < required_props.length; i++) {
                    var requiredProp = required_props[i];
                    if (!Object.prototype.hasOwnProperty.call(response, requiredProp)) {
                        console.error(requiredProp + " missing from response");
                        return false;
                    }
                }
                return true;
            },
            /**
             * Transform API data to App data
             */
            transformResponse: function (response) {
                return _transformers_CompetitionPortalApiTransformer__WEBPACK_IMPORTED_MODULE_1__["CompetitionPortalApiTransformer"].transformFetchPracticeIceSchedule(response);
            }
        });
    };
    /**
     * Fetch data for the Practice Ice Pre-Purchase page
     */
    CompetitionPortalApiService.fetchPracticeIcePrePurchase = function () {
        var competition_id = _CompetitionPortalAppService__WEBPACK_IMPORTED_MODULE_2__["CompetitionPortalAppService"].getActiveCompetitionPortalCompetitionId();
        var team_id = _CompetitionPortalAppService__WEBPACK_IMPORTED_MODULE_2__["CompetitionPortalAppService"].getActiveCompetitionPortalTeamId();
        var url = team_id ? "/api/competitions/" + competition_id + "/teams/" + team_id + "/practice-ice-prepurchase" : "/api/competitions/" + competition_id + "/practice-ice-prepurchase";
        return _services_AbstractAPIService__WEBPACK_IMPORTED_MODULE_0__["AbstractAPIService"].fetchAndTransformResponse({
            url: url,
            /**
             * Validate that the response is present and contains the necessary properties
             */
            validateResponse: function (response) {
                var required_props = ['competition_summary', 'cart', 'competition_information', 'entity_credits', 'competition_schedule', 'entity_schedule', 'active_sales_window'];
                for (var i = 0; i < required_props.length; i++) {
                    var requiredProp = required_props[i];
                    if (!Object.prototype.hasOwnProperty.call(response, requiredProp)) {
                        console.error(requiredProp + " missing from response");
                        return false;
                    }
                }
                return true;
            },
            /**
             * Transform API data to App data
             */
            transformResponse: function (response) {
                return _transformers_CompetitionPortalApiTransformer__WEBPACK_IMPORTED_MODULE_1__["CompetitionPortalApiTransformer"].transformFetchPracticeIcePrePurchase(response);
            }
        });
    };
    /**
     * Fetch competition portal competition schedule page data
     */
    CompetitionPortalApiService.fetchCompetitionSchedule = function () {
        var competition_id = _CompetitionPortalAppService__WEBPACK_IMPORTED_MODULE_2__["CompetitionPortalAppService"].getActiveCompetitionPortalCompetitionId();
        var team_id = _CompetitionPortalAppService__WEBPACK_IMPORTED_MODULE_2__["CompetitionPortalAppService"].getActiveCompetitionPortalTeamId();
        var url = team_id ? "/api/competitions/" + competition_id + "/teams/" + team_id + "/competition-schedule" : "/api/competitions/" + competition_id + "/competition-schedule";
        return _services_AbstractAPIService__WEBPACK_IMPORTED_MODULE_0__["AbstractAPIService"].fetchAndTransformResponse({
            url: url,
            /**
             * Validate that the response is present and contains the necessary properties
             */
            validateResponse: function (response) {
                var required_props = ['competition_summary', 'competition_schedule'];
                for (var i = 0; i < required_props.length; i++) {
                    var requiredProp = required_props[i];
                    if (!Object.prototype.hasOwnProperty.call(response, requiredProp)) {
                        console.error(requiredProp + " missing from response");
                        return false;
                    }
                }
                return true;
            },
            /**
             * Transform API data to App data
             */
            transformResponse: function (response) {
                return _transformers_CompetitionPortalApiTransformer__WEBPACK_IMPORTED_MODULE_1__["CompetitionPortalApiTransformer"].transformFetchCompetitionSchedule(response);
            }
        });
    };
    /**
     * Fetch competition portal "My Skaters" page data
     */
    CompetitionPortalApiService.fetchMySkaters = function () {
        var competition_id = _CompetitionPortalAppService__WEBPACK_IMPORTED_MODULE_2__["CompetitionPortalAppService"].getActiveCompetitionPortalCompetitionId();
        var url = "/api/competitions/" + competition_id + "/coach-skaters";
        return this.fetchAndTransformResponse({
            url: url,
            /**
             * Transform API data to App Data
             */
            transformResponse: function (response) {
                return _transformers_CompetitionPortalApiTransformer__WEBPACK_IMPORTED_MODULE_1__["CompetitionPortalApiTransformer"].transformFetchMySkaters(response);
            },
            /**
             * Validate API response
             */
            validateResponse: function (response) {
                var required_props = ['competition_summary', 'skaters'];
                var valid = true;
                for (var i = 0; i < required_props.length; i++) {
                    var requiredProp = required_props[i];
                    if (!Object.prototype.hasOwnProperty.call(response, requiredProp)) {
                        console.error(requiredProp + " missing from response");
                        valid = false;
                    }
                }
                return valid;
            }
        });
    };
    /**
     * Fetch competition portal "My Coaches" page data
     */
    CompetitionPortalApiService.fetchMyCoaches = function () {
        var competition_id = _CompetitionPortalAppService__WEBPACK_IMPORTED_MODULE_2__["CompetitionPortalAppService"].getActiveCompetitionPortalCompetitionId();
        var url = "/api/competitions/" + competition_id + "/my-coaches";
        return this.fetchAndTransformResponse({
            url: url,
            /**
             * Transform API data to App Data
             */
            transformResponse: function (response) {
                return _transformers_CompetitionPortalApiTransformer__WEBPACK_IMPORTED_MODULE_1__["CompetitionPortalApiTransformer"].transformFetchMyCoaches(response);
            },
            /**
             * Validate API response
             */
            validateResponse: function (response) {
                var required_props = ['competition_summary', 'event_categories'];
                var valid = true;
                for (var i = 0; i < required_props.length; i++) {
                    var requiredProp = required_props[i];
                    if (!Object.prototype.hasOwnProperty.call(response, requiredProp)) {
                        console.error(requiredProp + " missing from response");
                        valid = false;
                    }
                }
                return valid;
            }
        });
    };
    /**
     * Fetch competition portal "My Schedule (Coach)" page data
     */
    CompetitionPortalApiService.fetchMyScheduleCoach = function () {
        var competition_id = _CompetitionPortalAppService__WEBPACK_IMPORTED_MODULE_2__["CompetitionPortalAppService"].getActiveCompetitionPortalCompetitionId();
        var url = "/api/competitions/" + competition_id + "/my-schedule/coach";
        return this.fetchAndTransformResponse({
            url: url,
            /**
             * Transform API data to App Data
             */
            transformResponse: function (response) {
                return _transformers_CompetitionPortalApiTransformer__WEBPACK_IMPORTED_MODULE_1__["CompetitionPortalApiTransformer"].transformFetchMyScheduleCoach(response);
            },
            /**
             * Validate API response
             */
            validateResponse: function (response) {
                var required_props = ['competition_summary', 'schedule_available'];
                var valid = true;
                for (var i = 0; i < required_props.length; i++) {
                    var requiredProp = required_props[i];
                    if (!Object.prototype.hasOwnProperty.call(response, requiredProp)) {
                        console.error(requiredProp + " missing from response");
                        valid = false;
                    }
                }
                if (response.schedule_available && !response.coach_schedule) {
                    console.error('Schedule available but coach schedule missing from response');
                    valid = false;
                }
                return valid;
            }
        });
    };
    /**
     * Fetch competition portal "My Schedule (Skater)" page data
     */
    CompetitionPortalApiService.fetchMyScheduleSkater = function () {
        var competition_id = _CompetitionPortalAppService__WEBPACK_IMPORTED_MODULE_2__["CompetitionPortalAppService"].getActiveCompetitionPortalCompetitionId();
        var url = "/api/competitions/" + competition_id + "/my-schedule";
        return this.fetchAndTransformResponse({
            url: url,
            /**
             * Transform API data to App Data
             */
            transformResponse: function (response) {
                return _transformers_CompetitionPortalApiTransformer__WEBPACK_IMPORTED_MODULE_1__["CompetitionPortalApiTransformer"].transformFetchMyScheduleSkater(response);
            },
            /**
             * Validate API response
             */
            validateResponse: function (response) {
                var required_props = ['competition_summary', 'schedule_available'];
                var valid = true;
                for (var i = 0; i < required_props.length; i++) {
                    var requiredProp = required_props[i];
                    if (!Object.prototype.hasOwnProperty.call(response, requiredProp)) {
                        console.error(requiredProp + " missing from response");
                        valid = false;
                    }
                }
                if (response.schedule_available && !response.skater_schedule) {
                    console.error('Schedule available but skater schedule missing from response');
                    valid = false;
                }
                return valid;
            }
        });
    };
    CompetitionPortalApiService.fetchCoachCompetitionSchedule = function () {
        var competition_id = _CompetitionPortalAppService__WEBPACK_IMPORTED_MODULE_2__["CompetitionPortalAppService"].getActiveCompetitionPortalCompetitionId();
        var url = "/api/competitions/" + competition_id + "/coach-competition-schedule";
        return this.fetchAndTransformResponse({
            url: url,
            /**
             * Transform API data to App Data
             */
            transformResponse: function (response) {
                return _transformers_CompetitionPortalApiTransformer__WEBPACK_IMPORTED_MODULE_1__["CompetitionPortalApiTransformer"].transformFetchCoachCompetitionSchedule(response);
            },
            /**
             * Validate API response
             */
            validateResponse: function (response) {
                var required_props = ['competition_summary', 'competition_information', 'coached_skater_schedule', 'competition_schedule'];
                var valid = true;
                for (var i = 0; i < required_props.length; i++) {
                    var requiredProp = required_props[i];
                    if (!Object.prototype.hasOwnProperty.call(response, requiredProp)) {
                        console.error(requiredProp + " missing from response");
                        valid = false;
                    }
                }
                return valid;
            }
        });
    };
    return CompetitionPortalApiService;
}(_services_AbstractAPIService__WEBPACK_IMPORTED_MODULE_0__["AbstractAPIService"]));



/***/ }),

/***/ "./src/js/CompetitionPortal/_services/CompetitionPortalAppService.ts":
/*!***************************************************************************!*\
  !*** ./src/js/CompetitionPortal/_services/CompetitionPortalAppService.ts ***!
  \***************************************************************************/
/*! exports provided: CompetitionPortalAppService */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CompetitionPortalAppService", function() { return CompetitionPortalAppService; });
/* harmony import */ var _config_AppConfig__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../config/AppConfig */ "./src/js/config/AppConfig.ts");
/* harmony import */ var _services_AbstractAPIService__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../services/AbstractAPIService */ "./src/js/services/AbstractAPIService.ts");


var CompetitionPortalAppService = /** @class */ (function () {
    function CompetitionPortalAppService() {
    }
    /**
     * Get the active competition portal competition ID from cookie
     */
    CompetitionPortalAppService.getActiveCompetitionPortalCompetitionId = function () {
        return parseInt(_services_AbstractAPIService__WEBPACK_IMPORTED_MODULE_1__["AbstractAPIService"].getValueFromCookie(_config_AppConfig__WEBPACK_IMPORTED_MODULE_0__["COMPETITION_PORTAL_ACTIVE_COMPETITION_ID_COOKIE_NAME"], 'active competition id'));
    };
    /**
     * Get the active competition portal competition ID from cookie
     */
    CompetitionPortalAppService.getActiveCompetitionPortalTeamId = function () {
        try {
            return parseInt(_services_AbstractAPIService__WEBPACK_IMPORTED_MODULE_1__["AbstractAPIService"].getValueFromCookie(_config_AppConfig__WEBPACK_IMPORTED_MODULE_0__["COMPETITION_PORTAL_ACTIVE_TEAM_ID_COOKIE_NAME"], 'active team id', true));
        }
        catch (e) {
            return null;
        }
    };
    return CompetitionPortalAppService;
}());



/***/ }),

/***/ "./src/js/CompetitionPortal/_services/index.ts":
/*!*****************************************************!*\
  !*** ./src/js/CompetitionPortal/_services/index.ts ***!
  \*****************************************************/
/*! exports provided: CompetitionPortalApiService, CompetitionPortalAppService */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _CompetitionPortalApiService__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CompetitionPortalApiService */ "./src/js/CompetitionPortal/_services/CompetitionPortalApiService.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CompetitionPortalApiService", function() { return _CompetitionPortalApiService__WEBPACK_IMPORTED_MODULE_0__["CompetitionPortalApiService"]; });

/* harmony import */ var _CompetitionPortalAppService__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./CompetitionPortalAppService */ "./src/js/CompetitionPortal/_services/CompetitionPortalAppService.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CompetitionPortalAppService", function() { return _CompetitionPortalAppService__WEBPACK_IMPORTED_MODULE_1__["CompetitionPortalAppService"]; });





/***/ }),

/***/ "./src/js/CompetitionPortal/_store/CompetitionPortalState.ts":
/*!*******************************************************************!*\
  !*** ./src/js/CompetitionPortal/_store/CompetitionPortalState.ts ***!
  \*******************************************************************/
/*! exports provided: State, CompetitionPortalState */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "State", function() { return State; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CompetitionPortalState", function() { return CompetitionPortalState; });
/* harmony import */ var _services__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_services */ "./src/js/CompetitionPortal/_services/index.ts");

var State = /** @class */ (function () {
    function State() {
        this.active_competition_summary = null;
        /**
         * Summary information about the active entity
         */
        this.active_entity_summary = null;
        /**
         * The competition documents for the current competition
         */
        this.competition_documents = {
            reference_documents: [],
            action_documents: []
        };
        /**
         * Competition contacts for the competition
         */
        this.competition_contacts = [];
        /**
         * Teams managed by the current user registered for the active competition
         */
        this.competition_managed_teams = [];
        /**
         * Information for the Competition Information page
         */
        this.competition_information = null;
        this.competition_selectable_entities = [];
        this.is_team_view = !!_services__WEBPACK_IMPORTED_MODULE_0__["CompetitionPortalAppService"].getActiveCompetitionPortalTeamId();
        this.multiple_competition_views_available = false;
    }
    return State;
}());

var actions = {
    fetchCoachCompetitionSchedule: function (context) {
        return new Promise(function (resolve, reject) {
            _services__WEBPACK_IMPORTED_MODULE_0__["CompetitionPortalApiService"].fetchCoachCompetitionSchedule()
                .then(function (response) {
                context.dispatch('setCompetitionPortalCore', response);
                var schedule_response = response.competition_schedule;
                if (schedule_response.schedule) {
                    context.commit('competitions/setCompetitionSchedule', {
                        result: schedule_response.schedule
                    }, { root: true });
                }
                context.commit('competitions/setCompetitionScheduleAvailableOverride', schedule_response.schedule_available, { root: true });
                context.commit('competitions/setCompetitionInformation', {
                    result: response.competition_information
                }, { root: true });
                context.commit('coach/setCompetitionSkaterSchedule', response.coached_skater_schedule, { root: true });
                resolve();
            })
                .catch(function () {
                reject();
            });
        });
    },
    /**
     * Fetch information for the Competition Portal "Competition Contacts" page
     */
    fetchCompetitionContacts: function (context) {
        return new Promise(function (resolve, reject) {
            _services__WEBPACK_IMPORTED_MODULE_0__["CompetitionPortalApiService"].fetchCompetitionContacts()
                .then(function (response) {
                context.dispatch('setCompetitionPortalCore', response);
                context.commit('setCompetitionContacts', response.contacts);
                resolve();
            })
                .catch(function () {
                reject();
            });
        });
    },
    /**
     * Fetch information for the Competition Portal Competition Information page
     */
    fetchCompetitionInformation: function (context) {
        return new Promise(function (resolve, reject) {
            _services__WEBPACK_IMPORTED_MODULE_0__["CompetitionPortalApiService"].fetchCompetitionInformation()
                .then(function (response) {
                context.dispatch('setCompetitionPortalCore', response);
                context.commit('setCompetitionInformation', response.competition_information);
                resolve();
            })
                .catch(function () {
                reject();
            });
        });
    },
    /**
     * Fetch information for the Competition Portal Main page
     */
    fetchCompetitionMain: function (context) {
        return new Promise(function (resolve, reject) {
            _services__WEBPACK_IMPORTED_MODULE_0__["CompetitionPortalApiService"].fetchCompetitionMain()
                .then(function (response) {
                context.commit('competitions/setViewCompetitionCompetition', response.view_competition, { root: true });
                context.commit('setMultipleViewsAvailable', response.user_manages_competition_eligible_teams);
                context.dispatch('setCompetitionPortalCore', response);
                resolve();
            })
                .catch(function () {
                reject();
            });
        });
    },
    /**
     * Fetch information needed by the Competition Documents page
     */
    fetchCompetitionDocuments: function (context) {
        return new Promise(function (resolve, reject) {
            _services__WEBPACK_IMPORTED_MODULE_0__["CompetitionPortalApiService"].fetchCompetitionDocuments()
                .then(function (response) {
                context.commit('setCompetitionDocuments', response.competition_documents);
                context.dispatch('setCompetitionPortalCore', response);
                resolve();
            })
                .catch(function () {
                reject();
            });
        });
    },
    /**
     * Fetch information for the Competition Entity Select page
     */
    fetchCompetitionEntitySelect: function (context) {
        return new Promise(function (resolve, reject) {
            _services__WEBPACK_IMPORTED_MODULE_0__["CompetitionPortalApiService"].fetchEntitySelect()
                .then(function (response) {
                context.commit('setCompetitionSelectableEntities', response.entities);
                context.dispatch('setCompetitionPortalCore', response);
                resolve();
            })
                .catch(function () {
                reject();
            });
        });
    },
    /**
     * Fetch information needed by the Competition Roster page
     */
    fetchCompetitionRoster: function (context) {
        return new Promise(function (resolve, reject) {
            context.dispatch('roster/fetch')
                .then(function () {
                resolve();
            })
                .catch(function () {
                reject();
            });
        });
    },
    /**
     * Fetch information for the Competition Schedule page
     */
    fetchCompetitionSchedule: function (context) {
        return new Promise(function (resolve, reject) {
            _services__WEBPACK_IMPORTED_MODULE_0__["CompetitionPortalApiService"].fetchCompetitionSchedule()
                .then(function (response) {
                context.dispatch('setCompetitionPortalCore', response);
                var schedule_response = response.competition_schedule;
                if (schedule_response.schedule) {
                    context.commit('competitions/setCompetitionSchedule', {
                        result: schedule_response.schedule
                    }, { root: true });
                }
                context.commit('competitions/setCompetitionScheduleAvailableOverride', schedule_response.schedule_available, { root: true });
                resolve();
            })
                .catch(function () {
                reject();
            });
        });
    },
    /**
     * Fetch information needed by the Competition Team Personnel page
     */
    fetchCompetitionTeamPersonnel: function (context) {
        return new Promise(function (resolve, reject) {
            context.dispatch('team_personnel/fetch')
                .then(function () {
                resolve();
            })
                .catch(function () {
                reject();
            });
        });
    },
    /**
     * Fetch information for the Music & PPC page
     */
    fetchMusicAndPpc: function (context) {
        return new Promise(function (resolve, reject) {
            _services__WEBPACK_IMPORTED_MODULE_0__["CompetitionPortalApiService"].fetchMusicAndPpc()
                .then(function (response) {
                context.dispatch('setCompetitionPortalCore', response);
                context.commit('competitions/setCompetitionInformation', {
                    result: response.competition_information
                }, { root: true });
                context.commit('skater/setActiveSkatingEventSegments', response.entity_event_segments, { root: true });
                resolve(_services__WEBPACK_IMPORTED_MODULE_0__["CompetitionPortalAppService"].getActiveCompetitionPortalCompetitionId());
            })
                .catch(function () {
                reject();
            });
        });
    },
    /**
     * Fetch information needed by the My Coaches page
     */
    fetchMyCoaches: function (context) {
        return new Promise(function (resolve, reject) {
            _services__WEBPACK_IMPORTED_MODULE_0__["CompetitionPortalApiService"].fetchMyCoaches()
                .then(function (response) {
                context.dispatch('setCompetitionPortalCore', response);
                context.commit('skater/setCompetitionEventCoaches', response.event_categories, { root: true });
                resolve();
            })
                .catch(function () {
                reject();
            });
        });
    },
    /**
     * Fetch information needed by the My Schedule page
     */
    fetchMySchedule: function (context) {
        return new Promise(function (resolve, reject) {
            _services__WEBPACK_IMPORTED_MODULE_0__["CompetitionPortalApiService"].fetchMyScheduleSkater()
                .then(function (response) {
                context.dispatch('setCompetitionPortalCore', response);
                if (response.skater_schedule) {
                    context.commit('skater/setActiveSchedule', response.skater_schedule, { root: true });
                }
                context.commit('competitions/setCompetitionMyScheduleAvailableOverride', response.schedule_available, { root: true });
                resolve();
            })
                .catch(function () {
                reject();
            });
        });
    },
    /**
     * Fetch information needed by the My Schedule (Coach Version) page
     */
    fetchMyScheduleCoach: function (context) {
        return new Promise(function (resolve, reject) {
            _services__WEBPACK_IMPORTED_MODULE_0__["CompetitionPortalApiService"].fetchMyScheduleCoach()
                .then(function (response) {
                context.dispatch('setCompetitionPortalCore', response);
                if (response.coach_schedule) {
                    context.commit('coach/setCompetitionSkaterSchedule', response.coach_schedule, { root: true });
                }
                context.commit('competitions/setCompetitionMyScheduleAvailableOverride', response.schedule_available, { root: true });
                resolve();
            })
                .catch(function () {
                reject();
            });
        });
    },
    /**
     * Fetch information needed by the My Skaters page
     */
    fetchMySkaters: function (context) {
        return new Promise(function (resolve, reject) {
            _services__WEBPACK_IMPORTED_MODULE_0__["CompetitionPortalApiService"].fetchMySkaters()
                .then(function (response) {
                context.dispatch('setCompetitionPortalCore', response);
                context.commit('coach/setCompetitionSkaters', response.coach_skaters, { root: true });
                resolve();
            })
                .catch(function () {
                reject();
            });
        });
    },
    /**
     * Fetch information needed by the My Teams page
     */
    fetchMyTeams: function (context) {
        return new Promise(function (resolve, reject) {
            _services__WEBPACK_IMPORTED_MODULE_0__["CompetitionPortalApiService"].fetchMyTeams()
                .then(function (response) {
                context.dispatch('setCompetitionPortalCore', response);
                context.commit('setCompetitionManagedTeams', response.teams);
                resolve();
            })
                .catch(function () {
                reject();
            });
        });
    },
    /**
     * Set core competition portal properties from a FetchCompetitionPortalCoreServiceResponse
     */
    setCompetitionPortalCore: function (_a, payload) {
        var commit = _a.commit;
        commit('setActiveCompetitionSummary', payload.competition_summary);
        commit('app/setActivePageBackLink', payload.back_link, { root: true });
        commit('setActiveEntitySummary', payload.entity_summary);
    },
    /**
     * Toggle the completion state on an action competition document
     */
    toggleActionCompetitionDocument: function (context, document) {
        return new Promise(function (resolve, reject) {
            _services__WEBPACK_IMPORTED_MODULE_0__["CompetitionPortalApiService"].updateCompetitionDocumentCompletion(document)
                .then(function () {
                context.commit('toggleCompetitionDocument', document);
                resolve();
            })
                .catch(function (e) {
                reject(e);
            });
        });
    }
};
var getters = {
    /**
     * The binding for the competition portal heading based on current state
     */
    competition_portal_heading_binding: function (state) {
        var active_competition_summary = state.active_competition_summary;
        if (active_competition_summary) {
            var binding = {
                competition: active_competition_summary
            };
            if (state.active_entity_summary) {
                binding.entity = state.active_entity_summary;
            }
            return binding;
        }
        return null;
    }
};
var mutations = {
    /**
     * Set the active competition summary in state
     */
    setActiveCompetitionSummary: function (state, payload) {
        state.active_competition_summary = payload;
    },
    /**
     * Set the active entity summary in state
     */
    setActiveEntitySummary: function (state, payload) {
        state.active_entity_summary = payload;
    },
    /**
     * Set the current competition documents in state
     */
    setCompetitionDocuments: function (state, payload) {
        state.competition_documents = payload;
    },
    /**
     * Set the competition contacts in state
     */
    setCompetitionContacts: function (state, competition_contacts) {
        state.competition_contacts = competition_contacts;
    },
    /**
     * Set competition information in state
     */
    setCompetitionInformation: function (state, payload) {
        state.competition_information = payload;
    },
    /**
     * Set the list of user managed teams for the current competition in state
     */
    setCompetitionManagedTeams: function (state, payload) {
        state.competition_managed_teams = payload;
    },
    /**
     * Toggle the completion status on a competition document
     */
    toggleCompetitionDocument: function (state, document) {
        document.is_complete = !document.is_complete;
    },
    /**
     * Set selectable entities for the competition in state
     */
    setCompetitionSelectableEntities: function (state, payload) {
        state.competition_selectable_entities = payload;
    },
    /**
     * Set whether multiple competition main views are available
     */
    setMultipleViewsAvailable: function (state, payload) {
        state.multiple_competition_views_available = payload;
    }
};
var CompetitionPortalState = {
    namespaced: true,
    state: new State(),
    actions: actions,
    getters: getters,
    mutations: mutations
};


/***/ }),

/***/ "./src/js/CompetitionPortal/_transformers/CompetitionPortalApiTransformer.ts":
/*!***********************************************************************************!*\
  !*** ./src/js/CompetitionPortal/_transformers/CompetitionPortalApiTransformer.ts ***!
  \***********************************************************************************/
/*! exports provided: CompetitionPortalApiTransformer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CompetitionPortalApiTransformer", function() { return CompetitionPortalApiTransformer; });
/* harmony import */ var _Teams_TeamsApiTransformer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Teams/TeamsApiTransformer */ "./src/js/Teams/TeamsApiTransformer.ts");
/* harmony import */ var _models__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../_models */ "./src/js/CompetitionPortal/_models/index.ts");
/* harmony import */ var _adaptors_APIAdaptors_AppAPIAdaptor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../adaptors/APIAdaptors/AppAPIAdaptor */ "./src/js/adaptors/APIAdaptors/AppAPIAdaptor.ts");
/* harmony import */ var _pages_ViewCompetition_ViewCompetitionTransformer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../pages/ViewCompetition/ViewCompetitionTransformer */ "./src/js/pages/ViewCompetition/ViewCompetitionTransformer.ts");
/* harmony import */ var _adaptors_CompetitionContactDataAdaptor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../adaptors/CompetitionContactDataAdaptor */ "./src/js/adaptors/CompetitionContactDataAdaptor.ts");
/* harmony import */ var _adaptors_SkaterSkatingEventSegmentAdaptor__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../adaptors/SkaterSkatingEventSegmentAdaptor */ "./src/js/adaptors/SkaterSkatingEventSegmentAdaptor.ts");
/* harmony import */ var _adaptors_CompetitionInformationDataAdaptor__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../adaptors/CompetitionInformationDataAdaptor */ "./src/js/adaptors/CompetitionInformationDataAdaptor.ts");
/* harmony import */ var _adaptors_PracticeIceSchedulesDataAdaptor__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../adaptors/PracticeIceSchedulesDataAdaptor */ "./src/js/adaptors/PracticeIceSchedulesDataAdaptor.ts");
/* harmony import */ var _adaptors_CartDataAdaptor__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../adaptors/CartDataAdaptor */ "./src/js/adaptors/CartDataAdaptor.ts");
/* harmony import */ var _adaptors_SkaterCreditDataAdaptor__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../adaptors/SkaterCreditDataAdaptor */ "./src/js/adaptors/SkaterCreditDataAdaptor.ts");
/* harmony import */ var _adaptors_CompetitionScheduleDataAdaptor__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../adaptors/CompetitionScheduleDataAdaptor */ "./src/js/adaptors/CompetitionScheduleDataAdaptor.ts");
/* harmony import */ var _adaptors_SessionDataAdaptor__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../adaptors/SessionDataAdaptor */ "./src/js/adaptors/SessionDataAdaptor.ts");
/* harmony import */ var _adaptors_SkaterEventDataAdaptor__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../adaptors/SkaterEventDataAdaptor */ "./src/js/adaptors/SkaterEventDataAdaptor.ts");
/* harmony import */ var _adaptors_CoachSkatersAdaptor__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../adaptors/CoachSkatersAdaptor */ "./src/js/adaptors/CoachSkatersAdaptor.ts");
/* harmony import */ var _models_Collections_SkaterCoachedEventCollection__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../../models/Collections/SkaterCoachedEventCollection */ "./src/js/models/Collections/SkaterCoachedEventCollection.ts");
/* harmony import */ var _adaptors_CoachSkaterScheduleAdaptor__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../../adaptors/CoachSkaterScheduleAdaptor */ "./src/js/adaptors/CoachSkaterScheduleAdaptor.ts");
var __assign = (undefined && undefined.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
















var CompetitionPortalApiTransformer = /** @class */ (function () {
    function CompetitionPortalApiTransformer() {
    }
    CompetitionPortalApiTransformer.transformFetchMyTeams = function (response) {
        return __assign({}, this.transformFetchCompetitionPortalCore(response), { teams: _Teams_TeamsApiTransformer__WEBPACK_IMPORTED_MODULE_0__["TeamsApiTransformer"].transformManagedTeams(response.teams) });
    };
    CompetitionPortalApiTransformer.transformCompetitionSummary = function (data) {
        return new _models__WEBPACK_IMPORTED_MODULE_1__["ActiveCompetitionSummary"](__assign({}, data, { directions: data.directions || [], announcement_url: data.announcement_url || null, website_url: data.website_url || null }));
    };
    CompetitionPortalApiTransformer.transformFetchCompetitionDocuments = function (response) {
        return __assign({}, this.transformFetchCompetitionPortalCore(response), { competition_documents: __assign({}, response.competition_documents) });
    };
    CompetitionPortalApiTransformer.transformEntitySummary = function (entity) {
        if (!entity) {
            return null;
        }
        var params = {};
        if (entity.name) {
            params.name = entity.name;
        }
        if (entity.compliance) {
            var message = _adaptors_APIAdaptors_AppAPIAdaptor__WEBPACK_IMPORTED_MODULE_2__["AppAPIAdaptor"].adaptStatusMessageData(entity.compliance.status);
            var supporting_description_data = entity.compliance.supporting_description;
            params.compliance = {
                status_description: message.text,
                status_key: message.type_key,
                link: entity.compliance.link
            };
            if (supporting_description_data) {
                params.compliance.supporting_description = _adaptors_APIAdaptors_AppAPIAdaptor__WEBPACK_IMPORTED_MODULE_2__["AppAPIAdaptor"].adaptStatusMessageData(supporting_description_data);
            }
            if (entity.compliance.role_items) {
                params.compliance.role_items = entity.compliance.role_items.slice();
            }
        }
        return new _models__WEBPACK_IMPORTED_MODULE_1__["ActiveEntitySummary"](params);
    };
    /**
     * Transform core Competition Portal information from a page fetch response
     */
    CompetitionPortalApiTransformer.transformFetchCompetitionPortalCore = function (response) {
        return {
            competition_summary: this.transformCompetitionSummary(response.competition_summary),
            back_link: response.back_link || null,
            entity_summary: this.transformEntitySummary(response.entity_summary)
        };
    };
    CompetitionPortalApiTransformer.transformFetchEntitySelect = function (response) {
        return __assign({}, this.transformFetchCompetitionPortalCore(response), { entities: response.entities.map(function (entity_data) {
                return new _models__WEBPACK_IMPORTED_MODULE_1__["CompetitionSelectableEntity"](entity_data);
            }) });
    };
    CompetitionPortalApiTransformer.transformFetchCompetitionMain = function (response) {
        var competition_data = response.competition;
        return {
            competition_summary: this.transformCompetitionSummary({
                id: competition_data.id,
                announcement_url: competition_data.announcement_url,
                directions: competition_data.directions,
                end_date_pretty: competition_data.end_date_pretty,
                icon: competition_data.icon,
                name: competition_data.name,
                start_date_pretty: competition_data.start_date_pretty,
                website_url: competition_data.website_url
            }),
            back_link: response.back_link || null,
            entity_summary: this.transformEntitySummary(response.entity_summary),
            view_competition: _pages_ViewCompetition_ViewCompetitionTransformer__WEBPACK_IMPORTED_MODULE_3__["ViewCompetitionTransformer"].transformFetchViewCompetitionCompetition(competition_data),
            user_manages_competition_eligible_teams: response.user_manages_competition_eligible_teams
        };
    };
    CompetitionPortalApiTransformer.transformFetchCompetitionContacts = function (response) {
        return __assign({}, this.transformFetchCompetitionPortalCore(response), { contacts: _adaptors_CompetitionContactDataAdaptor__WEBPACK_IMPORTED_MODULE_4__["CompetitionContactDataAdaptor"].adaptArray(response.contacts) });
    };
    CompetitionPortalApiTransformer.transformFetchCompetitionInformation = function (response) {
        return __assign({}, this.transformFetchCompetitionPortalCore(response), { competition_information: this.transformCompetitionInformation(response) });
    };
    CompetitionPortalApiTransformer.transformCompetitionInformation = function (response) {
        var information_data = response.competition_information;
        return new _models__WEBPACK_IMPORTED_MODULE_1__["CompetitionPortalCompetitionInformation"]({
            registered_events: information_data.registered_events,
            practice_ice: {
                instructions: information_data.practice_ice.instructions,
                terminology: information_data.practice_ice.terminology,
                not_offered: information_data.practice_ice.not_offered,
                pricing_message: information_data.practice_ice.pricing_message || null,
                event_pricing: information_data.practice_ice.event_pricing || [],
                sales_windows: information_data.practice_ice.sales_windows || []
            }
        });
    };
    CompetitionPortalApiTransformer.transformFetchMusicAndPpc = function (response) {
        return __assign({}, this.transformFetchCompetitionPortalCore(response), { competition_information: _adaptors_CompetitionInformationDataAdaptor__WEBPACK_IMPORTED_MODULE_6__["CompetitionInformationDataAdaptor"].adapt(response.competition_information), entity_event_segments: _adaptors_SkaterSkatingEventSegmentAdaptor__WEBPACK_IMPORTED_MODULE_5__["SkaterSkatingEventSegmentAdaptor"].adaptArray(response.entity_event_segments) });
    };
    CompetitionPortalApiTransformer.transformFetchPracticeIceSchedule = function (response) {
        return __assign({}, this.transformFetchCompetitionPortalCore(response), _adaptors_PracticeIceSchedulesDataAdaptor__WEBPACK_IMPORTED_MODULE_7__["PracticeIceSchedulesDataAdaptor"].adapt(response), { cart: _adaptors_CartDataAdaptor__WEBPACK_IMPORTED_MODULE_8__["CartDataAdaptor"].adapt(response.cart), competition_information: _adaptors_CompetitionInformationDataAdaptor__WEBPACK_IMPORTED_MODULE_6__["CompetitionInformationDataAdaptor"].adapt(response.competition_information), active_sales_window: response.active_sales_window, entity_credits: _adaptors_SkaterCreditDataAdaptor__WEBPACK_IMPORTED_MODULE_9__["SkaterCreditDataAdaptor"].adaptCompetitionCredits(response.entity_credits) });
    };
    CompetitionPortalApiTransformer.transformFetchPracticeIcePrePurchase = function (response) {
        return __assign({}, this.transformFetchCompetitionPortalCore(response), { cart: _adaptors_CartDataAdaptor__WEBPACK_IMPORTED_MODULE_8__["CartDataAdaptor"].adapt(response.cart), competition_information: _adaptors_CompetitionInformationDataAdaptor__WEBPACK_IMPORTED_MODULE_6__["CompetitionInformationDataAdaptor"].adapt(response.competition_information), entity_credits: _adaptors_SkaterCreditDataAdaptor__WEBPACK_IMPORTED_MODULE_9__["SkaterCreditDataAdaptor"].adaptCompetitionCredits(response.entity_credits), competition_schedule: _adaptors_CompetitionScheduleDataAdaptor__WEBPACK_IMPORTED_MODULE_10__["CompetitionScheduleDataAdaptor"].adapt(response.competition_schedule), entity_schedule: {
                sessions: _adaptors_SessionDataAdaptor__WEBPACK_IMPORTED_MODULE_11__["SessionDataAdaptor"].adaptScheduledArray(response.entity_schedule.sessions),
                events: _adaptors_SkaterEventDataAdaptor__WEBPACK_IMPORTED_MODULE_12__["SkaterEventDataAdaptor"].adaptArray(response.entity_schedule.events)
            }, active_sales_window: response.active_sales_window });
    };
    CompetitionPortalApiTransformer.transformFetchCompetitionSchedule = function (response) {
        return __assign({}, this.transformFetchCompetitionPortalCore(response), { competition_schedule: this.transformCompetitionSchedule(response.competition_schedule) });
    };
    CompetitionPortalApiTransformer.transformFetchMySkaters = function (response) {
        return __assign({}, this.transformFetchCompetitionPortalCore(response), { coach_skaters: _adaptors_CoachSkatersAdaptor__WEBPACK_IMPORTED_MODULE_13__["CoachSkatersAdaptor"].adaptArray(response.skaters) });
    };
    CompetitionPortalApiTransformer.transformFetchMyCoaches = function (response) {
        return __assign({}, this.transformFetchCompetitionPortalCore(response), { event_categories: new _models_Collections_SkaterCoachedEventCollection__WEBPACK_IMPORTED_MODULE_14__["SkaterCoachedEventCategoryCollection"](_adaptors_SkaterEventDataAdaptor__WEBPACK_IMPORTED_MODULE_12__["SkaterEventDataAdaptor"].adaptCoachedEventArray(response.event_categories)) });
    };
    CompetitionPortalApiTransformer.transformFetchMyScheduleCoach = function (response) {
        var result = __assign({}, this.transformFetchCompetitionPortalCore(response), { schedule_available: response.schedule_available });
        if (response.coach_schedule) {
            result.coach_schedule = _adaptors_CoachSkaterScheduleAdaptor__WEBPACK_IMPORTED_MODULE_15__["CoachSkaterScheduleAdaptor"].adapt(response.coach_schedule.sessions, response.coach_schedule.skater_session_map);
        }
        return result;
    };
    CompetitionPortalApiTransformer.transformFetchMyScheduleSkater = function (response) {
        var result = __assign({}, this.transformFetchCompetitionPortalCore(response), { schedule_available: response.schedule_available });
        if (response.skater_schedule) {
            result.skater_schedule = {
                sessions: _adaptors_SessionDataAdaptor__WEBPACK_IMPORTED_MODULE_11__["SessionDataAdaptor"].adaptScheduledArray(response.skater_schedule.sessions),
                events: _adaptors_SkaterEventDataAdaptor__WEBPACK_IMPORTED_MODULE_12__["SkaterEventDataAdaptor"].adaptArray(response.skater_schedule.events)
            };
        }
        return result;
    };
    CompetitionPortalApiTransformer.transformFetchCoachCompetitionSchedule = function (response) {
        return __assign({}, this.transformFetchCompetitionPortalCore(response), { competition_schedule: this.transformCompetitionSchedule(response.competition_schedule), competition_information: _adaptors_CompetitionInformationDataAdaptor__WEBPACK_IMPORTED_MODULE_6__["CompetitionInformationDataAdaptor"].adapt(response.competition_information), coached_skater_schedule: _adaptors_CoachSkaterScheduleAdaptor__WEBPACK_IMPORTED_MODULE_15__["CoachSkaterScheduleAdaptor"].adapt(response.coached_skater_schedule.sessions, response.coached_skater_schedule.skater_session_map) });
    };
    CompetitionPortalApiTransformer.transformCompetitionSchedule = function (response) {
        if (response.schedule_unavailable) {
            return {
                schedule_available: false
            };
        }
        return {
            schedule_available: true,
            schedule: _adaptors_CompetitionScheduleDataAdaptor__WEBPACK_IMPORTED_MODULE_10__["CompetitionScheduleDataAdaptor"].adapt(response)
        };
    };
    return CompetitionPortalApiTransformer;
}());



/***/ }),

/***/ "./src/js/CompetitionPortal/_transformers/DataNavigationLinkTransformer.ts":
/*!*********************************************************************************!*\
  !*** ./src/js/CompetitionPortal/_transformers/DataNavigationLinkTransformer.ts ***!
  \*********************************************************************************/
/*! exports provided: DataNavigationLinkTransformer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DataNavigationLinkTransformer", function() { return DataNavigationLinkTransformer; });
/* harmony import */ var _models__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_models */ "./src/js/CompetitionPortal/_models/index.ts");
/* harmony import */ var _adaptors_APIAdaptors_AppAPIAdaptor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../adaptors/APIAdaptors/AppAPIAdaptor */ "./src/js/adaptors/APIAdaptors/AppAPIAdaptor.ts");
var __assign = (undefined && undefined.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};


var DataNavigationLinkTransformer = /** @class */ (function () {
    function DataNavigationLinkTransformer() {
    }
    /**
     * Transform an entire DataNavigationLink from API navigation_link_data to App model
     */
    DataNavigationLinkTransformer.transformDataNavigationLink = function (navigation_link_data) {
        return new _models__WEBPACK_IMPORTED_MODULE_0__["DataNavigationLink"](__assign({}, this.transformCore(navigation_link_data), this.transformOptionalParams(navigation_link_data)));
    };
    /**
     * Transform core information required for all items
     */
    DataNavigationLinkTransformer.transformCore = function (navigation_link_data) {
        return {
            label: navigation_link_data.label,
            url: navigation_link_data.url,
            is_disabled: !!navigation_link_data.is_disabled
        };
    };
    /**
     * Transform optional information that may be present on items
     */
    DataNavigationLinkTransformer.transformOptionalParams = function (navigation_link_data) {
        var result = {};
        var supporting_data = this.transformData(navigation_link_data.data);
        if (supporting_data) {
            result.data = supporting_data;
        }
        if (Object.prototype.hasOwnProperty.call(navigation_link_data, 'is_complete')) {
            result.is_complete = navigation_link_data.is_complete;
        }
        return result;
    };
    /**
     * Transform the data/content set within a link
     */
    DataNavigationLinkTransformer.transformData = function (data) {
        var _this = this;
        if (!data || !data.length) {
            return null;
        }
        return data.map(function (data_item) {
            return _this.transformDatum(data_item);
        });
    };
    /**
     * Transform an individual data/content item within the link
     */
    DataNavigationLinkTransformer.transformDatum = function (data_item) {
        var result = {
            content: this.transformDatumContent(data_item.content)
        };
        if (data_item.icon) {
            result.icon = data_item.icon;
        }
        if (data_item.status_type) {
            result.status_type = data_item.status_type || 'default';
        }
        return result;
    };
    /**
     * Transform the content property within an individual data/content item
     */
    DataNavigationLinkTransformer.transformDatumContent = function (data) {
        if (typeof data === 'string') {
            return data;
        }
        return data.map(function (item) {
            return _adaptors_APIAdaptors_AppAPIAdaptor__WEBPACK_IMPORTED_MODULE_1__["AppAPIAdaptor"].adaptStatusMessageData(item);
        });
    };
    return DataNavigationLinkTransformer;
}());



/***/ }),

/***/ "./src/js/Teams/TeamsApiService.ts":
/*!*****************************************!*\
  !*** ./src/js/Teams/TeamsApiService.ts ***!
  \*****************************************/
/*! exports provided: TeamsApiService */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TeamsApiService", function() { return TeamsApiService; });
/* harmony import */ var _services_AbstractAPIService__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../services/AbstractAPIService */ "./src/js/services/AbstractAPIService.ts");
/* harmony import */ var _TeamsApiTransformer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./TeamsApiTransformer */ "./src/js/Teams/TeamsApiTransformer.ts");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();


var TeamsApiService = /** @class */ (function (_super) {
    __extends(TeamsApiService, _super);
    function TeamsApiService() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Fetch the teams managed by the active user
     */
    TeamsApiService.fetchManagedTeams = function () {
        return this.fetchAndTransformResponse({
            /**
             * Transform API data to app data
             */
            transformResponse: function (response) {
                return _TeamsApiTransformer__WEBPACK_IMPORTED_MODULE_1__["TeamsApiTransformer"].transformFetchManagedTeams(response);
            },
            url: '/api/user/managed-teams',
            /**
             * Validate API response
             */
            validateResponse: function (response) {
                if (!response.teams) {
                    console.error('teams not provided in response');
                    return false;
                }
                if (!response.selection_links) {
                    console.error('selection links not provided in response');
                    return false;
                }
                return true;
            }
        });
    };
    /**
     * Fetch the competitions the active user's managed teams are registered for
     */
    TeamsApiService.fetchManagedTeamCompetitions = function () {
        return this.fetchAndTransformResponse({
            /**
             * Transform API data to app data
             */
            transformResponse: function (response) {
                return _TeamsApiTransformer__WEBPACK_IMPORTED_MODULE_1__["TeamsApiTransformer"].transformFetchManagedTeamCompetitions(response);
            },
            url: '/api/user/managed-teams/competitions',
            /**
             * Validate API response
             */
            validateResponse: function (response) {
                if (!response.competitions) {
                    console.error('competitions not provided in response');
                    return false;
                }
                return true;
            }
        });
    };
    return TeamsApiService;
}(_services_AbstractAPIService__WEBPACK_IMPORTED_MODULE_0__["AbstractAPIService"]));



/***/ }),

/***/ "./src/js/Teams/TeamsApiTransformer.ts":
/*!*********************************************!*\
  !*** ./src/js/Teams/TeamsApiTransformer.ts ***!
  \*********************************************/
/*! exports provided: TeamsApiTransformer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TeamsApiTransformer", function() { return TeamsApiTransformer; });
/* harmony import */ var _models_ManagedTeam__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_models/ManagedTeam */ "./src/js/Teams/_models/ManagedTeam.ts");
/* harmony import */ var _models__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_models */ "./src/js/Teams/_models/index.ts");
var __assign = (undefined && undefined.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};


var TeamsApiTransformer = /** @class */ (function () {
    function TeamsApiTransformer() {
    }
    TeamsApiTransformer.transformFetchManagedTeams = function (data) {
        return {
            teams: TeamsApiTransformer.transformManagedTeams(data.teams),
            selection_links: __assign({}, data.selection_links)
        };
    };
    TeamsApiTransformer.transformManagedTeams = function (teams_data) {
        var _this = this;
        return teams_data.map(function (team_data) {
            return _this.transformManagedTeam(team_data);
        });
    };
    TeamsApiTransformer.transformManagedTeam = function (team_data) {
        var team = new _models_ManagedTeam__WEBPACK_IMPORTED_MODULE_0__["ManagedTeam"](team_data);
        if (team_data.links) {
            team.links = __assign({ competition_portal: '' }, team_data.links);
        }
        return team;
    };
    TeamsApiTransformer.transformFetchManagedTeamCompetitions = function (response) {
        return {
            competitions: response.competitions.map(function (competition_data) {
                return new _models__WEBPACK_IMPORTED_MODULE_1__["MyCompetitionsTeamsCompetition"](competition_data);
            }),
            back_link: response.back_link || null,
            links: response.links || null
        };
    };
    return TeamsApiTransformer;
}());



/***/ }),

/***/ "./src/js/Teams/TeamsState.ts":
/*!************************************!*\
  !*** ./src/js/Teams/TeamsState.ts ***!
  \************************************/
/*! exports provided: State, TeamsState */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "State", function() { return State; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TeamsState", function() { return TeamsState; });
/* harmony import */ var _TeamsApiService__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TeamsApiService */ "./src/js/Teams/TeamsApiService.ts");

var State = /** @class */ (function () {
    function State() {
        this.links = {};
        this.managed_team_competitions = [];
        this.managed_teams = [];
        this.selection_links = null;
    }
    return State;
}());

var actions = {
    /**
     * Fetch all the teams managed by the current user
     */
    fetchManagedTeams: function (context) {
        return new Promise(function (resolve, reject) {
            _TeamsApiService__WEBPACK_IMPORTED_MODULE_0__["TeamsApiService"].fetchManagedTeams()
                .then(function (response) {
                context.commit('setManagedTeams', response.teams);
                context.commit('setSelectionLinks', response.selection_links);
                resolve();
            })
                .catch(function (error_message) {
                reject(error_message);
            });
        });
    },
    /**
     * Fetch data for my competitions - teams page
     */
    fetchManagedTeamCompetitions: function (context) {
        return new Promise(function (resolve, reject) {
            _TeamsApiService__WEBPACK_IMPORTED_MODULE_0__["TeamsApiService"].fetchManagedTeamCompetitions()
                .then(function (response) {
                context.commit('setManagedTeamCompetitions', response.competitions);
                context.commit('setLinks', response.links || {});
                context.commit('app/setActivePageBackLink', response.back_link, { root: true });
                resolve();
            })
                .catch(function (error_message) {
                reject(error_message);
            });
        });
    }
};
var getters = {};
var mutations = {
    /**
     * Set link set in state
     */
    setLinks: function (state, payload) {
        state.links = payload;
    },
    /**
     * Set user managed teams in state
     */
    setManagedTeams: function (state, payload) {
        state.managed_teams = payload;
    },
    /**
     * Set user managed teams' competitions in state
     */
    setManagedTeamCompetitions: function (state, payload) {
        state.managed_team_competitions = payload;
    },
    /**
     * Set selection links in state
     */
    setSelectionLinks: function (state, payload) {
        state.selection_links = payload;
    }
};
var TeamsState = {
    namespaced: true,
    state: new State(),
    actions: actions,
    getters: getters,
    mutations: mutations
};


/***/ }),

/***/ "./src/js/Teams/_models/ManagedTeam.ts":
/*!*********************************************!*\
  !*** ./src/js/Teams/_models/ManagedTeam.ts ***!
  \*********************************************/
/*! exports provided: ManagedTeam */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ManagedTeam", function() { return ManagedTeam; });
var __assign = (undefined && undefined.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
var ManagedTeam = /** @class */ (function () {
    function ManagedTeam(params) {
        this._links = {
            competition_portal: ''
        };
        this.id = params.id;
        this.level = params.level;
        this.member_number = params.member_number;
        this.membership_status = __assign({}, params.membership_status);
        this.name = params.name;
        this.selection_information = __assign({}, params.selection_information);
    }
    Object.defineProperty(ManagedTeam.prototype, "links", {
        get: function () {
            return this._links;
        },
        set: function (value) {
            this._links = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ManagedTeam.prototype, "is_selectable", {
        get: function () {
            return this.selection_information.is_selectable;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ManagedTeam.prototype, "not_selectable_reason", {
        get: function () {
            if ('is_not_selectable_reason' in this.selection_information && this.selection_information.is_not_selectable_reason) {
                return this.selection_information.is_not_selectable_reason;
            }
            return null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ManagedTeam.prototype, "not_selectable_link", {
        get: function () {
            if ('not_selectable_link' in this.selection_information && this.selection_information.not_selectable_link) {
                return this.selection_information.not_selectable_link;
            }
            return null;
        },
        enumerable: true,
        configurable: true
    });
    return ManagedTeam;
}());



/***/ }),

/***/ "./src/js/Teams/_models/MyCompetitionsTeamsCompetition.ts":
/*!****************************************************************!*\
  !*** ./src/js/Teams/_models/MyCompetitionsTeamsCompetition.ts ***!
  \****************************************************************/
/*! exports provided: MyCompetitionsTeamsCompetition */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MyCompetitionsTeamsCompetition", function() { return MyCompetitionsTeamsCompetition; });
var MyCompetitionsTeamsCompetition = /** @class */ (function () {
    function MyCompetitionsTeamsCompetition(params) {
        this.end_date_pretty = params.end_date_pretty;
        this.icon = params.icon;
        this.id = params.id;
        this.links = params.links;
        this.name = params.name;
        this.start_date_pretty = params.start_date_pretty;
    }
    return MyCompetitionsTeamsCompetition;
}());



/***/ }),

/***/ "./src/js/Teams/_models/index.ts":
/*!***************************************!*\
  !*** ./src/js/Teams/_models/index.ts ***!
  \***************************************/
/*! exports provided: ManagedTeam, MyCompetitionsTeamsCompetition */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _ManagedTeam__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ManagedTeam */ "./src/js/Teams/_models/ManagedTeam.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ManagedTeam", function() { return _ManagedTeam__WEBPACK_IMPORTED_MODULE_0__["ManagedTeam"]; });

/* harmony import */ var _MyCompetitionsTeamsCompetition__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./MyCompetitionsTeamsCompetition */ "./src/js/Teams/_models/MyCompetitionsTeamsCompetition.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MyCompetitionsTeamsCompetition", function() { return _MyCompetitionsTeamsCompetition__WEBPACK_IMPORTED_MODULE_1__["MyCompetitionsTeamsCompetition"]; });





/***/ }),

/***/ "./src/js/adaptors/APIAdaptors/AppAPIAdaptor.ts":
/*!******************************************************!*\
  !*** ./src/js/adaptors/APIAdaptors/AppAPIAdaptor.ts ***!
  \******************************************************/
/*! exports provided: AppAPIAdaptor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AppAPIAdaptor", function() { return AppAPIAdaptor; });
var __assign = (undefined && undefined.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
var AppAPIAdaptor = /** @class */ (function () {
    function AppAPIAdaptor() {
    }
    AppAPIAdaptor.adaptSupportDocumentCategoryDataArrayToSupportDocumentCategoryArray = function (data) {
        return data.map(function (item) {
            return __assign({}, item);
        });
    };
    /**
     * Adapt a status message
     */
    AppAPIAdaptor.adaptStatusMessageData = function (data) {
        return {
            text: data.text,
            type_key: data.type_key || 'default'
        };
    };
    return AppAPIAdaptor;
}());



/***/ }),

/***/ "./src/js/adaptors/APIAdaptors/CartAPIAdaptor.ts":
/*!*******************************************************!*\
  !*** ./src/js/adaptors/APIAdaptors/CartAPIAdaptor.ts ***!
  \*******************************************************/
/*! exports provided: CartAPIAdaptor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CartAPIAdaptor", function() { return CartAPIAdaptor; });
var __assign = (undefined && undefined.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
/**
 * Adapt App Data for Consumption by API
 */
var CartAPIAdaptor = /** @class */ (function () {
    function CartAPIAdaptor() {
    }
    CartAPIAdaptor.adaptRemoveSession = function (cart_session) {
        return {
            session_id: cart_session.session.id
        };
    };
    CartAPIAdaptor.adaptAddSession = function (scheduled_session, cost) {
        return {
            scheduled_as: scheduled_session.scheduled_as,
            scheduled_event_id: scheduled_session.scheduled_event_id,
            session_id: scheduled_session.session.id,
            cost: cost
        };
    };
    CartAPIAdaptor.adaptAddCredits = function (credits) {
        return credits;
    };
    CartAPIAdaptor.adaptRemoveCredit = function (credit) {
        return __assign({}, credit);
    };
    CartAPIAdaptor.adaptCompleteOrder = function (checkout_data) {
        return __assign({}, checkout_data);
    };
    /**
     * Adapt App cart package data to data processable by backend when adding new packages
     */
    CartAPIAdaptor.adaptAddPackages = function (packages) {
        return packages;
    };
    CartAPIAdaptor.adaptRemoveCreditPackage = function (credit_package) {
        return __assign({}, credit_package);
    };
    CartAPIAdaptor.adaptRemoveRegistrationItem = function (item) {
        // By this point, the type key is either 'registration_fee' or 'series_registration_fee'
        var cart_item_type_key = item.cart_item_type_key;
        return {
            registration_item_id: item.id,
            cart_item_type_key: cart_item_type_key
        };
    };
    return CartAPIAdaptor;
}());



/***/ }),

/***/ "./src/js/adaptors/APIAdaptors/CompetitionRegistrationAPIAdapter.ts":
/*!**************************************************************************!*\
  !*** ./src/js/adaptors/APIAdaptors/CompetitionRegistrationAPIAdapter.ts ***!
  \**************************************************************************/
/*! exports provided: CompetitionRegistrationAPIAdapter */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CompetitionRegistrationAPIAdapter", function() { return CompetitionRegistrationAPIAdapter; });
/* harmony import */ var _helpers_time__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../helpers/time */ "./src/js/helpers/time.ts");
/* harmony import */ var _SkateTestHistoryAPIAdaptor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SkateTestHistoryAPIAdaptor */ "./src/js/adaptors/APIAdaptors/SkateTestHistoryAPIAdaptor.ts");
/* harmony import */ var _SkaterEventDataAdaptor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../SkaterEventDataAdaptor */ "./src/js/adaptors/SkaterEventDataAdaptor.ts");
var __assign = (undefined && undefined.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};



var CompetitionRegistrationAPIAdapter = /** @class */ (function () {
    function CompetitionRegistrationAPIAdapter() {
    }
    /**
     * Adapt core competition information
     */
    CompetitionRegistrationAPIAdapter.adaptCompetitionCore = function (core_data) {
        return __assign({}, core_data, { start_date: Object(_helpers_time__WEBPACK_IMPORTED_MODULE_0__["UTCDateFormatNoYear"])(new Date(core_data.start_date_ts * 1000)), end_date: Object(_helpers_time__WEBPACK_IMPORTED_MODULE_0__["UTCDateFormatNoYear"])(new Date(core_data.end_date_ts * 1000)), start_date_ts: core_data.start_date_ts * 1000, end_date_ts: core_data.end_date_ts * 1000 });
    };
    /**
     * Adapt data for the competition list
     */
    CompetitionRegistrationAPIAdapter.adaptCompetitionList = function (raw_data) {
        return raw_data.map(function (competition_data) {
            return __assign({}, competition_data, CompetitionRegistrationAPIAdapter.adaptCompetitionCore(competition_data));
        });
    };
    /**
     * Adapt active competition data
     */
    CompetitionRegistrationAPIAdapter.adaptActiveCompetitionInformation = function (data) {
        return __assign({}, data, { competition: CompetitionRegistrationAPIAdapter.adaptCompetitionCore(data.competition) });
    };
    CompetitionRegistrationAPIAdapter.adaptActiveCompetitionPrices = function (prices) {
        return __assign({}, prices);
    };
    CompetitionRegistrationAPIAdapter.adaptEventSelectionEventDataToEventSelectionEvent = function (data) {
        return __assign({}, data);
    };
    CompetitionRegistrationAPIAdapter.adaptPartnerSkateTestSummaryDataToPartnerSkateTestSummary = function (data) {
        return __assign({}, data);
    };
    CompetitionRegistrationAPIAdapter.adaptEventSelectionDataToEventSelectionResponse = function (data) {
        return {
            available_events: data.available_events.map(function (item) {
                return CompetitionRegistrationAPIAdapter.adaptEventSelectionEventDataToEventSelectionEvent(item);
            }),
            partner_skate_test_summary: data.partner_skate_test_summary.map(function (item) {
                return CompetitionRegistrationAPIAdapter.adaptPartnerSkateTestSummaryDataToPartnerSkateTestSummary(item);
            }),
        };
    };
    CompetitionRegistrationAPIAdapter.adaptAddEventToEventSelectionAddAPIPayload = function (event) {
        return {
            event_id: event.id
        };
    };
    CompetitionRegistrationAPIAdapter.adaptAddEventToEventSelectionRemoveAPIPayload = function (event) {
        return {
            event_id: event.id
        };
    };
    CompetitionRegistrationAPIAdapter.adaptPartnerSkateTestRemoveAPIResponseToPartnerSkateTestRemoveResult = function (data) {
        return {
            skate_test_history: _SkateTestHistoryAPIAdaptor__WEBPACK_IMPORTED_MODULE_1__["SkateTestHistoryAPIAdaptor"].adaptUserSkateTestHistoryDataToUserSkateTestHistory(data.skate_test_history),
            partner_skate_test_summary: data.partner_skate_test_summary.map(function (item) {
                return CompetitionRegistrationAPIAdapter.adaptPartnerSkateTestSummaryDataToPartnerSkateTestSummary(item);
            }),
        };
    };
    CompetitionRegistrationAPIAdapter.adaptPartnerSkateTestAddAPIResponseToPartnerSkateTestAddResult = function (data) {
        return {
            skate_test_history: _SkateTestHistoryAPIAdaptor__WEBPACK_IMPORTED_MODULE_1__["SkateTestHistoryAPIAdaptor"].adaptUserSkateTestHistoryDataToUserSkateTestHistory(data.skate_test_history),
            partner_skate_test_summary: data.partner_skate_test_summary.map(function (item) {
                return CompetitionRegistrationAPIAdapter.adaptPartnerSkateTestSummaryDataToPartnerSkateTestSummary(item);
            }),
        };
    };
    CompetitionRegistrationAPIAdapter.adaptPartnerIdentificationCategoryDataArrayToPartnerIdentificationCategoryArray = function (partner_categories) {
        return partner_categories.map(function (category_data) {
            return __assign({}, category_data);
        });
    };
    CompetitionRegistrationAPIAdapter.adaptAddPartnerPayloadToAddPartnerAPIPayload = function (payload) {
        return __assign({}, payload);
    };
    CompetitionRegistrationAPIAdapter.adaptRemovePartnerPayloadToRemovePartnerAPIPayload = function (payload) {
        return __assign({}, payload);
    };
    CompetitionRegistrationAPIAdapter.adaptSkaterCoachedEventCategoryDataArrayToSkaterCoachedEventCategoryArray = function (coach_categories) {
        return coach_categories.map(function (data) {
            return _SkaterEventDataAdaptor__WEBPACK_IMPORTED_MODULE_2__["SkaterEventDataAdaptor"].adaptCoachedEvent(data);
        });
    };
    CompetitionRegistrationAPIAdapter.adaptCompRegAddCoachPayloadToCompRegAddCoachAPIPayload = function (payload) {
        return __assign({}, payload);
    };
    CompetitionRegistrationAPIAdapter.adaptCompRegRemoveCoachPayloadToCompRegRemoveCoachAPIPayload = function (payload) {
        return __assign({}, payload);
    };
    CompetitionRegistrationAPIAdapter.adaptCompRegReplaceCoachPayloadToCompRegReplaceCoachAPIPayload = function (payload) {
        return __assign({}, payload);
    };
    CompetitionRegistrationAPIAdapter.adaptRepresentationSelectionToRepresentationSelectionData = function (representation) {
        return __assign({}, representation);
    };
    CompetitionRegistrationAPIAdapter.adaptSelectedRepresentationDataToRepresentationSelection = function (selected_representation) {
        return __assign({}, selected_representation);
    };
    return CompetitionRegistrationAPIAdapter;
}());



/***/ }),

/***/ "./src/js/adaptors/APIAdaptors/SkateTestHistoryAPIAdaptor.ts":
/*!*******************************************************************!*\
  !*** ./src/js/adaptors/APIAdaptors/SkateTestHistoryAPIAdaptor.ts ***!
  \*******************************************************************/
/*! exports provided: SkateTestHistoryAPIAdaptor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SkateTestHistoryAPIAdaptor", function() { return SkateTestHistoryAPIAdaptor; });
var __assign = (undefined && undefined.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
var SkateTestHistoryAPIAdaptor = /** @class */ (function () {
    function SkateTestHistoryAPIAdaptor() {
    }
    SkateTestHistoryAPIAdaptor.adaptUserSkateTestHistoryDataToUserSkateTestHistory = function (data) {
        return __assign({}, data);
    };
    SkateTestHistoryAPIAdaptor.adaptSkateTestFormDataToIndividualSkateTestData = function (test_data) {
        return __assign({}, test_data, { test: test_data.test.value });
    };
    SkateTestHistoryAPIAdaptor.adaptSkateTestRemoveAppPayloadToSkateTestRemoveAPIPayload = function (remove_data) {
        return {
            discipline_key: remove_data.discipline.key,
            test_id: remove_data.test.id
        };
    };
    SkateTestHistoryAPIAdaptor.adaptPartnerSkateTestRemoveAppPayloadToPartnerSkateTestRemoveAPIPayload = function (remove_data) {
        return {
            discipline_key: remove_data.discipline.key,
            test: remove_data.test,
            partner_id: remove_data.partner_id
        };
    };
    SkateTestHistoryAPIAdaptor.adaptPartnerSkateTestAddAppPayloadToPartnerSkateTestAddAPIPayload = function (payload) {
        return __assign({}, payload, { test_data: SkateTestHistoryAPIAdaptor.adaptSkateTestFormDataToIndividualSkateTestData(payload.test_data) });
    };
    return SkateTestHistoryAPIAdaptor;
}());



/***/ }),

/***/ "./src/js/adaptors/APIAdaptors/SkaterAPIAdaptor.ts":
/*!*********************************************************!*\
  !*** ./src/js/adaptors/APIAdaptors/SkaterAPIAdaptor.ts ***!
  \*********************************************************/
/*! exports provided: SkaterAPIAdaptor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SkaterAPIAdaptor", function() { return SkaterAPIAdaptor; });
/* harmony import */ var _models_Music_EventSegmentMusic__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../models/Music/EventSegmentMusic */ "./src/js/models/Music/EventSegmentMusic.ts");
/* harmony import */ var _models_Music_SavedMusic__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../models/Music/SavedMusic */ "./src/js/models/Music/SavedMusic.ts");
var __assign = (undefined && undefined.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};


/**
 * Adapt App Data for Consumption by API
 */
var SkaterAPIAdaptor = /** @class */ (function () {
    function SkaterAPIAdaptor() {
    }
    SkaterAPIAdaptor.adaptAddSession = function (scheduled_session) {
        return {
            scheduled_as: scheduled_session.scheduled_as,
            scheduled_event_id: scheduled_session.scheduled_event_id,
            session_id: scheduled_session.session.id,
        };
    };
    SkaterAPIAdaptor.adaptRemoveSession = function (scheduled_session) {
        return {
            scheduled_as: scheduled_session.scheduled_as,
            scheduled_event_id: scheduled_session.scheduled_event_id,
            session_id: scheduled_session.session.id,
        };
    };
    SkaterAPIAdaptor.adaptBillingAddressFormDataToBillingAddressSubmitData = function (data) {
        return __assign({}, data, { street_2: data.street_2 ? data.street_2 : null, state: data.state ? data.state : null, province: data.province ? data.province : null });
    };
    SkaterAPIAdaptor.adaptUpdateAddress = function (edit_opts) {
        var source = edit_opts.source, data = edit_opts.data;
        return {
            source: source,
            data: SkaterAPIAdaptor.adaptBillingAddressFormDataToBillingAddressSubmitData(data)
        };
    };
    SkaterAPIAdaptor.adaptCreateAddress = function (data) {
        return SkaterAPIAdaptor.adaptBillingAddressFormDataToBillingAddressSubmitData(data);
    };
    SkaterAPIAdaptor.adaptRemoveCoach = function (payload) {
        return {
            competition_id: payload.competition_id,
            coach_id: payload.coach.id,
            event_category_id: payload.event_category_id
        };
    };
    SkaterAPIAdaptor.adaptAddCoach = function (payload) {
        return {
            competition_id: payload.competition_id,
            coach_id: payload.coach.id,
            event_category_id: payload.event_category_id
        };
    };
    SkaterAPIAdaptor.adaptReplaceCoach = function (payload) {
        return {
            competition_id: payload.competition_id,
            replacement_coach_id: payload.coach.id,
            event_category_id: payload.event_category_id,
            previous_coach_id: payload.previous_coach_id
        };
    };
    SkaterAPIAdaptor.adaptSavePPC = function (payload) {
        return {
            ppc: payload.ppc.export(),
            event_id: payload.event_id,
            event_segment_id: payload.segment_id,
            competition_id: payload.competition_id,
            competition_skated_event_id: payload.competition_skated_event_id
        };
    };
    SkaterAPIAdaptor.adaptSavePPCResponse = function (save_response) {
        if (save_response.last_modified) {
            save_response.last_modified *= 1000;
        }
        return __assign({}, save_response);
    };
    SkaterAPIAdaptor.adaptSaveMusic = function (save_payload) {
        return __assign({}, save_payload, { music: save_payload.music.export() });
    };
    SkaterAPIAdaptor.adaptSaveMusicResponse = function (save_response, save_payload) {
        // @downstream-sync 2020-07-02 - downstream music items have id:string typing
        var saved_music = _models_Music_SavedMusic__WEBPACK_IMPORTED_MODULE_1__["SavedMusic"].createFromMusic(save_payload.music, save_response.music_item_id);
        var event_segment_music = new _models_Music_EventSegmentMusic__WEBPACK_IMPORTED_MODULE_0__["EventSegmentMusic"](__assign({}, save_payload, { music: saved_music }));
        return {
            success: save_response.success,
            is_complete: save_response.is_complete,
            last_modified: save_response.last_modified ? save_response.last_modified * 1000 : save_response.last_modified,
            event_segment_music: event_segment_music
        };
    };
    return SkaterAPIAdaptor;
}());



/***/ }),

/***/ "./src/js/adaptors/APIAdaptors/UserAPIAdaptor.ts":
/*!*******************************************************!*\
  !*** ./src/js/adaptors/APIAdaptors/UserAPIAdaptor.ts ***!
  \*******************************************************/
/*! exports provided: UserAPIAdaptor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UserAPIAdaptor", function() { return UserAPIAdaptor; });
var __assign = (undefined && undefined.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
var UserAPIAdaptor = /** @class */ (function () {
    function UserAPIAdaptor() {
    }
    UserAPIAdaptor.adaptUserProfileDataToUserProfile = function (profile_data) {
        return __assign({}, profile_data, { birth_date: {
                formatted: profile_data.birth_date.formatted,
                timestamp: profile_data.birth_date.timestamp * 1000
            } });
    };
    UserAPIAdaptor.adaptEditProfileFormStateToUserProfileData = function (profile_data) {
        /**
         * At this point, profile_data has been validated to ensure required properties are provided. Null coalescing is
         * here solely for type-safeness
         */
        return __assign({}, profile_data, { first_name: profile_data.first_name || "", last_name: profile_data.last_name || "", birth_date: profile_data.birth_date || "" });
    };
    UserAPIAdaptor.adaptUserWaiversToUserWaiverSaveData = function (user_waiver) {
        return {
            id: user_waiver.id,
            name: user_waiver.status.name,
            relationship: user_waiver.status.relationship
        };
    };
    UserAPIAdaptor.adaptUserWaiverDataToUserWaiver = function (user_waiver) {
        return __assign({}, user_waiver);
    };
    return UserAPIAdaptor;
}());



/***/ }),

/***/ "./src/js/adaptors/APIAdaptors/VolunteerOpportunitiesAPIAdaptor.ts":
/*!*************************************************************************!*\
  !*** ./src/js/adaptors/APIAdaptors/VolunteerOpportunitiesAPIAdaptor.ts ***!
  \*************************************************************************/
/*! exports provided: VolunteerOpportunitiesAPIAdaptor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VolunteerOpportunitiesAPIAdaptor", function() { return VolunteerOpportunitiesAPIAdaptor; });
/* harmony import */ var _UserAPIAdaptor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./UserAPIAdaptor */ "./src/js/adaptors/APIAdaptors/UserAPIAdaptor.ts");
var __assign = (undefined && undefined.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};

var VolunteerOpportunitiesAPIAdaptor = /** @class */ (function () {
    function VolunteerOpportunitiesAPIAdaptor() {
    }
    /**
     * Transform categorized set of opportunities from API to App structures
     */
    VolunteerOpportunitiesAPIAdaptor.adaptCategorizedVolunteerOpportunitiesDataToVolunteerRequestCategorizedOpportunities = function (data) {
        return {
            upcoming: {
                local: data.upcoming.local.map(function (data) {
                    return VolunteerOpportunitiesAPIAdaptor.adaptOpportunityEvent(data);
                }),
                usfs: data.upcoming.usfs.map(function (data) {
                    return VolunteerOpportunitiesAPIAdaptor.adaptOpportunityEvent(data);
                })
            },
            requested: data.requested.map(function (data) {
                return VolunteerOpportunitiesAPIAdaptor.adaptOpportunityEvent(data);
            })
        };
    };
    /**
     * Transform search form data to structure usable by API
     */
    VolunteerOpportunitiesAPIAdaptor.adaptExportedVolunteerRequestSearchFormToVolunteerOpportunitySearchAPIPayload = function (payload) {
        return {
            state: payload.state ? payload.state.value : null,
            club: payload.club ? payload.club.value : null,
            competition_name: payload.event_name || null,
            start_date: payload.start_date || null,
            end_date: payload.end_date || null
        };
    };
    /**
     * Transform response when fetching opportunities list
     */
    VolunteerOpportunitiesAPIAdaptor.adaptFetchVolunteerOpportunitiesResponse = function (response) {
        return {
            opportunities: VolunteerOpportunitiesAPIAdaptor.adaptCategorizedVolunteerOpportunitiesDataToVolunteerRequestCategorizedOpportunities(response.opportunities),
            search_form_options: {
                states: response.search_form_options.states.slice(),
                clubs: response.search_form_options.clubs.slice()
            }
        };
    };
    /**
     * Transform response when fetching data for an individual opportunity
     */
    VolunteerOpportunitiesAPIAdaptor.adaptFetchVolunteerRequestDataResponse = function (response) {
        var links = response.links, user_profile_form_options = response.user_profile_form_options, user_profile = response.user_profile, user_emergency_contact = response.user_emergency_contact, opportunity_request_form_options = response.opportunity_request_form_options;
        return {
            links: links,
            user_profile_form_options: user_profile_form_options,
            user_profile: _UserAPIAdaptor__WEBPACK_IMPORTED_MODULE_0__["UserAPIAdaptor"].adaptUserProfileDataToUserProfile(user_profile),
            user_emergency_contact: {
                name: user_emergency_contact.name || null,
                relationship: user_emergency_contact.relationship || null,
                phone: user_emergency_contact.phone || null
            },
            opportunity_request_form_options: opportunity_request_form_options,
            waivers: VolunteerOpportunitiesAPIAdaptor.adaptFetchVolunteerRequestDataResponseWaivers(response)
        };
    };
    VolunteerOpportunitiesAPIAdaptor.adaptFetchVolunteerRequestDataResponseWaivers = function (response) {
        var waivers_information = response.waivers;
        return {
            form_options: {
                relationships: waivers_information ? waivers_information.form_options.relationships.slice() : []
            },
            user_waivers: waivers_information ? waivers_information.user_waivers.map(function (waiver_data) {
                return _UserAPIAdaptor__WEBPACK_IMPORTED_MODULE_0__["UserAPIAdaptor"].adaptUserWaiverDataToUserWaiver(waiver_data);
            }) : [],
            lead: waivers_information ? waivers_information && waivers_information.introduction : 'Please confirm your agreement of the terms and conditions below.'
        };
    };
    /**
     * Transform an individual opportunity item
     */
    VolunteerOpportunitiesAPIAdaptor.adaptOpportunityEvent = function (event_data) {
        return __assign({}, event_data);
    };
    /**
     * Transform response when submitting an opportunity request
     */
    VolunteerOpportunitiesAPIAdaptor.adaptSubmitVolunteerRequestResponse = function (response) {
        var opportunities = response.opportunities, redirect_url = response.redirect_url;
        return {
            opportunities: opportunities ? VolunteerOpportunitiesAPIAdaptor.adaptCategorizedVolunteerOpportunitiesDataToVolunteerRequestCategorizedOpportunities(opportunities) : null,
            redirect_url: redirect_url
        };
    };
    /**
     * Transform response when searching for an opportunity
     */
    VolunteerOpportunitiesAPIAdaptor.adaptVolunteerOpportunitySearchResponse = function (response) {
        return {
            opportunities: response.opportunities.map(function (opportunity_data) {
                return VolunteerOpportunitiesAPIAdaptor.adaptOpportunityEvent(opportunity_data);
            })
        };
    };
    /**
     * Transform experience form data to structure usable by API
     */
    VolunteerOpportunitiesAPIAdaptor.adaptVolunteerRequestExperienceFormDataToSubmitVolunteerRequestAPIPayload = function (app_payload) {
        return {
            experience: app_payload.experience.map(function (item) {
                return __assign({}, item, { description: item.description || null });
            }),
            volunteer_skillset: app_payload.skillset,
            confirmations: {
                terms_and_conditions: app_payload.terms_agree,
                criminal_history_consent: app_payload.records_consent
            },
            waivers: app_payload.waivers.map(function (user_waiver) {
                return _UserAPIAdaptor__WEBPACK_IMPORTED_MODULE_0__["UserAPIAdaptor"].adaptUserWaiversToUserWaiverSaveData(user_waiver);
            })
        };
    };
    /**
     * Update data from General Information form to structure usable by API.
     */
    VolunteerOpportunitiesAPIAdaptor.adaptVolunteerRequestGeneralInformationFormDataToVolunteerRequestUpdateUserProfileAPIPayload = function (app_payload) {
        return {
            profile: {
                address: {
                    country: app_payload.country,
                    street: app_payload.street,
                    street_2: app_payload.street_2,
                    city: app_payload.city,
                    state: app_payload.state,
                    province: app_payload.province,
                    zip: app_payload.zip
                },
                cell_phone: app_payload.cell_phone,
                email: app_payload.email
            },
            emergency_contact: __assign({}, app_payload.emergency_contact)
        };
    };
    return VolunteerOpportunitiesAPIAdaptor;
}());



/***/ }),

/***/ "./src/js/adaptors/BillingAddressDataAdaptor.ts":
/*!******************************************************!*\
  !*** ./src/js/adaptors/BillingAddressDataAdaptor.ts ***!
  \******************************************************/
/*! exports provided: BillingAddressDataAdaptor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BillingAddressDataAdaptor", function() { return BillingAddressDataAdaptor; });
/* harmony import */ var _models_BillingAddress__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../models/BillingAddress */ "./src/js/models/BillingAddress.ts");

var BillingAddressDataAdaptor = /** @class */ (function () {
    function BillingAddressDataAdaptor() {
    }
    BillingAddressDataAdaptor.adapt = function (raw_data) {
        return new _models_BillingAddress__WEBPACK_IMPORTED_MODULE_0__["BillingAddress"](raw_data);
    };
    BillingAddressDataAdaptor.adaptArray = function (raw_data) {
        return raw_data.map(function (data_point) {
            return BillingAddressDataAdaptor.adapt(data_point);
        });
    };
    return BillingAddressDataAdaptor;
}());



/***/ }),

/***/ "./src/js/adaptors/CartDataAdaptor.ts":
/*!********************************************!*\
  !*** ./src/js/adaptors/CartDataAdaptor.ts ***!
  \********************************************/
/*! exports provided: CartDataAdaptor, CartFeeDataAdaptor, CartCreditDataAdaptor, CartCreditPackageDataAdaptor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CartDataAdaptor", function() { return CartDataAdaptor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CartFeeDataAdaptor", function() { return CartFeeDataAdaptor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CartCreditDataAdaptor", function() { return CartCreditDataAdaptor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CartCreditPackageDataAdaptor", function() { return CartCreditPackageDataAdaptor; });
/* harmony import */ var _models_Cart_Cart__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../models/Cart/Cart */ "./src/js/models/Cart/Cart.ts");
/* harmony import */ var _SessionDataAdaptor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SessionDataAdaptor */ "./src/js/adaptors/SessionDataAdaptor.ts");
/* harmony import */ var _models_Cart_CartCreditPackage__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../models/Cart/CartCreditPackage */ "./src/js/models/Cart/CartCreditPackage.ts");
/* harmony import */ var _models_Cart_CartCredit__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../models/Cart/CartCredit */ "./src/js/models/Cart/CartCredit.ts");
var __assign = (undefined && undefined.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};




var CartDataAdaptor = /** @class */ (function () {
    function CartDataAdaptor() {
    }
    CartDataAdaptor.adapt = function (raw_data) {
        var sessions = [];
        var credits = [];
        var credit_packages = [];
        //calculated total cost has been replaced by API-reported total cost
        var total_cost = 0;
        for (var i = 0; i < raw_data.sessions.length; i++) {
            var obj = raw_data.sessions[i];
            var temp = _SessionDataAdaptor__WEBPACK_IMPORTED_MODULE_1__["SessionDataAdaptor"].adaptCartSession(obj);
            total_cost += temp.cost;
            sessions.push(temp);
        }
        for (var i = 0; i < raw_data.credits.length; i++) {
            var cart_credit = CartCreditDataAdaptor.adapt(raw_data.credits[i]);
            total_cost += cart_credit.cost;
            credits.push(cart_credit);
        }
        for (var i = 0; i < raw_data.packages.length; i++) {
            var credit_package_data = raw_data.packages[i];
            var cart_package = CartCreditPackageDataAdaptor.adapt(credit_package_data);
            total_cost += cart_package.cost;
            credit_packages.push(cart_package);
        }
        var cart = new _models_Cart_Cart__WEBPACK_IMPORTED_MODULE_0__["Cart"](sessions, total_cost, credits, credit_packages);
        cart.setCostProperties(CartDataAdaptor.adaptCostProperties(raw_data));
        cart.registration_items = CartDataAdaptor.adaptRegistrationItems(raw_data);
        return cart;
    };
    CartDataAdaptor.adaptCostProperties = function (raw_data) {
        return {
            subtotal: (raw_data.subtotal !== null && raw_data.subtotal !== undefined) ? raw_data.subtotal : false,
            additional_fees: (raw_data.additional_fees && "map" in raw_data.additional_fees) ? raw_data.additional_fees.map(function (fee_data) {
                return CartFeeDataAdaptor.adapt(fee_data);
            }) : false,
            total: (raw_data.total !== null && raw_data.total !== undefined) ? raw_data.total : false,
        };
    };
    CartDataAdaptor.adaptRegistrationItems = function (raw_data) {
        if (!raw_data.registration_items) {
            return [];
        }
        return raw_data.registration_items.map(function (data) {
            return __assign({}, data, { is_registration_item: true, description_lines: data.description_lines ? data.description_lines : [] });
        });
    };
    return CartDataAdaptor;
}());

var CartFeeDataAdaptor = /** @class */ (function () {
    function CartFeeDataAdaptor() {
    }
    CartFeeDataAdaptor.adapt = function (raw_data) {
        return __assign({}, raw_data);
    };
    return CartFeeDataAdaptor;
}());

var CartCreditDataAdaptor = /** @class */ (function () {
    function CartCreditDataAdaptor() {
    }
    CartCreditDataAdaptor.adapt = function (raw_data) {
        return new _models_Cart_CartCredit__WEBPACK_IMPORTED_MODULE_3__["CartCredit"](raw_data);
    };
    return CartCreditDataAdaptor;
}());

var CartCreditPackageDataAdaptor = /** @class */ (function () {
    function CartCreditPackageDataAdaptor() {
    }
    CartCreditPackageDataAdaptor.adapt = function (raw_data) {
        return new _models_Cart_CartCreditPackage__WEBPACK_IMPORTED_MODULE_2__["CartCreditPackage"](raw_data);
    };
    return CartCreditPackageDataAdaptor;
}());



/***/ }),

/***/ "./src/js/adaptors/CoachAdaptor.ts":
/*!*****************************************!*\
  !*** ./src/js/adaptors/CoachAdaptor.ts ***!
  \*****************************************/
/*! exports provided: CoachAdaptor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CoachAdaptor", function() { return CoachAdaptor; });
var CoachAdaptor = /** @class */ (function () {
    function CoachAdaptor() {
    }
    CoachAdaptor.adaptCoachResult = function (raw_data) {
        return {
            club_name: raw_data.club_name,
            first_name: raw_data.first_name,
            id: raw_data.id,
            ineligible: raw_data.ineligible,
            last_name: raw_data.last_name,
            member_number: parseInt(raw_data.member_number),
            state_abbreviation: raw_data.state_abbreviation,
        };
    };
    CoachAdaptor.adaptCoachResultArray = function (raw_data) {
        return raw_data.map(function (item) {
            return CoachAdaptor.adaptCoachResult(item);
        });
    };
    return CoachAdaptor;
}());



/***/ }),

/***/ "./src/js/adaptors/CoachSkaterScheduleAdaptor.ts":
/*!*******************************************************!*\
  !*** ./src/js/adaptors/CoachSkaterScheduleAdaptor.ts ***!
  \*******************************************************/
/*! exports provided: CoachSkaterScheduleAdaptor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CoachSkaterScheduleAdaptor", function() { return CoachSkaterScheduleAdaptor; });
/* harmony import */ var _models_Schedule_CoachSkatersSchedule__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../models/Schedule/CoachSkatersSchedule */ "./src/js/models/Schedule/CoachSkatersSchedule.ts");
/* harmony import */ var _models_Collections_SessionCollection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../models/Collections/SessionCollection */ "./src/js/models/Collections/SessionCollection.ts");
/* harmony import */ var _SessionDataAdaptor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./SessionDataAdaptor */ "./src/js/adaptors/SessionDataAdaptor.ts");



var CoachSkaterScheduleAdaptor = /** @class */ (function () {
    function CoachSkaterScheduleAdaptor() {
    }
    CoachSkaterScheduleAdaptor.adapt = function (sessions_data, skater_session_map) {
        return new _models_Schedule_CoachSkatersSchedule__WEBPACK_IMPORTED_MODULE_0__["CoachSkatersSchedule"](new _models_Collections_SessionCollection__WEBPACK_IMPORTED_MODULE_1__["SessionCollection"](_SessionDataAdaptor__WEBPACK_IMPORTED_MODULE_2__["SessionDataAdaptor"].adaptArray(sessions_data)), skater_session_map);
    };
    return CoachSkaterScheduleAdaptor;
}());



/***/ }),

/***/ "./src/js/adaptors/CoachSkatersAdaptor.ts":
/*!************************************************!*\
  !*** ./src/js/adaptors/CoachSkatersAdaptor.ts ***!
  \************************************************/
/*! exports provided: CoachSkatersAdaptor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CoachSkatersAdaptor", function() { return CoachSkatersAdaptor; });
var CoachSkatersAdaptor = /** @class */ (function () {
    function CoachSkatersAdaptor() {
    }
    /**
     * Adapt coach skater data into coach skater
     */
    CoachSkatersAdaptor.adapt = function (raw_data) {
        return {
            id: raw_data.id,
            first_name: raw_data.first_name,
            last_name: raw_data.last_name,
            federation_letter_status: raw_data.federation_letter_status ? raw_data.federation_letter_status : false,
            events: CoachSkatersAdaptor.adaptEventArray(raw_data.events),
        };
    };
    /**
     * Adapt coach skater event data into coach skater event
     */
    CoachSkatersAdaptor.adaptEvent = function (raw_data) {
        return {
            name: raw_data.name,
            coaching_role: raw_data.coaching_role,
            music_complete: raw_data.music_complete,
            ppc_complete: raw_data.ppc_complete,
            ppc_required: raw_data.ppc_required,
            music_required: raw_data.music_required,
        };
    };
    /**
     * Adapt array of coach skater data into array of coach skaters
     */
    CoachSkatersAdaptor.adaptArray = function (raw_data) {
        var result = [];
        for (var i = 0; i < raw_data.length; i++) {
            result.push(CoachSkatersAdaptor.adapt(raw_data[i]));
        }
        return result;
    };
    /**
     * Adapt array of coach skater event data into array of coach skaters
     */
    CoachSkatersAdaptor.adaptEventArray = function (raw_data) {
        var result = [];
        for (var i = 0; i < raw_data.length; i++) {
            result.push(CoachSkatersAdaptor.adaptEvent(raw_data[i]));
        }
        return result;
    };
    return CoachSkatersAdaptor;
}());



/***/ }),

/***/ "./src/js/adaptors/CompetitionContactDataAdaptor.ts":
/*!**********************************************************!*\
  !*** ./src/js/adaptors/CompetitionContactDataAdaptor.ts ***!
  \**********************************************************/
/*! exports provided: CompetitionContactDataAdaptor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CompetitionContactDataAdaptor", function() { return CompetitionContactDataAdaptor; });
var CompetitionContactDataAdaptor = /** @class */ (function () {
    function CompetitionContactDataAdaptor() {
    }
    CompetitionContactDataAdaptor.adapt = function (raw_data) {
        return {
            name: raw_data.name,
            role: raw_data.role,
            email: raw_data.email
        };
    };
    CompetitionContactDataAdaptor.adaptArray = function (raw_data) {
        var results = [];
        for (var i = 0; i < raw_data.length; i++) {
            results.push(CompetitionContactDataAdaptor.adapt(raw_data[i]));
        }
        return results;
    };
    return CompetitionContactDataAdaptor;
}());



/***/ }),

/***/ "./src/js/adaptors/CompetitionDataAdaptor.ts":
/*!***************************************************!*\
  !*** ./src/js/adaptors/CompetitionDataAdaptor.ts ***!
  \***************************************************/
/*! exports provided: CompetitionDataAdaptor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CompetitionDataAdaptor", function() { return CompetitionDataAdaptor; });
/* harmony import */ var _models_Competition_Competition__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../models/Competition/Competition */ "./src/js/models/Competition/Competition.ts");

var CompetitionDataAdaptor = /** @class */ (function () {
    function CompetitionDataAdaptor() {
    }
    CompetitionDataAdaptor.adapt = function (raw_data) {
        raw_data.end_date = raw_data.end_date * 1000; //account for difference in javascript timestamp length
        raw_data.start_date = raw_data.start_date * 1000; //account for difference in javascript timestamp length
        return new _models_Competition_Competition__WEBPACK_IMPORTED_MODULE_0__["Competition"](raw_data);
    };
    CompetitionDataAdaptor.adaptArray = function (raw_data) {
        var results = [];
        for (var i = 0; i < raw_data.length; i++) {
            results.push(CompetitionDataAdaptor.adapt(raw_data[i]));
        }
        return results;
    };
    return CompetitionDataAdaptor;
}());



/***/ }),

/***/ "./src/js/adaptors/CompetitionInformationDataAdaptor.ts":
/*!**************************************************************!*\
  !*** ./src/js/adaptors/CompetitionInformationDataAdaptor.ts ***!
  \**************************************************************/
/*! exports provided: CompetitionInformationDataAdaptor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CompetitionInformationDataAdaptor", function() { return CompetitionInformationDataAdaptor; });
/* harmony import */ var _models_Competition_CompetitionInformation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../models/Competition/CompetitionInformation */ "./src/js/models/Competition/CompetitionInformation.ts");
/* harmony import */ var _SalesWindowDataAdaptor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SalesWindowDataAdaptor */ "./src/js/adaptors/SalesWindowDataAdaptor.ts");
/* harmony import */ var _SkatingEventDataAdaptor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./SkatingEventDataAdaptor */ "./src/js/adaptors/SkatingEventDataAdaptor.ts");
var __assign = (undefined && undefined.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};



var CompetitionInformationDataAdaptor = /** @class */ (function () {
    function CompetitionInformationDataAdaptor() {
    }
    CompetitionInformationDataAdaptor.adaptDeadline = function (deadline_date) {
        if (deadline_date === null) {
            return null;
        }
        return __assign({}, deadline_date, { timestamp: deadline_date.timestamp * 1000, date: new Date(deadline_date.timestamp * 1000) });
    };
    CompetitionInformationDataAdaptor.adapt = function (raw_data) {
        var competition_id = parseInt(String(raw_data.competition_id));
        var sales_windows = _SalesWindowDataAdaptor__WEBPACK_IMPORTED_MODULE_1__["SalesWindowDataAdaptor"].adaptArray(raw_data.sales_windows);
        var skating_events = _SkatingEventDataAdaptor__WEBPACK_IMPORTED_MODULE_2__["SkatingEventDataAdaptor"].adaptArray(raw_data.skating_events);
        var practice_ice_instructions = raw_data.practice_ice_instructions;
        var practice_ice_terminology = raw_data.practice_ice_terminology;
        var schedulable_session_types = raw_data.schedulable_session_types;
        var pricing_message = raw_data.pricing_message ? raw_data.pricing_message : false;
        var music_ppc_deadline_description = raw_data.music_ppc_deadline_description ? raw_data.music_ppc_deadline_description : '';
        var ppc_deadline = raw_data.ppc_deadline ? CompetitionInformationDataAdaptor.adaptDeadline(raw_data.ppc_deadline) : null;
        var music_deadline = raw_data.music_deadline ? CompetitionInformationDataAdaptor.adaptDeadline(raw_data.music_deadline) : null;
        /**
         * @deprecated - 2020-06-17
         */
        var competition_documents = {
            action_documents: raw_data.competition_documents ? raw_data.competition_documents.action_documents : [],
            reference_documents: raw_data.competition_documents ? raw_data.competition_documents.reference_documents : []
        };
        var args = {
            competition_id: competition_id,
            sales_windows: sales_windows,
            skating_events: skating_events,
            practice_ice_instructions: practice_ice_instructions,
            practice_ice_terminology: practice_ice_terminology,
            schedulable_session_types: schedulable_session_types,
            pricing_message: pricing_message,
            music_ppc_deadline_description: music_ppc_deadline_description,
            ppc_deadline: ppc_deadline,
            music_deadline: music_deadline,
            competition_documents: competition_documents
        };
        return new _models_Competition_CompetitionInformation__WEBPACK_IMPORTED_MODULE_0__["CompetitionInformation"](args);
    };
    return CompetitionInformationDataAdaptor;
}());



/***/ }),

/***/ "./src/js/adaptors/CompetitionScheduleDataAdaptor.ts":
/*!***********************************************************!*\
  !*** ./src/js/adaptors/CompetitionScheduleDataAdaptor.ts ***!
  \***********************************************************/
/*! exports provided: CompetitionScheduleDataAdaptor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CompetitionScheduleDataAdaptor", function() { return CompetitionScheduleDataAdaptor; });
/* harmony import */ var _models_Competition_CompetitionSchedule__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../models/Competition/CompetitionSchedule */ "./src/js/models/Competition/CompetitionSchedule.ts");
/* harmony import */ var _FacilityDataAdaptor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./FacilityDataAdaptor */ "./src/js/adaptors/FacilityDataAdaptor.ts");
/* harmony import */ var _RinkDataAdaptor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./RinkDataAdaptor */ "./src/js/adaptors/RinkDataAdaptor.ts");
/* harmony import */ var _SessionDataAdaptor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./SessionDataAdaptor */ "./src/js/adaptors/SessionDataAdaptor.ts");




var CompetitionScheduleDataAdaptor = /** @class */ (function () {
    function CompetitionScheduleDataAdaptor() {
    }
    CompetitionScheduleDataAdaptor.adapt = function (raw_data) {
        var facilities_array = _FacilityDataAdaptor__WEBPACK_IMPORTED_MODULE_1__["FacililtyDataAdaptor"].adaptArray(raw_data.facilities);
        var rinks_array = _RinkDataAdaptor__WEBPACK_IMPORTED_MODULE_2__["RinkDataAdaptor"].adaptFullArray(raw_data.rinks);
        var sessions_array = _SessionDataAdaptor__WEBPACK_IMPORTED_MODULE_3__["SessionDataAdaptor"].adaptArray(raw_data.sessions);
        var competitionSchedule = new _models_Competition_CompetitionSchedule__WEBPACK_IMPORTED_MODULE_0__["CompetitionSchedule"](facilities_array, rinks_array, sessions_array);
        if (raw_data.legend) {
            competitionSchedule.legend = raw_data.legend;
        }
        if (raw_data.links) {
            competitionSchedule.links = raw_data.links;
        }
        return competitionSchedule;
    };
    return CompetitionScheduleDataAdaptor;
}());



/***/ }),

/***/ "./src/js/adaptors/FacilityDataAdaptor.ts":
/*!************************************************!*\
  !*** ./src/js/adaptors/FacilityDataAdaptor.ts ***!
  \************************************************/
/*! exports provided: FacililtyDataAdaptor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FacililtyDataAdaptor", function() { return FacililtyDataAdaptor; });
/* harmony import */ var _models_Facility__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../models/Facility */ "./src/js/models/Facility.ts");

var FacililtyDataAdaptor = /** @class */ (function () {
    function FacililtyDataAdaptor() {
    }
    FacililtyDataAdaptor.adapt = function (raw_data) {
        return new _models_Facility__WEBPACK_IMPORTED_MODULE_0__["Facility"](raw_data.name, raw_data.id);
    };
    FacililtyDataAdaptor.adaptArray = function (raw_data) {
        var result = [];
        for (var i = 0; i < raw_data.length; i++) {
            var facility = FacililtyDataAdaptor.adapt(raw_data[i]);
            result.push(facility);
        }
        return result;
    };
    return FacililtyDataAdaptor;
}());



/***/ }),

/***/ "./src/js/adaptors/MemberSearchAdaptor.ts":
/*!************************************************!*\
  !*** ./src/js/adaptors/MemberSearchAdaptor.ts ***!
  \************************************************/
/*! exports provided: MemberSearchAdaptor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MemberSearchAdaptor", function() { return MemberSearchAdaptor; });
var __assign = (undefined && undefined.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
var MemberSearchAdaptor = /** @class */ (function () {
    function MemberSearchAdaptor() {
    }
    MemberSearchAdaptor.adaptResult = function (raw_data) {
        return __assign({}, raw_data);
    };
    MemberSearchAdaptor.adaptResultArray = function (raw_data) {
        return raw_data.map(function (item) {
            return MemberSearchAdaptor.adaptResult(item);
        });
    };
    MemberSearchAdaptor.adaptGenderedResultArray = function (raw_data) {
        return raw_data.map(function (item) {
            return __assign({}, item, MemberSearchAdaptor.adaptResult(item));
        });
    };
    MemberSearchAdaptor.adaptMemberSearchParametersToMemberSearchAPIParameters = function (search_params) {
        return __assign({}, search_params);
    };
    return MemberSearchAdaptor;
}());



/***/ }),

/***/ "./src/js/adaptors/MusicDataAdaptor.ts":
/*!*********************************************!*\
  !*** ./src/js/adaptors/MusicDataAdaptor.ts ***!
  \*********************************************/
/*! exports provided: MusicDataAdaptor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MusicDataAdaptor", function() { return MusicDataAdaptor; });
/* harmony import */ var _models_Music_EventSegmentMusic__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../models/Music/EventSegmentMusic */ "./src/js/models/Music/EventSegmentMusic.ts");
/* harmony import */ var _models_Music_Music__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../models/Music/Music */ "./src/js/models/Music/Music.ts");
/* harmony import */ var _models_Music_MusicCopyright__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../models/Music/MusicCopyright */ "./src/js/models/Music/MusicCopyright.ts");
/* harmony import */ var _models_Music_SavedMusic__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../models/Music/SavedMusic */ "./src/js/models/Music/SavedMusic.ts");




var MusicDataAdaptor = /** @class */ (function () {
    function MusicDataAdaptor() {
    }
    MusicDataAdaptor.adaptEventSegmentMusicDataToSavedMusic = function (data) {
        if (!('music' in data)) {
            throw 'Invalid data';
        }
        if (!data.music) {
            return null;
        }
        return MusicDataAdaptor.adaptSavedMusicDataToSavedMusic(data.music);
    };
    MusicDataAdaptor.adaptEventSegmentMusicDataToEventSegmentMusic = function (data) {
        var required_properties = [
            'music',
            'competition_id',
            'event_id',
            'event_segment_id',
            'competition_skated_event_id'
        ];
        for (var i = 0; i < required_properties.length; i++) {
            var obj = required_properties[i];
            if (!(obj in data)) {
                throw 'Invalid data';
            }
        }
        if (!data.music) {
            return null;
        }
        var args = {
            competition_id: parseInt(String(data.competition_id)),
            event_id: parseInt(String(data.event_id)),
            event_segment_id: parseInt(String(data.event_segment_id)),
            competition_skated_event_id: parseInt(String(data.competition_skated_event_id)),
            music: MusicDataAdaptor.adaptSavedMusicDataToSavedMusic(data.music)
        };
        return new _models_Music_EventSegmentMusic__WEBPACK_IMPORTED_MODULE_0__["EventSegmentMusic"](args);
    };
    MusicDataAdaptor.adaptMusicCopyrightDataToMusicCopyright = function (data, context_id) {
        if (typeof data.duration_minutes === 'string') {
            data.duration_minutes = parseInt(data.duration_minutes);
        }
        if (typeof data.duration_seconds === 'string') {
            data.duration_seconds = parseInt(data.duration_seconds);
        }
        var args = {
            title: data.title,
            artist: data.artist,
            arrangement: data.arrangement,
            record_label: data.record_label,
            duration_minutes: data.duration_minutes,
            duration_seconds: data.duration_seconds,
            context_id: context_id
        };
        return new _models_Music_MusicCopyright__WEBPACK_IMPORTED_MODULE_2__["MusicCopyright"](args);
    };
    /**
     * Adapt the response from uploading a music file
     */
    MusicDataAdaptor.adaptMusicFileUploadResponse = function (data) {
        if (data.success) {
            return {
                success: true,
                file: data.file,
                metadata: data.metadata
            };
        }
        return {
            success: false,
            error: true,
            message: data.error_message
        };
    };
    MusicDataAdaptor.adaptMusicLibrary = function (library) {
        return library.map(function (music_data) {
            return MusicDataAdaptor.adaptSavedMusicDataToSavedMusic(music_data);
        });
    };
    MusicDataAdaptor.adaptSavedMusicDataToMusic = function (saved_music_data) {
        var params = {
            name: saved_music_data.name,
            has_been_played: saved_music_data.has_been_played,
            copyrights: saved_music_data.copyrights.map(function (copyright_data, index) {
                return MusicDataAdaptor.adaptMusicCopyrightDataToMusicCopyright(copyright_data, index + 1);
            }),
            file: MusicDataAdaptor.adaptFileDataToFile(saved_music_data.file),
            active_copyright_context_id: saved_music_data.copyrights.length + 1
        };
        return new _models_Music_Music__WEBPACK_IMPORTED_MODULE_1__["Music"](params);
    };
    MusicDataAdaptor.adaptSavedMusicDataToSavedMusic = function (saved_music_data) {
        var args = {
            name: saved_music_data.name,
            has_been_played: saved_music_data.has_been_played,
            copyrights: saved_music_data.copyrights.map(function (copyright_data, index) {
                return MusicDataAdaptor.adaptMusicCopyrightDataToMusicCopyright(copyright_data, index + 1);
            }),
            file: MusicDataAdaptor.adaptFileDataToFile(saved_music_data.file),
            is_assigned_to_program: saved_music_data.is_assigned_to_program,
            // @downstream-sync 2020-07-02 - downstream music items have id:string typing
            id: saved_music_data.id,
            active_copyright_context_id: saved_music_data.copyrights.length + 1
        };
        return new _models_Music_SavedMusic__WEBPACK_IMPORTED_MODULE_3__["SavedMusic"](args);
    };
    MusicDataAdaptor.adaptFileDataToFile = function (file) {
        if (!file) {
            return null;
        }
        return {
            url: file.url,
            id: file.id
        };
    };
    return MusicDataAdaptor;
}());



/***/ }),

/***/ "./src/js/adaptors/NullableCreditListCreditListAdaptor.ts":
/*!****************************************************************!*\
  !*** ./src/js/adaptors/NullableCreditListCreditListAdaptor.ts ***!
  \****************************************************************/
/*! exports provided: NullableCreditListCreditListAdaptor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NullableCreditListCreditListAdaptor", function() { return NullableCreditListCreditListAdaptor; });
var NullableCreditListCreditListAdaptor = /** @class */ (function () {
    function NullableCreditListCreditListAdaptor() {
    }
    NullableCreditListCreditListAdaptor.adapt = function (nullable_credit_list) {
        var result = {
            opi: 0,
            upi: 0,
            wu: 0
        };
        if (nullable_credit_list) {
            for (var type in result) {
                var source_value = nullable_credit_list[type];
                if (source_value) {
                    result[type] = source_value;
                }
            }
        }
        return result;
    };
    return NullableCreditListCreditListAdaptor;
}());



/***/ }),

/***/ "./src/js/adaptors/PPCDataAdaptor.ts":
/*!*******************************************!*\
  !*** ./src/js/adaptors/PPCDataAdaptor.ts ***!
  \*******************************************/
/*! exports provided: PPCDataAdaptor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PPCDataAdaptor", function() { return PPCDataAdaptor; });
/* harmony import */ var _models_PPC_PPC__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../models/PPC/PPC */ "./src/js/models/PPC/PPC.ts");
/* harmony import */ var _models_PPC_PPCElement__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../models/PPC/PPCElement */ "./src/js/models/PPC/PPCElement.ts");


var PPCDataAdaptor = /** @class */ (function () {
    function PPCDataAdaptor() {
    }
    PPCDataAdaptor.adapt_PPCData_To_PPC = function (data) {
        var args = {
            elements: data.elements.map(function (element_data) {
                return PPCDataAdaptor.adapt_PPCElementData_To_PPCElement(element_data);
            }),
            event_segment_id: parseInt(data.event_segment_id),
            competition_id: parseInt(data.competition_id),
            event_id: parseInt(data.event_id),
            competition_skated_event_id: parseInt(data.competition_skated_event_id)
        };
        return new _models_PPC_PPC__WEBPACK_IMPORTED_MODULE_0__["PPC"](args);
    };
    PPCDataAdaptor.adapt_PPCOptionsData_To_PPCFormOptions = function (data) {
        if (!data.hasOwnProperty('type') || !data.hasOwnProperty('elements')) {
            throw ("Invalid data");
        }
        return {
            types: PPCDataAdaptor.adapt_PPCIndexedTypesData_To_PPCElementTypeArray(data.type),
            moves: PPCDataAdaptor.adapt_IndexedPPCMoveData_To_PPCElementMoveArray(data.elements)
        };
    };
    PPCDataAdaptor.adapt_PPCElementData_To_PPCElement = function (data) {
        var args = {
            moves: data.moves.map(function (move_data) {
                return PPCDataAdaptor.adapt_PPCMoveData_To_PPCElementMove(move_data);
            }),
            type: PPCDataAdaptor.adapt_PPCTypeData_TO_PPCElementType(data.type),
            element: PPCDataAdaptor.adapt_PPCMoveData_To_PPCElementMove(data.element)
        };
        if (data.transition_description) {
            args.transition_description = data.transition_description;
        }
        return new _models_PPC_PPCElement__WEBPACK_IMPORTED_MODULE_1__["PPCElement"](args);
    };
    PPCDataAdaptor.adapt_PPCTypeData_TO_PPCElementType = function (data) {
        return {
            id: data.id,
            name: data.description
        };
    };
    PPCDataAdaptor.adapt_PPCMoveData_To_PPCElementMove = function (data) {
        return {
            id: data.id,
            category_id: data.category_id,
            type_id: data.type_id,
            name: data.description,
            code: data.code,
            is_combo: data.is_combo,
            is_transition: data.is_transition,
            move_count: data.number_of_combos,
            exclude_from_combos: data.exclude_from_combos,
        };
    };
    PPCDataAdaptor.adapt_IndexedPPCMoveData_To_PPCElementMoveArray = function (data) {
        var result = [];
        for (var i in data) {
            var move_data = data[i];
            result.push(PPCDataAdaptor.adapt_PPCMoveData_To_PPCElementMove(move_data));
        }
        return result;
    };
    PPCDataAdaptor.adapt_PPCIndexedTypesData_To_PPCElementTypeArray = function (data) {
        var result = [];
        for (var i in data) {
            var name = data[i];
            result.push({
                id: parseInt(i),
                name: name
            });
        }
        return result;
    };
    return PPCDataAdaptor;
}());



/***/ }),

/***/ "./src/js/adaptors/PracticeIceSchedulesDataAdaptor.ts":
/*!************************************************************!*\
  !*** ./src/js/adaptors/PracticeIceSchedulesDataAdaptor.ts ***!
  \************************************************************/
/*! exports provided: PracticeIceSchedulesDataAdaptor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PracticeIceSchedulesDataAdaptor", function() { return PracticeIceSchedulesDataAdaptor; });
/* harmony import */ var _models_Competition_CompetitionSchedule__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../models/Competition/CompetitionSchedule */ "./src/js/models/Competition/CompetitionSchedule.ts");
/* harmony import */ var _SessionDataAdaptor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SessionDataAdaptor */ "./src/js/adaptors/SessionDataAdaptor.ts");
/* harmony import */ var _FacilityDataAdaptor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./FacilityDataAdaptor */ "./src/js/adaptors/FacilityDataAdaptor.ts");
/* harmony import */ var _RinkDataAdaptor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./RinkDataAdaptor */ "./src/js/adaptors/RinkDataAdaptor.ts");
/* harmony import */ var _SkaterEventDataAdaptor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./SkaterEventDataAdaptor */ "./src/js/adaptors/SkaterEventDataAdaptor.ts");
/* harmony import */ var _models_Sessions_ScheduledSession__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../models/Sessions/ScheduledSession */ "./src/js/models/Sessions/ScheduledSession.ts");






var PracticeIceSchedulesDataAdaptor = /** @class */ (function () {
    /**
     * Save raw data.  Parse sessions and created indexed session collection
     */
    function PracticeIceSchedulesDataAdaptor(raw_data) {
        this.indexed_sessions = {};
        this.raw_data = raw_data;
        if (!this.dataValid(raw_data)) {
            console.error("Invalid Practice Ice Schedules Data");
            throw "Invalid Practice Ice Schedules Data";
        }
        var sessions = _SessionDataAdaptor__WEBPACK_IMPORTED_MODULE_1__["SessionDataAdaptor"].adaptArray(this.raw_data.competition_schedule.sessions);
        this.sessions_array = sessions;
        this.indexed_sessions = sessions.reduce(function (accumulator, session) {
            accumulator[session.id] = session;
            return accumulator;
        }, {});
    }
    /**
     * Get the CompetitionSchedule from the data
     */
    PracticeIceSchedulesDataAdaptor.prototype.getCompetitionSchedule = function () {
        var competition_data = this.raw_data.competition_schedule;
        var facilities_array = _FacilityDataAdaptor__WEBPACK_IMPORTED_MODULE_2__["FacililtyDataAdaptor"].adaptArray(competition_data.facilities);
        var rinks_array = _RinkDataAdaptor__WEBPACK_IMPORTED_MODULE_3__["RinkDataAdaptor"].adaptFullArray(competition_data.rinks);
        return new _models_Competition_CompetitionSchedule__WEBPACK_IMPORTED_MODULE_0__["CompetitionSchedule"](facilities_array, rinks_array, this.sessions_array);
    };
    /**
     * Get the SkaterScheduleStateArgs from the data
     */
    PracticeIceSchedulesDataAdaptor.prototype.getSkaterScheduleArguments = function () {
        var skater_data = this.raw_data.mapped_skater_schedule;
        return {
            sessions: this.getScheduledSessionsFromMap(skater_data.scheduled_session_maps),
            events: _SkaterEventDataAdaptor__WEBPACK_IMPORTED_MODULE_4__["SkaterEventDataAdaptor"].adaptArray(skater_data.events)
        };
    };
    /**
     * Get the ScheduledSession objects based on the provided map data
     */
    PracticeIceSchedulesDataAdaptor.prototype.getScheduledSessionsFromMap = function (session_map) {
        var self = this;
        return session_map.map(function (data) {
            return self.adaptSkaterScheduledSession(data);
        });
    };
    /**
     * Build a ScheduledSession object from provided data
     */
    PracticeIceSchedulesDataAdaptor.prototype.adaptSkaterScheduledSession = function (scheduled_session_data) {
        var session_instance = this.getSession(scheduled_session_data);
        return new _models_Sessions_ScheduledSession__WEBPACK_IMPORTED_MODULE_5__["ScheduledSession"]({
            session: session_instance,
            scheduled_as: scheduled_session_data.scheduled_as,
            scheduled_event_id: scheduled_session_data.scheduled_event_id
        });
    };
    /**
     * Adapt complete PracticeIceSchedulesData into PracticeIceSchedulesStateArgs
     */
    PracticeIceSchedulesDataAdaptor.adapt = function (raw_data) {
        var instance = new PracticeIceSchedulesDataAdaptor(raw_data);
        return {
            competition_schedule: instance.getCompetitionSchedule(),
            skater_schedule_args: instance.getSkaterScheduleArguments()
        };
    };
    /**
     * Get the full session object from a provided map
     */
    PracticeIceSchedulesDataAdaptor.prototype.getSession = function (scheduled_session_map_data) {
        if (this.indexed_sessions.hasOwnProperty(String(scheduled_session_map_data.session_id))) {
            return this.indexed_sessions[scheduled_session_map_data.session_id];
        }
        console.error('Unable to find complete session data for skater scheduled session map.');
        throw ('Unable to find complete session data for skater scheduled session map.');
    };
    PracticeIceSchedulesDataAdaptor.prototype.dataValid = function (raw_data) {
        var required = {
            competition_schedule: [
                "sessions",
                "facilities",
                "rinks",
            ],
            mapped_skater_schedule: [
                'scheduled_session_maps',
                'events',
            ]
        };
        for (var i in required) {
            var requiredElement = required[i];
            if (!raw_data.hasOwnProperty(i)) {
                return false;
            }
            if (typeof requiredElement === 'object') {
                for (var j = 0; j < requiredElement.length; j++) {
                    var requiredElementElement = requiredElement[j];
                    if (!raw_data[i].hasOwnProperty(requiredElementElement)) {
                        return false;
                    }
                }
            }
        }
        return true;
    };
    return PracticeIceSchedulesDataAdaptor;
}());



/***/ }),

/***/ "./src/js/adaptors/RinkDataAdaptor.ts":
/*!********************************************!*\
  !*** ./src/js/adaptors/RinkDataAdaptor.ts ***!
  \********************************************/
/*! exports provided: RinkDataAdaptor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RinkDataAdaptor", function() { return RinkDataAdaptor; });
/* harmony import */ var _models_Rink__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../models/Rink */ "./src/js/models/Rink.ts");
/* harmony import */ var _FacilityDataAdaptor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./FacilityDataAdaptor */ "./src/js/adaptors/FacilityDataAdaptor.ts");


var RinkDataAdaptor = /** @class */ (function () {
    function RinkDataAdaptor() {
    }
    RinkDataAdaptor.adapt = function (raw_data, facility) {
        return new _models_Rink__WEBPACK_IMPORTED_MODULE_0__["Rink"](raw_data.name, facility, raw_data.id);
    };
    RinkDataAdaptor.adaptFull = function (raw_data) {
        var facility = _FacilityDataAdaptor__WEBPACK_IMPORTED_MODULE_1__["FacililtyDataAdaptor"].adapt(raw_data.facility);
        return RinkDataAdaptor.adapt(raw_data, facility);
    };
    RinkDataAdaptor.adaptFullArray = function (raw_data) {
        var result = [];
        for (var i = 0; i < raw_data.length; i++) {
            var rink = RinkDataAdaptor.adaptFull(raw_data[i]);
            result.push(rink);
        }
        return result;
    };
    return RinkDataAdaptor;
}());



/***/ }),

/***/ "./src/js/adaptors/SalesWindowDataAdaptor.ts":
/*!***************************************************!*\
  !*** ./src/js/adaptors/SalesWindowDataAdaptor.ts ***!
  \***************************************************/
/*! exports provided: SalesWindowDataAdaptor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SalesWindowDataAdaptor", function() { return SalesWindowDataAdaptor; });
/* harmony import */ var _models_SalesWindow__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../models/SalesWindow */ "./src/js/models/SalesWindow.ts");
var __assign = (undefined && undefined.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};

var SalesWindowDataAdaptor = /** @class */ (function () {
    function SalesWindowDataAdaptor() {
    }
    SalesWindowDataAdaptor.adapt = function (raw_data) {
        return new _models_SalesWindow__WEBPACK_IMPORTED_MODULE_0__["SalesWindow"](__assign({}, raw_data, { start_datetime_timestamp: raw_data.start_datetime_timestamp * 1000, end_datetime_timestamp: raw_data.end_datetime_timestamp * 1000 }));
    };
    SalesWindowDataAdaptor.adaptArray = function (raw_data) {
        var result = [];
        for (var i = 0; i < raw_data.length; i++) {
            result.push(SalesWindowDataAdaptor.adapt(raw_data[i]));
        }
        return result;
    };
    return SalesWindowDataAdaptor;
}());



/***/ }),

/***/ "./src/js/adaptors/SessionDataAdaptor.ts":
/*!***********************************************!*\
  !*** ./src/js/adaptors/SessionDataAdaptor.ts ***!
  \***********************************************/
/*! exports provided: SessionDataAdaptor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SessionDataAdaptor", function() { return SessionDataAdaptor; });
/* harmony import */ var _models_Sessions_SkatingEventSession__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../models/Sessions/SkatingEventSession */ "./src/js/models/Sessions/SkatingEventSession.ts");
/* harmony import */ var _models_Sessions_Resurface__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../models/Sessions/Resurface */ "./src/js/models/Sessions/Resurface.ts");
/* harmony import */ var _models_Sessions_PracticeIce__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../models/Sessions/PracticeIce */ "./src/js/models/Sessions/PracticeIce.ts");
/* harmony import */ var _models_Sessions_WarmUp__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../models/Sessions/WarmUp */ "./src/js/models/Sessions/WarmUp.ts");
/* harmony import */ var _models_Sessions_ScheduledSession__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../models/Sessions/ScheduledSession */ "./src/js/models/Sessions/ScheduledSession.ts");
/* harmony import */ var _models_Sessions_CartSession__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../models/Sessions/CartSession */ "./src/js/models/Sessions/CartSession.ts");






var SessionDataAdaptor = /** @class */ (function () {
    function SessionDataAdaptor() {
    }
    /**
     * Adapt a unix timestamp in seconds relative to a source timezone defined by a UTC offset in minutes to ensure date
     * displayed in browser is the source date rather than the localized version of that date.
     *
     * seconds_to_add = (local_utc_offset - source_utc_offset) * 60
     *
     * ex:
     *  - Source timestamp indicating 8am EDT
     *  - Browser localized to MDT
     *
     * 1. Source is UTC +4 (as defined by Date::getTimezoneOffset() in JavaScript) - param timestamp_seconds
     * 2. Local is UTC +6 - determined in method by Date::getTimezoneOffset()
     * 3. Adjustment to source timestamp to display 8am EDT date as 8am in MDT = +2 hours
     *
     * result: Add 2 hours to timestamp to ensure date shows as 8am rather than 6am
     *
     * Note: timezones east of UTC are negative within JavaScript API.  The math still holds, as subtracting a negative
     * number from the local offset increases the overall amount of time added.
     */
    SessionDataAdaptor.adjustLocalTimeRelativeToSourceTimezone = function (timestamp_seconds, source_utc_offset_minutes) {
        var local_utc_offset_minutes = (new Date()).getTimezoneOffset();
        var local_source_offset_difference_minutes = local_utc_offset_minutes - source_utc_offset_minutes;
        var local_adjusted_ts = timestamp_seconds + local_source_offset_difference_minutes * 60;
        return local_adjusted_ts;
    };
    /**
     * Adapt a unix timestamp in seconds to a unix timestamp in milliseconds
     */
    SessionDataAdaptor.adaptTimestamp = function (timestamp_seconds) {
        return timestamp_seconds * 1000;
    };
    SessionDataAdaptor.adaptArray = function (raw_data) {
        var results = [];
        for (var i = 0; i < raw_data.length; i++) {
            var obj = raw_data[i];
            results.push(SessionDataAdaptor.adapt(obj));
        }
        return results;
    };
    SessionDataAdaptor.adapt = function (raw_data) {
        raw_data.date = SessionDataAdaptor.adaptTimestamp(SessionDataAdaptor.adjustLocalTimeRelativeToSourceTimezone(raw_data.date, raw_data.utc_timezone_offset));
        raw_data.time_end = SessionDataAdaptor.adaptTimestamp(SessionDataAdaptor.adjustLocalTimeRelativeToSourceTimezone(raw_data.time_end, raw_data.utc_timezone_offset));
        raw_data.time_start = SessionDataAdaptor.adaptTimestamp(SessionDataAdaptor.adjustLocalTimeRelativeToSourceTimezone(raw_data.time_start, raw_data.utc_timezone_offset));
        switch (raw_data.type_key) {
            case 'event': {
                return SessionDataAdaptor.adaptEventSession(raw_data);
            }
            case 'resurface': {
                return SessionDataAdaptor.adaptResurface(raw_data);
            }
            case 'practice_ice': {
                return SessionDataAdaptor.adaptPracticeIce(raw_data);
            }
            case 'warm_up': {
                return SessionDataAdaptor.adaptWarmUp(raw_data);
            }
        }
    };
    SessionDataAdaptor.adaptEventSession = function (raw_data) {
        return new _models_Sessions_SkatingEventSession__WEBPACK_IMPORTED_MODULE_0__["SkatingEventSession"](raw_data);
    };
    SessionDataAdaptor.adaptResurface = function (raw_data) {
        return new _models_Sessions_Resurface__WEBPACK_IMPORTED_MODULE_1__["Resurface"](raw_data);
    };
    SessionDataAdaptor.adaptPracticeIce = function (raw_data) {
        return new _models_Sessions_PracticeIce__WEBPACK_IMPORTED_MODULE_2__["PracticeIce"](raw_data);
    };
    SessionDataAdaptor.adaptWarmUp = function (raw_data) {
        return new _models_Sessions_WarmUp__WEBPACK_IMPORTED_MODULE_3__["WarmUp"](raw_data);
    };
    SessionDataAdaptor.adaptScheduled = function (raw_data) {
        var session = SessionDataAdaptor.adapt(raw_data.session);
        return new _models_Sessions_ScheduledSession__WEBPACK_IMPORTED_MODULE_4__["ScheduledSession"]({
            session: session,
            scheduled_as: raw_data.scheduled_as,
            scheduled_event_id: raw_data.scheduled_event_id
        });
    };
    SessionDataAdaptor.adaptScheduledArray = function (raw_data) {
        var result = [];
        for (var i = 0; i < raw_data.length; i++) {
            result.push(SessionDataAdaptor.adaptScheduled(raw_data[i]));
        }
        return result;
    };
    SessionDataAdaptor.adaptCartSession = function (raw_data) {
        var session = SessionDataAdaptor.adapt(raw_data.session);
        return new _models_Sessions_CartSession__WEBPACK_IMPORTED_MODULE_5__["CartSession"]({
            session: session,
            scheduled_as: raw_data.scheduled_as,
            scheduled_event_id: raw_data.scheduled_event_id,
            cost: raw_data.cost,
            competition_id: raw_data.competition_id,
            competition_name: raw_data.competition_name,
            scheduled_event_name: raw_data.scheduled_event_name,
        });
    };
    return SessionDataAdaptor;
}());



/***/ }),

/***/ "./src/js/adaptors/SkaterCreditDataAdaptor.ts":
/*!****************************************************!*\
  !*** ./src/js/adaptors/SkaterCreditDataAdaptor.ts ***!
  \****************************************************/
/*! exports provided: SkaterCreditDataAdaptor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SkaterCreditDataAdaptor", function() { return SkaterCreditDataAdaptor; });
/* harmony import */ var _models_Credits_SkaterEventCredits__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../models/Credits/SkaterEventCredits */ "./src/js/models/Credits/SkaterEventCredits.ts");
/* harmony import */ var _models_Credits_CreditsCollection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../models/Credits/CreditsCollection */ "./src/js/models/Credits/CreditsCollection.ts");
/* harmony import */ var _models_Credits_SkaterCredits__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../models/Credits/SkaterCredits */ "./src/js/models/Credits/SkaterCredits.ts");



var SkaterCreditDataAdaptor = /** @class */ (function () {
    function SkaterCreditDataAdaptor() {
    }
    SkaterCreditDataAdaptor.adaptEventCredits = function (raw_data) {
        var event_id = raw_data.event_id;
        var total_credits = raw_data.total;
        var scheduled_credits = raw_data.scheduled;
        return new _models_Credits_SkaterEventCredits__WEBPACK_IMPORTED_MODULE_0__["SkaterEventCredits"](event_id, new _models_Credits_CreditsCollection__WEBPACK_IMPORTED_MODULE_1__["CreditsCollection"](total_credits), new _models_Credits_CreditsCollection__WEBPACK_IMPORTED_MODULE_1__["CreditsCollection"](scheduled_credits));
    };
    SkaterCreditDataAdaptor.adaptCompetitionCredits = function (raw_data) {
        var result = [];
        for (var i = 0; i < raw_data.event_credits.length; i++) {
            result.push(SkaterCreditDataAdaptor.adaptEventCredits(raw_data.event_credits[i]));
        }
        return new _models_Credits_SkaterCredits__WEBPACK_IMPORTED_MODULE_2__["SkaterCredits"](result, raw_data.purchased_package_ids);
    };
    return SkaterCreditDataAdaptor;
}());



/***/ }),

/***/ "./src/js/adaptors/SkaterEventDataAdaptor.ts":
/*!***************************************************!*\
  !*** ./src/js/adaptors/SkaterEventDataAdaptor.ts ***!
  \***************************************************/
/*! exports provided: SkaterEventDataAdaptor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SkaterEventDataAdaptor", function() { return SkaterEventDataAdaptor; });
/* harmony import */ var _models_SkatingEvent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../models/SkatingEvent */ "./src/js/models/SkatingEvent.ts");
/* harmony import */ var _models_SkaterCoachedEventCategory__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../models/SkaterCoachedEventCategory */ "./src/js/models/SkaterCoachedEventCategory.ts");


var SkaterEventDataAdaptor = /** @class */ (function () {
    function SkaterEventDataAdaptor() {
    }
    SkaterEventDataAdaptor.adapt = function (raw_data) {
        return new _models_SkatingEvent__WEBPACK_IMPORTED_MODULE_0__["SkatingEvent"](raw_data.id, raw_data.name, raw_data.competition_id);
    };
    SkaterEventDataAdaptor.adaptArray = function (raw_data) {
        var result = [];
        for (var i = 0; i < raw_data.length; i++) {
            result.push(SkaterEventDataAdaptor.adapt(raw_data[i]));
        }
        return result;
    };
    SkaterEventDataAdaptor.adaptCoachedEvent = function (raw_data) {
        return new _models_SkaterCoachedEventCategory__WEBPACK_IMPORTED_MODULE_1__["SkaterCoachedEventCategory"]({
            id: raw_data.id,
            name: raw_data.name,
            coach_limit: raw_data.coach_limit,
            coaches: SkaterEventDataAdaptor.adaptEventCoachArray(raw_data.coaches)
        });
    };
    SkaterEventDataAdaptor.adaptEventCoach = function (raw_data) {
        return {
            id: raw_data.id,
            first_name: raw_data.first_name,
            last_name: raw_data.last_name,
            ineligible: raw_data.ineligible,
        };
    };
    SkaterEventDataAdaptor.adaptEventCoachArray = function (raw_data) {
        var result = [];
        for (var i = 0; i < raw_data.length; i++) {
            var obj = raw_data[i];
            result.push(SkaterEventDataAdaptor.adaptEventCoach(obj));
        }
        return result;
    };
    SkaterEventDataAdaptor.adaptCoachedEventArray = function (raw_data) {
        var result = [];
        for (var i = 0; i < raw_data.length; i++) {
            var obj = raw_data[i];
            result.push(SkaterEventDataAdaptor.adaptCoachedEvent(obj));
        }
        return result;
    };
    return SkaterEventDataAdaptor;
}());



/***/ }),

/***/ "./src/js/adaptors/SkaterInfoDataAdaptor.ts":
/*!**************************************************!*\
  !*** ./src/js/adaptors/SkaterInfoDataAdaptor.ts ***!
  \**************************************************/
/*! exports provided: SkaterInfoDataAdaptor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SkaterInfoDataAdaptor", function() { return SkaterInfoDataAdaptor; });
/**
 * @deprecated 5/27/19 - this returned basic name and address info and has been superseded by User Profile info
 */
var SkaterInfoDataAdaptor = /** @class */ (function () {
    function SkaterInfoDataAdaptor() {
    }
    SkaterInfoDataAdaptor.adapt = function (raw_data) {
        return {
            first_name: raw_data.first_name,
            last_name: raw_data.last_name,
            address: {
                street: raw_data.address.street,
                street_2: raw_data.address.street_2 ? raw_data.address.street_2 : null,
                city: raw_data.address.city,
                state: raw_data.address.state,
                zip_code: raw_data.address.zip_code,
            }
        };
    };
    return SkaterInfoDataAdaptor;
}());



/***/ }),

/***/ "./src/js/adaptors/SkaterSkatingEventSegmentAdaptor.ts":
/*!*************************************************************!*\
  !*** ./src/js/adaptors/SkaterSkatingEventSegmentAdaptor.ts ***!
  \*************************************************************/
/*! exports provided: SkaterSkatingEventSegmentAdaptor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SkaterSkatingEventSegmentAdaptor", function() { return SkaterSkatingEventSegmentAdaptor; });
/* harmony import */ var _models_SkaterSkatingEventSegment__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../models/SkaterSkatingEventSegment */ "./src/js/models/SkaterSkatingEventSegment.ts");

var SkaterSkatingEventSegmentAdaptor = /** @class */ (function () {
    function SkaterSkatingEventSegmentAdaptor() {
    }
    SkaterSkatingEventSegmentAdaptor.adaptArray = function (raw_data) {
        return raw_data.map(function (raw_datum) {
            return SkaterSkatingEventSegmentAdaptor.adapt(raw_datum);
        });
    };
    SkaterSkatingEventSegmentAdaptor.adaptEventSegmentsData = function (raw_data) {
        if (raw_data.skater_event_segments && typeof raw_data.skater_event_segments === "object") {
            return SkaterSkatingEventSegmentAdaptor.adaptArray(raw_data.skater_event_segments);
        }
        throw ("Invalid event segment data");
    };
    SkaterSkatingEventSegmentAdaptor.adapt = function (raw_data) {
        var required_fields = [
            'event_name',
            'segment_name',
            'event_id',
            'segment_id',
            'ppc_required',
            'music_required',
            'rhythm_required',
            'theme_required',
            'is_ppc_complete',
            'is_music_complete',
            'is_rhythm_complete',
            'is_theme_complete',
            'competition_skated_event_id',
            'ppc_last_modified_timestamp',
            'music_last_modified_timestamp',
            'rhythms',
            'theme' // @downstream-sync 2020-07-02 - import rhythm/theme feature
        ];
        for (var i = 0; i < required_fields.length; i++) {
            var param = required_fields[i];
            if (!(param in raw_data)) {
                throw ("Invalid event segment data");
            }
        }
        var args = {
            event_name: raw_data.event_name,
            segment_name: raw_data.segment_name,
            event_id: raw_data.event_id,
            segment_id: raw_data.segment_id,
            ppc_required: raw_data.ppc_required,
            music_required: raw_data.music_required,
            rhythm_required: raw_data.rhythm_required,
            theme_required: raw_data.theme_required,
            is_ppc_complete: raw_data.is_ppc_complete,
            is_music_complete: raw_data.is_music_complete,
            is_rhythm_complete: raw_data.is_rhythm_complete,
            is_theme_complete: raw_data.is_theme_complete,
            ppc_last_modified_timestamp: raw_data.ppc_last_modified_timestamp ? raw_data.ppc_last_modified_timestamp * 1000 : null,
            music_last_modified_timestamp: raw_data.music_last_modified_timestamp ? raw_data.music_last_modified_timestamp * 1000 : null,
            competition_skated_event_id: raw_data.competition_skated_event_id,
            rhythms: raw_data.rhythms,
            theme: raw_data.theme // @downstream-sync 2020-07-02 - import rhythm/theme feature
        };
        return new _models_SkaterSkatingEventSegment__WEBPACK_IMPORTED_MODULE_0__["SkaterSkatingEventSegment"](args);
    };
    return SkaterSkatingEventSegmentAdaptor;
}());



/***/ }),

/***/ "./src/js/adaptors/SkatingEventDataAdaptor.ts":
/*!****************************************************!*\
  !*** ./src/js/adaptors/SkatingEventDataAdaptor.ts ***!
  \****************************************************/
/*! exports provided: DefaultCreditRules, SkatingEventCreditConfigDataAdaptor, SkatingEventDataAdaptor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DefaultCreditRules", function() { return DefaultCreditRules; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SkatingEventCreditConfigDataAdaptor", function() { return SkatingEventCreditConfigDataAdaptor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SkatingEventDataAdaptor", function() { return SkatingEventDataAdaptor; });
/* harmony import */ var _models_SkatingEvent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../models/SkatingEvent */ "./src/js/models/SkatingEvent.ts");
/* harmony import */ var _models_Credits_CreditPackage__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../models/Credits/CreditPackage */ "./src/js/models/Credits/CreditPackage.ts");


var DefaultCreditRules = /** @class */ (function () {
    function DefaultCreditRules() {
        this.opi = new _models_SkatingEvent__WEBPACK_IMPORTED_MODULE_0__["CreditRule"]("opi", 0, 0);
        this.upi = new _models_SkatingEvent__WEBPACK_IMPORTED_MODULE_0__["CreditRule"]("upi", 0, 0);
        this.wu = new _models_SkatingEvent__WEBPACK_IMPORTED_MODULE_0__["CreditRule"]("wu", 0, 0);
    }
    return DefaultCreditRules;
}());

var SkatingEventCreditConfigDataAdaptor = /** @class */ (function () {
    function SkatingEventCreditConfigDataAdaptor() {
    }
    SkatingEventCreditConfigDataAdaptor.adapt = function (raw_data) {
        var default_rules = new DefaultCreditRules();
        for (var i = 0; i < raw_data.length; i++) {
            var config = raw_data[i];
            default_rules[config.key] = new _models_SkatingEvent__WEBPACK_IMPORTED_MODULE_0__["CreditRule"](config.key, config.cost, config.limit);
        }
        return new _models_SkatingEvent__WEBPACK_IMPORTED_MODULE_0__["CreditRules"](default_rules.opi, default_rules.upi, default_rules.wu);
    };
    return SkatingEventCreditConfigDataAdaptor;
}());

var SkatingEventDataAdaptor = /** @class */ (function () {
    function SkatingEventDataAdaptor() {
    }
    SkatingEventDataAdaptor.adaptCreditPackageData = function (raw_data) {
        return new _models_Credits_CreditPackage__WEBPACK_IMPORTED_MODULE_1__["CreditPackage"]({
            cost: raw_data.cost,
            limit: raw_data.limit,
            id: raw_data.id,
            event_id: raw_data.event_id,
            credits: raw_data.credits
        });
    };
    SkatingEventDataAdaptor.adaptCreditPackageDataArray = function (raw_data) {
        if (raw_data && raw_data.length) {
            return raw_data.map(function (raw_datum) {
                return SkatingEventDataAdaptor.adaptCreditPackageData(raw_datum);
            });
        }
        return [];
    };
    SkatingEventDataAdaptor.adapt = function (raw_data) {
        return new _models_SkatingEvent__WEBPACK_IMPORTED_MODULE_0__["SkatingEvent"](raw_data.id, raw_data.name, raw_data.competition_id, SkatingEventCreditConfigDataAdaptor.adapt(raw_data.credit_config), SkatingEventDataAdaptor.adaptCreditPackageDataArray(raw_data.credit_packages));
    };
    SkatingEventDataAdaptor.adaptArray = function (raw_data) {
        var result = [];
        for (var i = 0; i < raw_data.length; i++) {
            result.push(SkatingEventDataAdaptor.adapt(raw_data[i]));
        }
        return result;
    };
    return SkatingEventDataAdaptor;
}());



/***/ }),

/***/ "./src/js/adaptors/UserDataAdaptor.ts":
/*!********************************************!*\
  !*** ./src/js/adaptors/UserDataAdaptor.ts ***!
  \********************************************/
/*! exports provided: UserAdaptor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UserAdaptor", function() { return UserAdaptor; });
/* harmony import */ var _models_User__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../models/User */ "./src/js/models/User.ts");

var UserAdaptor = /** @class */ (function () {
    function UserAdaptor() {
    }
    UserAdaptor.adaptUser = function (raw_data) {
        var required_props = ['roles', 'upload_file_capability', 'member_number', 'email'];
        for (var i = 0; i < required_props.length; i++) {
            var prop = required_props[i];
            if (!(prop in raw_data)) {
                throw "Invalid user data";
            }
        }
        var sub_props = ["can_upload", "error_message"];
        for (var i = 0; i < sub_props.length; i++) {
            var prop = sub_props[i];
            if (!(prop in raw_data.upload_file_capability)) {
                throw "Invalid user data";
            }
        }
        if (typeof raw_data.upload_file_capability.can_upload === "string") {
            raw_data.upload_file_capability.can_upload = raw_data.upload_file_capability.can_upload === "true";
        }
        var valid_user_roles = ["skater", "coach", 'team_manager'];
        var user_roles = [];
        for (var i = 0; i < raw_data.roles.length; i++) {
            var data_type = raw_data.roles[i];
            if (valid_user_roles.indexOf(data_type) !== -1) {
                user_roles.push(data_type);
            }
        }
        var args = {
            roles: user_roles,
            upload_file_capability: {
                can_upload: raw_data.upload_file_capability.can_upload,
                error_message: raw_data.upload_file_capability.error_message
            },
            member_number: typeof raw_data.member_number !== 'number' ? parseInt(raw_data.member_number) : raw_data.member_number,
            email: raw_data.email
        };
        return new _models_User__WEBPACK_IMPORTED_MODULE_0__["User"](args);
    };
    return UserAdaptor;
}());



/***/ }),

/***/ "./src/js/competition-registration.ts":
/*!********************************************!*\
  !*** ./src/js/competition-registration.ts ***!
  \********************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var es6_promise_auto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! es6-promise/auto */ "./node_modules/es6-promise/auto.js");
/* harmony import */ var es6_promise_auto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(es6_promise_auto__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
/* harmony import */ var _pages_CompetitionRegistration_CompetitionRegistrationIndex_vue__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./pages/CompetitionRegistration/CompetitionRegistrationIndex.vue */ "./src/js/pages/CompetitionRegistration/CompetitionRegistrationIndex.vue");
/* harmony import */ var _pages_CompetitionRegistration_CompetitionRegistrationOverview_vue__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./pages/CompetitionRegistration/CompetitionRegistrationOverview.vue */ "./src/js/pages/CompetitionRegistration/CompetitionRegistrationOverview.vue");
/* harmony import */ var _pages_CompetitionRegistration_CompetitionRegistrationSkaterProfile_vue__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./pages/CompetitionRegistration/CompetitionRegistrationSkaterProfile.vue */ "./src/js/pages/CompetitionRegistration/CompetitionRegistrationSkaterProfile.vue");
/* harmony import */ var _pages_CompetitionRegistration_CompetitionRegistrationSkateTests_vue__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./pages/CompetitionRegistration/CompetitionRegistrationSkateTests.vue */ "./src/js/pages/CompetitionRegistration/CompetitionRegistrationSkateTests.vue");
/* harmony import */ var _pages_CompetitionRegistration_CompetitionRegistrationPartnerEvents_vue__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./pages/CompetitionRegistration/CompetitionRegistrationPartnerEvents.vue */ "./src/js/pages/CompetitionRegistration/CompetitionRegistrationPartnerEvents.vue");
/* harmony import */ var _pages_CompetitionRegistration_CompetitionRegistrationPartnerIdentification_vue__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./pages/CompetitionRegistration/CompetitionRegistrationPartnerIdentification.vue */ "./src/js/pages/CompetitionRegistration/CompetitionRegistrationPartnerIdentification.vue");
/* harmony import */ var _pages_CompetitionRegistration_CompetitionRegistrationEventSelection_vue__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./pages/CompetitionRegistration/CompetitionRegistrationEventSelection.vue */ "./src/js/pages/CompetitionRegistration/CompetitionRegistrationEventSelection.vue");
/* harmony import */ var _pages_CompetitionRegistration_CompetitionRegistrationCoachInformation_vue__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./pages/CompetitionRegistration/CompetitionRegistrationCoachInformation.vue */ "./src/js/pages/CompetitionRegistration/CompetitionRegistrationCoachInformation.vue");
/* harmony import */ var _pages_CompetitionRegistration_CompetitionRegistrationWaivers_vue__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./pages/CompetitionRegistration/CompetitionRegistrationWaivers.vue */ "./src/js/pages/CompetitionRegistration/CompetitionRegistrationWaivers.vue");
/* harmony import */ var _components_SkateTestHistory_SkateTestHistory_vue__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./components/SkateTestHistory/SkateTestHistory.vue */ "./src/js/components/SkateTestHistory/SkateTestHistory.vue");
/* harmony import */ var _components_DateInput_vue__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./components/DateInput.vue */ "./src/js/components/DateInput.vue");
/* harmony import */ var _components_CompetitionRegistration_CompetitionRegistrationProgress_vue__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./components/CompetitionRegistration/CompetitionRegistrationProgress.vue */ "./src/js/components/CompetitionRegistration/CompetitionRegistrationProgress.vue");
/* harmony import */ var _components_SkateTestEquivalency_DisciplineForm_vue__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./components/SkateTestEquivalency/DisciplineForm.vue */ "./src/js/components/SkateTestEquivalency/DisciplineForm.vue");
/* harmony import */ var _components_CompetitionRegistration_EventRequirementsOverlay_vue__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./components/CompetitionRegistration/EventRequirementsOverlay.vue */ "./src/js/components/CompetitionRegistration/EventRequirementsOverlay.vue");
/* harmony import */ var _store__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./store */ "./src/js/store/index.ts");
/* harmony import */ var _store_CompetitionRegistration_CompetitionRegistrationState__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./store/CompetitionRegistration/CompetitionRegistrationState */ "./src/js/store/CompetitionRegistration/CompetitionRegistrationState.ts");
/* harmony import */ var _store_Modules_FormOptionsState__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./store/Modules/FormOptionsState */ "./src/js/store/Modules/FormOptionsState.ts");


/**
 * Page Components
 */









/**
 * Abstract Components
 */





/**
 * State Management
 */



/**
 * Pages
 */
vue__WEBPACK_IMPORTED_MODULE_1__["default"].component('competition-registration-index', _pages_CompetitionRegistration_CompetitionRegistrationIndex_vue__WEBPACK_IMPORTED_MODULE_2__["default"]);
vue__WEBPACK_IMPORTED_MODULE_1__["default"].component('competition-registration-overview', _pages_CompetitionRegistration_CompetitionRegistrationOverview_vue__WEBPACK_IMPORTED_MODULE_3__["default"]);
vue__WEBPACK_IMPORTED_MODULE_1__["default"].component('competition-registration-skater-profile', _pages_CompetitionRegistration_CompetitionRegistrationSkaterProfile_vue__WEBPACK_IMPORTED_MODULE_4__["default"]);
vue__WEBPACK_IMPORTED_MODULE_1__["default"].component('competition-registration-skate-tests', _pages_CompetitionRegistration_CompetitionRegistrationSkateTests_vue__WEBPACK_IMPORTED_MODULE_5__["default"]);
vue__WEBPACK_IMPORTED_MODULE_1__["default"].component('competition-registration-partner-events', _pages_CompetitionRegistration_CompetitionRegistrationPartnerEvents_vue__WEBPACK_IMPORTED_MODULE_6__["default"]);
vue__WEBPACK_IMPORTED_MODULE_1__["default"].component('competition-registration-partner-identification', _pages_CompetitionRegistration_CompetitionRegistrationPartnerIdentification_vue__WEBPACK_IMPORTED_MODULE_7__["default"]);
vue__WEBPACK_IMPORTED_MODULE_1__["default"].component('competition-registration-event-selection', _pages_CompetitionRegistration_CompetitionRegistrationEventSelection_vue__WEBPACK_IMPORTED_MODULE_8__["default"]);
vue__WEBPACK_IMPORTED_MODULE_1__["default"].component('competition-registration-coach-information', _pages_CompetitionRegistration_CompetitionRegistrationCoachInformation_vue__WEBPACK_IMPORTED_MODULE_9__["default"]);
vue__WEBPACK_IMPORTED_MODULE_1__["default"].component('competition-registration-waivers', _pages_CompetitionRegistration_CompetitionRegistrationWaivers_vue__WEBPACK_IMPORTED_MODULE_10__["default"]);
/**
 * Components
 */
vue__WEBPACK_IMPORTED_MODULE_1__["default"].component('skate-test-history', _components_SkateTestHistory_SkateTestHistory_vue__WEBPACK_IMPORTED_MODULE_11__["default"]);
vue__WEBPACK_IMPORTED_MODULE_1__["default"].component('date-input', _components_DateInput_vue__WEBPACK_IMPORTED_MODULE_12__["default"]);
vue__WEBPACK_IMPORTED_MODULE_1__["default"].component('competition-registration-progress', _components_CompetitionRegistration_CompetitionRegistrationProgress_vue__WEBPACK_IMPORTED_MODULE_13__["default"]);
vue__WEBPACK_IMPORTED_MODULE_1__["default"].component('skate-test-discipline-form', _components_SkateTestEquivalency_DisciplineForm_vue__WEBPACK_IMPORTED_MODULE_14__["default"]);
vue__WEBPACK_IMPORTED_MODULE_1__["default"].component('event-requirements-overlay', _components_CompetitionRegistration_EventRequirementsOverlay_vue__WEBPACK_IMPORTED_MODULE_15__["default"]);
/**
 * State
 */
_store__WEBPACK_IMPORTED_MODULE_16__["default"].registerModule('competition_registration', _store_CompetitionRegistration_CompetitionRegistrationState__WEBPACK_IMPORTED_MODULE_17__["CompetitionRegistrationState"]);
_store__WEBPACK_IMPORTED_MODULE_16__["default"].registerModule('form_options', _store_Modules_FormOptionsState__WEBPACK_IMPORTED_MODULE_18__["FormOptionsState"]);


/***/ }),

/***/ "./src/js/components/AutoSuggest.vue":
/*!*******************************************!*\
  !*** ./src/js/components/AutoSuggest.vue ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _AutoSuggest_vue_vue_type_template_id_7e45a639___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AutoSuggest.vue?vue&type=template&id=7e45a639& */ "./src/js/components/AutoSuggest.vue?vue&type=template&id=7e45a639&");
/* harmony import */ var _AutoSuggest_vue_vue_type_script_lang_ts___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./AutoSuggest.vue?vue&type=script&lang=ts& */ "./src/js/components/AutoSuggest.vue?vue&type=script&lang=ts&");
/* empty/unused harmony star reexport *//* harmony import */ var _node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js */ "./node_modules/vue-loader/lib/runtime/componentNormalizer.js");





/* normalize component */

var component = Object(_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_2__["default"])(
  _AutoSuggest_vue_vue_type_script_lang_ts___WEBPACK_IMPORTED_MODULE_1__["default"],
  _AutoSuggest_vue_vue_type_template_id_7e45a639___WEBPACK_IMPORTED_MODULE_0__["render"],
  _AutoSuggest_vue_vue_type_template_id_7e45a639___WEBPACK_IMPORTED_MODULE_0__["staticRenderFns"],
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var api; }
component.options.__file = "src/js/components/AutoSuggest.vue"
/* harmony default export */ __webpack_exports__["default"] = (component.exports);

/***/ }),

/***/ "./src/js/components/AutoSuggest.vue?vue&type=script&lang=ts&":
/*!********************************************************************!*\
  !*** ./src/js/components/AutoSuggest.vue?vue&type=script&lang=ts& ***!
  \********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_ts_loader_index_js_ref_5_node_modules_vue_loader_lib_index_js_vue_loader_options_AutoSuggest_vue_vue_type_script_lang_ts___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/ts-loader??ref--5!../../../node_modules/vue-loader/lib??vue-loader-options!./AutoSuggest.vue?vue&type=script&lang=ts& */ "./node_modules/ts-loader/index.js?!./node_modules/vue-loader/lib/index.js?!./src/js/components/AutoSuggest.vue?vue&type=script&lang=ts&");
/* empty/unused harmony star reexport */ /* harmony default export */ __webpack_exports__["default"] = (_node_modules_ts_loader_index_js_ref_5_node_modules_vue_loader_lib_index_js_vue_loader_options_AutoSuggest_vue_vue_type_script_lang_ts___WEBPACK_IMPORTED_MODULE_0__["default"]); 

/***/ }),

/***/ "./src/js/components/AutoSuggest.vue?vue&type=template&id=7e45a639&":
/*!**************************************************************************!*\
  !*** ./src/js/components/AutoSuggest.vue?vue&type=template&id=7e45a639& ***!
  \**************************************************************************/
/*! exports provided: render, staticRenderFns */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_AutoSuggest_vue_vue_type_template_id_7e45a639___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!../../../node_modules/vue-loader/lib??vue-loader-options!./AutoSuggest.vue?vue&type=template&id=7e45a639& */ "./node_modules/vue-loader/lib/loaders/templateLoader.js?!./node_modules/vue-loader/lib/index.js?!./src/js/components/AutoSuggest.vue?vue&type=template&id=7e45a639&");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "render", function() { return _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_AutoSuggest_vue_vue_type_template_id_7e45a639___WEBPACK_IMPORTED_MODULE_0__["render"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "staticRenderFns", function() { return _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_AutoSuggest_vue_vue_type_template_id_7e45a639___WEBPACK_IMPORTED_MODULE_0__["staticRenderFns"]; });



/***/ }),

/***/ "./src/js/components/CompetitionRegistration/CompetitionRegistrationProgress.vue":
/*!***************************************************************************************!*\
  !*** ./src/js/components/CompetitionRegistration/CompetitionRegistrationProgress.vue ***!
  \***************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _CompetitionRegistrationProgress_vue_vue_type_template_id_13ec7932___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CompetitionRegistrationProgress.vue?vue&type=template&id=13ec7932& */ "./src/js/components/CompetitionRegistration/CompetitionRegistrationProgress.vue?vue&type=template&id=13ec7932&");
/* harmony import */ var _CompetitionRegistrationProgress_vue_vue_type_script_lang_ts___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./CompetitionRegistrationProgress.vue?vue&type=script&lang=ts& */ "./src/js/components/CompetitionRegistration/CompetitionRegistrationProgress.vue?vue&type=script&lang=ts&");
/* empty/unused harmony star reexport *//* harmony import */ var _node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js */ "./node_modules/vue-loader/lib/runtime/componentNormalizer.js");





/* normalize component */

var component = Object(_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_2__["default"])(
  _CompetitionRegistrationProgress_vue_vue_type_script_lang_ts___WEBPACK_IMPORTED_MODULE_1__["default"],
  _CompetitionRegistrationProgress_vue_vue_type_template_id_13ec7932___WEBPACK_IMPORTED_MODULE_0__["render"],
  _CompetitionRegistrationProgress_vue_vue_type_template_id_13ec7932___WEBPACK_IMPORTED_MODULE_0__["staticRenderFns"],
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var api; }
component.options.__file = "src/js/components/CompetitionRegistration/CompetitionRegistrationProgress.vue"
/* harmony default export */ __webpack_exports__["default"] = (component.exports);

/***/ }),

/***/ "./src/js/components/CompetitionRegistration/CompetitionRegistrationProgress.vue?vue&type=script&lang=ts&":
/*!****************************************************************************************************************!*\
  !*** ./src/js/components/CompetitionRegistration/CompetitionRegistrationProgress.vue?vue&type=script&lang=ts& ***!
  \****************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_ts_loader_index_js_ref_5_node_modules_vue_loader_lib_index_js_vue_loader_options_CompetitionRegistrationProgress_vue_vue_type_script_lang_ts___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../node_modules/ts-loader??ref--5!../../../../node_modules/vue-loader/lib??vue-loader-options!./CompetitionRegistrationProgress.vue?vue&type=script&lang=ts& */ "./node_modules/ts-loader/index.js?!./node_modules/vue-loader/lib/index.js?!./src/js/components/CompetitionRegistration/CompetitionRegistrationProgress.vue?vue&type=script&lang=ts&");
/* empty/unused harmony star reexport */ /* harmony default export */ __webpack_exports__["default"] = (_node_modules_ts_loader_index_js_ref_5_node_modules_vue_loader_lib_index_js_vue_loader_options_CompetitionRegistrationProgress_vue_vue_type_script_lang_ts___WEBPACK_IMPORTED_MODULE_0__["default"]); 

/***/ }),

/***/ "./src/js/components/CompetitionRegistration/CompetitionRegistrationProgress.vue?vue&type=template&id=13ec7932&":
/*!**********************************************************************************************************************!*\
  !*** ./src/js/components/CompetitionRegistration/CompetitionRegistrationProgress.vue?vue&type=template&id=13ec7932& ***!
  \**********************************************************************************************************************/
/*! exports provided: render, staticRenderFns */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_CompetitionRegistrationProgress_vue_vue_type_template_id_13ec7932___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!../../../../node_modules/vue-loader/lib??vue-loader-options!./CompetitionRegistrationProgress.vue?vue&type=template&id=13ec7932& */ "./node_modules/vue-loader/lib/loaders/templateLoader.js?!./node_modules/vue-loader/lib/index.js?!./src/js/components/CompetitionRegistration/CompetitionRegistrationProgress.vue?vue&type=template&id=13ec7932&");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "render", function() { return _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_CompetitionRegistrationProgress_vue_vue_type_template_id_13ec7932___WEBPACK_IMPORTED_MODULE_0__["render"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "staticRenderFns", function() { return _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_CompetitionRegistrationProgress_vue_vue_type_template_id_13ec7932___WEBPACK_IMPORTED_MODULE_0__["staticRenderFns"]; });



/***/ }),

/***/ "./src/js/components/CompetitionRegistration/CompetitionSearch.vue":
/*!*************************************************************************!*\
  !*** ./src/js/components/CompetitionRegistration/CompetitionSearch.vue ***!
  \*************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _CompetitionSearch_vue_vue_type_script_lang_ts___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CompetitionSearch.vue?vue&type=script&lang=ts& */ "./src/js/components/CompetitionRegistration/CompetitionSearch.vue?vue&type=script&lang=ts&");
/* empty/unused harmony star reexport *//* harmony import */ var _node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js */ "./node_modules/vue-loader/lib/runtime/componentNormalizer.js");
var render, staticRenderFns




/* normalize component */

var component = Object(_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_1__["default"])(
  _CompetitionSearch_vue_vue_type_script_lang_ts___WEBPACK_IMPORTED_MODULE_0__["default"],
  render,
  staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var api; }
component.options.__file = "src/js/components/CompetitionRegistration/CompetitionSearch.vue"
/* harmony default export */ __webpack_exports__["default"] = (component.exports);

/***/ }),

/***/ "./src/js/components/CompetitionRegistration/CompetitionSearch.vue?vue&type=script&lang=ts&":
/*!**************************************************************************************************!*\
  !*** ./src/js/components/CompetitionRegistration/CompetitionSearch.vue?vue&type=script&lang=ts& ***!
  \**************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_ts_loader_index_js_ref_5_node_modules_vue_loader_lib_index_js_vue_loader_options_CompetitionSearch_vue_vue_type_script_lang_ts___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../node_modules/ts-loader??ref--5!../../../../node_modules/vue-loader/lib??vue-loader-options!./CompetitionSearch.vue?vue&type=script&lang=ts& */ "./node_modules/ts-loader/index.js?!./node_modules/vue-loader/lib/index.js?!./src/js/components/CompetitionRegistration/CompetitionSearch.vue?vue&type=script&lang=ts&");
/* empty/unused harmony star reexport */ /* harmony default export */ __webpack_exports__["default"] = (_node_modules_ts_loader_index_js_ref_5_node_modules_vue_loader_lib_index_js_vue_loader_options_CompetitionSearch_vue_vue_type_script_lang_ts___WEBPACK_IMPORTED_MODULE_0__["default"]); 

/***/ }),

/***/ "./src/js/components/CompetitionRegistration/EventRequirementsOverlay.vue":
/*!********************************************************************************!*\
  !*** ./src/js/components/CompetitionRegistration/EventRequirementsOverlay.vue ***!
  \********************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _EventRequirementsOverlay_vue_vue_type_template_id_45298f29___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./EventRequirementsOverlay.vue?vue&type=template&id=45298f29& */ "./src/js/components/CompetitionRegistration/EventRequirementsOverlay.vue?vue&type=template&id=45298f29&");
/* harmony import */ var _EventRequirementsOverlay_vue_vue_type_script_lang_ts___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./EventRequirementsOverlay.vue?vue&type=script&lang=ts& */ "./src/js/components/CompetitionRegistration/EventRequirementsOverlay.vue?vue&type=script&lang=ts&");
/* empty/unused harmony star reexport *//* harmony import */ var _node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js */ "./node_modules/vue-loader/lib/runtime/componentNormalizer.js");





/* normalize component */

var component = Object(_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_2__["default"])(
  _EventRequirementsOverlay_vue_vue_type_script_lang_ts___WEBPACK_IMPORTED_MODULE_1__["default"],
  _EventRequirementsOverlay_vue_vue_type_template_id_45298f29___WEBPACK_IMPORTED_MODULE_0__["render"],
  _EventRequirementsOverlay_vue_vue_type_template_id_45298f29___WEBPACK_IMPORTED_MODULE_0__["staticRenderFns"],
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var api; }
component.options.__file = "src/js/components/CompetitionRegistration/EventRequirementsOverlay.vue"
/* harmony default export */ __webpack_exports__["default"] = (component.exports);

/***/ }),

/***/ "./src/js/components/CompetitionRegistration/EventRequirementsOverlay.vue?vue&type=script&lang=ts&":
/*!*********************************************************************************************************!*\
  !*** ./src/js/components/CompetitionRegistration/EventRequirementsOverlay.vue?vue&type=script&lang=ts& ***!
  \*********************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_ts_loader_index_js_ref_5_node_modules_vue_loader_lib_index_js_vue_loader_options_EventRequirementsOverlay_vue_vue_type_script_lang_ts___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../node_modules/ts-loader??ref--5!../../../../node_modules/vue-loader/lib??vue-loader-options!./EventRequirementsOverlay.vue?vue&type=script&lang=ts& */ "./node_modules/ts-loader/index.js?!./node_modules/vue-loader/lib/index.js?!./src/js/components/CompetitionRegistration/EventRequirementsOverlay.vue?vue&type=script&lang=ts&");
/* empty/unused harmony star reexport */ /* harmony default export */ __webpack_exports__["default"] = (_node_modules_ts_loader_index_js_ref_5_node_modules_vue_loader_lib_index_js_vue_loader_options_EventRequirementsOverlay_vue_vue_type_script_lang_ts___WEBPACK_IMPORTED_MODULE_0__["default"]); 

/***/ }),

/***/ "./src/js/components/CompetitionRegistration/EventRequirementsOverlay.vue?vue&type=template&id=45298f29&":
/*!***************************************************************************************************************!*\
  !*** ./src/js/components/CompetitionRegistration/EventRequirementsOverlay.vue?vue&type=template&id=45298f29& ***!
  \***************************************************************************************************************/
/*! exports provided: render, staticRenderFns */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_EventRequirementsOverlay_vue_vue_type_template_id_45298f29___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!../../../../node_modules/vue-loader/lib??vue-loader-options!./EventRequirementsOverlay.vue?vue&type=template&id=45298f29& */ "./node_modules/vue-loader/lib/loaders/templateLoader.js?!./node_modules/vue-loader/lib/index.js?!./src/js/components/CompetitionRegistration/EventRequirementsOverlay.vue?vue&type=template&id=45298f29&");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "render", function() { return _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_EventRequirementsOverlay_vue_vue_type_template_id_45298f29___WEBPACK_IMPORTED_MODULE_0__["render"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "staticRenderFns", function() { return _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_EventRequirementsOverlay_vue_vue_type_template_id_45298f29___WEBPACK_IMPORTED_MODULE_0__["staticRenderFns"]; });



/***/ }),

/***/ "./src/js/components/CompetitionRegistration/EventSelection.vue":
/*!**********************************************************************!*\
  !*** ./src/js/components/CompetitionRegistration/EventSelection.vue ***!
  \**********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _EventSelection_vue_vue_type_script_lang_ts___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./EventSelection.vue?vue&type=script&lang=ts& */ "./src/js/components/CompetitionRegistration/EventSelection.vue?vue&type=script&lang=ts&");
/* empty/unused harmony star reexport *//* harmony import */ var _node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js */ "./node_modules/vue-loader/lib/runtime/componentNormalizer.js");
var render, staticRenderFns




/* normalize component */

var component = Object(_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_1__["default"])(
  _EventSelection_vue_vue_type_script_lang_ts___WEBPACK_IMPORTED_MODULE_0__["default"],
  render,
  staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var api; }
component.options.__file = "src/js/components/CompetitionRegistration/EventSelection.vue"
/* harmony default export */ __webpack_exports__["default"] = (component.exports);

/***/ }),

/***/ "./src/js/components/CompetitionRegistration/EventSelection.vue?vue&type=script&lang=ts&":
/*!***********************************************************************************************!*\
  !*** ./src/js/components/CompetitionRegistration/EventSelection.vue?vue&type=script&lang=ts& ***!
  \***********************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_ts_loader_index_js_ref_5_node_modules_vue_loader_lib_index_js_vue_loader_options_EventSelection_vue_vue_type_script_lang_ts___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../node_modules/ts-loader??ref--5!../../../../node_modules/vue-loader/lib??vue-loader-options!./EventSelection.vue?vue&type=script&lang=ts& */ "./node_modules/ts-loader/index.js?!./node_modules/vue-loader/lib/index.js?!./src/js/components/CompetitionRegistration/EventSelection.vue?vue&type=script&lang=ts&");
/* empty/unused harmony star reexport */ /* harmony default export */ __webpack_exports__["default"] = (_node_modules_ts_loader_index_js_ref_5_node_modules_vue_loader_lib_index_js_vue_loader_options_EventSelection_vue_vue_type_script_lang_ts___WEBPACK_IMPORTED_MODULE_0__["default"]); 

/***/ }),

/***/ "./src/js/components/CompetitionRegistration/EventSelectionEvent.vue":
/*!***************************************************************************!*\
  !*** ./src/js/components/CompetitionRegistration/EventSelectionEvent.vue ***!
  \***************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _EventSelectionEvent_vue_vue_type_template_id_b8523b16___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./EventSelectionEvent.vue?vue&type=template&id=b8523b16& */ "./src/js/components/CompetitionRegistration/EventSelectionEvent.vue?vue&type=template&id=b8523b16&");
/* harmony import */ var _EventSelectionEvent_vue_vue_type_script_lang_ts___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./EventSelectionEvent.vue?vue&type=script&lang=ts& */ "./src/js/components/CompetitionRegistration/EventSelectionEvent.vue?vue&type=script&lang=ts&");
/* empty/unused harmony star reexport *//* harmony import */ var _node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js */ "./node_modules/vue-loader/lib/runtime/componentNormalizer.js");





/* normalize component */

var component = Object(_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_2__["default"])(
  _EventSelectionEvent_vue_vue_type_script_lang_ts___WEBPACK_IMPORTED_MODULE_1__["default"],
  _EventSelectionEvent_vue_vue_type_template_id_b8523b16___WEBPACK_IMPORTED_MODULE_0__["render"],
  _EventSelectionEvent_vue_vue_type_template_id_b8523b16___WEBPACK_IMPORTED_MODULE_0__["staticRenderFns"],
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var api; }
component.options.__file = "src/js/components/CompetitionRegistration/EventSelectionEvent.vue"
/* harmony default export */ __webpack_exports__["default"] = (component.exports);

/***/ }),

/***/ "./src/js/components/CompetitionRegistration/EventSelectionEvent.vue?vue&type=script&lang=ts&":
/*!****************************************************************************************************!*\
  !*** ./src/js/components/CompetitionRegistration/EventSelectionEvent.vue?vue&type=script&lang=ts& ***!
  \****************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_ts_loader_index_js_ref_5_node_modules_vue_loader_lib_index_js_vue_loader_options_EventSelectionEvent_vue_vue_type_script_lang_ts___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../node_modules/ts-loader??ref--5!../../../../node_modules/vue-loader/lib??vue-loader-options!./EventSelectionEvent.vue?vue&type=script&lang=ts& */ "./node_modules/ts-loader/index.js?!./node_modules/vue-loader/lib/index.js?!./src/js/components/CompetitionRegistration/EventSelectionEvent.vue?vue&type=script&lang=ts&");
/* empty/unused harmony star reexport */ /* harmony default export */ __webpack_exports__["default"] = (_node_modules_ts_loader_index_js_ref_5_node_modules_vue_loader_lib_index_js_vue_loader_options_EventSelectionEvent_vue_vue_type_script_lang_ts___WEBPACK_IMPORTED_MODULE_0__["default"]); 

/***/ }),

/***/ "./src/js/components/CompetitionRegistration/EventSelectionEvent.vue?vue&type=template&id=b8523b16&":
/*!**********************************************************************************************************!*\
  !*** ./src/js/components/CompetitionRegistration/EventSelectionEvent.vue?vue&type=template&id=b8523b16& ***!
  \**********************************************************************************************************/
/*! exports provided: render, staticRenderFns */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_EventSelectionEvent_vue_vue_type_template_id_b8523b16___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!../../../../node_modules/vue-loader/lib??vue-loader-options!./EventSelectionEvent.vue?vue&type=template&id=b8523b16& */ "./node_modules/vue-loader/lib/loaders/templateLoader.js?!./node_modules/vue-loader/lib/index.js?!./src/js/components/CompetitionRegistration/EventSelectionEvent.vue?vue&type=template&id=b8523b16&");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "render", function() { return _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_EventSelectionEvent_vue_vue_type_template_id_b8523b16___WEBPACK_IMPORTED_MODULE_0__["render"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "staticRenderFns", function() { return _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_EventSelectionEvent_vue_vue_type_template_id_b8523b16___WEBPACK_IMPORTED_MODULE_0__["staticRenderFns"]; });



/***/ }),

/***/ "./src/js/components/CompetitionRegistration/SelectRepresentation.vue":
/*!****************************************************************************!*\
  !*** ./src/js/components/CompetitionRegistration/SelectRepresentation.vue ***!
  \****************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _SelectRepresentation_vue_vue_type_script_lang_ts___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SelectRepresentation.vue?vue&type=script&lang=ts& */ "./src/js/components/CompetitionRegistration/SelectRepresentation.vue?vue&type=script&lang=ts&");
/* empty/unused harmony star reexport *//* harmony import */ var _node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js */ "./node_modules/vue-loader/lib/runtime/componentNormalizer.js");
var render, staticRenderFns




/* normalize component */

var component = Object(_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_1__["default"])(
  _SelectRepresentation_vue_vue_type_script_lang_ts___WEBPACK_IMPORTED_MODULE_0__["default"],
  render,
  staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var api; }
component.options.__file = "src/js/components/CompetitionRegistration/SelectRepresentation.vue"
/* harmony default export */ __webpack_exports__["default"] = (component.exports);

/***/ }),

/***/ "./src/js/components/CompetitionRegistration/SelectRepresentation.vue?vue&type=script&lang=ts&":
/*!*****************************************************************************************************!*\
  !*** ./src/js/components/CompetitionRegistration/SelectRepresentation.vue?vue&type=script&lang=ts& ***!
  \*****************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_ts_loader_index_js_ref_5_node_modules_vue_loader_lib_index_js_vue_loader_options_SelectRepresentation_vue_vue_type_script_lang_ts___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../node_modules/ts-loader??ref--5!../../../../node_modules/vue-loader/lib??vue-loader-options!./SelectRepresentation.vue?vue&type=script&lang=ts& */ "./node_modules/ts-loader/index.js?!./node_modules/vue-loader/lib/index.js?!./src/js/components/CompetitionRegistration/SelectRepresentation.vue?vue&type=script&lang=ts&");
/* empty/unused harmony star reexport */ /* harmony default export */ __webpack_exports__["default"] = (_node_modules_ts_loader_index_js_ref_5_node_modules_vue_loader_lib_index_js_vue_loader_options_SelectRepresentation_vue_vue_type_script_lang_ts___WEBPACK_IMPORTED_MODULE_0__["default"]); 

/***/ }),

/***/ "./src/js/components/DateInput.vue":
/*!*****************************************!*\
  !*** ./src/js/components/DateInput.vue ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _DateInput_vue_vue_type_template_id_e6e2c8c0___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DateInput.vue?vue&type=template&id=e6e2c8c0& */ "./src/js/components/DateInput.vue?vue&type=template&id=e6e2c8c0&");
/* harmony import */ var _DateInput_vue_vue_type_script_lang_ts___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DateInput.vue?vue&type=script&lang=ts& */ "./src/js/components/DateInput.vue?vue&type=script&lang=ts&");
/* empty/unused harmony star reexport *//* harmony import */ var _node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js */ "./node_modules/vue-loader/lib/runtime/componentNormalizer.js");





/* normalize component */

var component = Object(_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_2__["default"])(
  _DateInput_vue_vue_type_script_lang_ts___WEBPACK_IMPORTED_MODULE_1__["default"],
  _DateInput_vue_vue_type_template_id_e6e2c8c0___WEBPACK_IMPORTED_MODULE_0__["render"],
  _DateInput_vue_vue_type_template_id_e6e2c8c0___WEBPACK_IMPORTED_MODULE_0__["staticRenderFns"],
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var api; }
component.options.__file = "src/js/components/DateInput.vue"
/* harmony default export */ __webpack_exports__["default"] = (component.exports);

/***/ }),

/***/ "./src/js/components/DateInput.vue?vue&type=script&lang=ts&":
/*!******************************************************************!*\
  !*** ./src/js/components/DateInput.vue?vue&type=script&lang=ts& ***!
  \******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_ts_loader_index_js_ref_5_node_modules_vue_loader_lib_index_js_vue_loader_options_DateInput_vue_vue_type_script_lang_ts___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/ts-loader??ref--5!../../../node_modules/vue-loader/lib??vue-loader-options!./DateInput.vue?vue&type=script&lang=ts& */ "./node_modules/ts-loader/index.js?!./node_modules/vue-loader/lib/index.js?!./src/js/components/DateInput.vue?vue&type=script&lang=ts&");
/* empty/unused harmony star reexport */ /* harmony default export */ __webpack_exports__["default"] = (_node_modules_ts_loader_index_js_ref_5_node_modules_vue_loader_lib_index_js_vue_loader_options_DateInput_vue_vue_type_script_lang_ts___WEBPACK_IMPORTED_MODULE_0__["default"]); 

/***/ }),

/***/ "./src/js/components/DateInput.vue?vue&type=template&id=e6e2c8c0&":
/*!************************************************************************!*\
  !*** ./src/js/components/DateInput.vue?vue&type=template&id=e6e2c8c0& ***!
  \************************************************************************/
/*! exports provided: render, staticRenderFns */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_DateInput_vue_vue_type_template_id_e6e2c8c0___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!../../../node_modules/vue-loader/lib??vue-loader-options!./DateInput.vue?vue&type=template&id=e6e2c8c0& */ "./node_modules/vue-loader/lib/loaders/templateLoader.js?!./node_modules/vue-loader/lib/index.js?!./src/js/components/DateInput.vue?vue&type=template&id=e6e2c8c0&");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "render", function() { return _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_DateInput_vue_vue_type_template_id_e6e2c8c0___WEBPACK_IMPORTED_MODULE_0__["render"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "staticRenderFns", function() { return _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_DateInput_vue_vue_type_template_id_e6e2c8c0___WEBPACK_IMPORTED_MODULE_0__["staticRenderFns"]; });



/***/ }),

/***/ "./src/js/components/EditProfile.vue":
/*!*******************************************!*\
  !*** ./src/js/components/EditProfile.vue ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _EditProfile_vue_vue_type_script_lang_ts___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./EditProfile.vue?vue&type=script&lang=ts& */ "./src/js/components/EditProfile.vue?vue&type=script&lang=ts&");
/* empty/unused harmony star reexport *//* harmony import */ var _node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js */ "./node_modules/vue-loader/lib/runtime/componentNormalizer.js");
var render, staticRenderFns




/* normalize component */

var component = Object(_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_1__["default"])(
  _EditProfile_vue_vue_type_script_lang_ts___WEBPACK_IMPORTED_MODULE_0__["default"],
  render,
  staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var api; }
component.options.__file = "src/js/components/EditProfile.vue"
/* harmony default export */ __webpack_exports__["default"] = (component.exports);

/***/ }),

/***/ "./src/js/components/EditProfile.vue?vue&type=script&lang=ts&":
/*!********************************************************************!*\
  !*** ./src/js/components/EditProfile.vue?vue&type=script&lang=ts& ***!
  \********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_ts_loader_index_js_ref_5_node_modules_vue_loader_lib_index_js_vue_loader_options_EditProfile_vue_vue_type_script_lang_ts___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/ts-loader??ref--5!../../../node_modules/vue-loader/lib??vue-loader-options!./EditProfile.vue?vue&type=script&lang=ts& */ "./node_modules/ts-loader/index.js?!./node_modules/vue-loader/lib/index.js?!./src/js/components/EditProfile.vue?vue&type=script&lang=ts&");
/* empty/unused harmony star reexport */ /* harmony default export */ __webpack_exports__["default"] = (_node_modules_ts_loader_index_js_ref_5_node_modules_vue_loader_lib_index_js_vue_loader_options_EditProfile_vue_vue_type_script_lang_ts___WEBPACK_IMPORTED_MODULE_0__["default"]); 

/***/ }),

/***/ "./src/js/components/MemberSearch/MemberSearchValidators.ts":
/*!******************************************************************!*\
  !*** ./src/js/components/MemberSearch/MemberSearchValidators.ts ***!
  \******************************************************************/
/*! exports provided: validateResultActive */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "validateResultActive", function() { return validateResultActive; });
/**
 * Validate that a member search result has active status
 */
var validateResultActive = function (member_result) {
    return member_result.active ? false : 'Ineligible to Participate';
};


/***/ }),

/***/ "./src/js/components/ProgressBar.vue":
/*!*******************************************!*\
  !*** ./src/js/components/ProgressBar.vue ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _ProgressBar_vue_vue_type_template_id_70fb958a___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ProgressBar.vue?vue&type=template&id=70fb958a& */ "./src/js/components/ProgressBar.vue?vue&type=template&id=70fb958a&");
/* harmony import */ var _ProgressBar_vue_vue_type_script_lang_ts___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ProgressBar.vue?vue&type=script&lang=ts& */ "./src/js/components/ProgressBar.vue?vue&type=script&lang=ts&");
/* empty/unused harmony star reexport *//* harmony import */ var _node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js */ "./node_modules/vue-loader/lib/runtime/componentNormalizer.js");





/* normalize component */

var component = Object(_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_2__["default"])(
  _ProgressBar_vue_vue_type_script_lang_ts___WEBPACK_IMPORTED_MODULE_1__["default"],
  _ProgressBar_vue_vue_type_template_id_70fb958a___WEBPACK_IMPORTED_MODULE_0__["render"],
  _ProgressBar_vue_vue_type_template_id_70fb958a___WEBPACK_IMPORTED_MODULE_0__["staticRenderFns"],
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var api; }
component.options.__file = "src/js/components/ProgressBar.vue"
/* harmony default export */ __webpack_exports__["default"] = (component.exports);

/***/ }),

/***/ "./src/js/components/ProgressBar.vue?vue&type=script&lang=ts&":
/*!********************************************************************!*\
  !*** ./src/js/components/ProgressBar.vue?vue&type=script&lang=ts& ***!
  \********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_ts_loader_index_js_ref_5_node_modules_vue_loader_lib_index_js_vue_loader_options_ProgressBar_vue_vue_type_script_lang_ts___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/ts-loader??ref--5!../../../node_modules/vue-loader/lib??vue-loader-options!./ProgressBar.vue?vue&type=script&lang=ts& */ "./node_modules/ts-loader/index.js?!./node_modules/vue-loader/lib/index.js?!./src/js/components/ProgressBar.vue?vue&type=script&lang=ts&");
/* empty/unused harmony star reexport */ /* harmony default export */ __webpack_exports__["default"] = (_node_modules_ts_loader_index_js_ref_5_node_modules_vue_loader_lib_index_js_vue_loader_options_ProgressBar_vue_vue_type_script_lang_ts___WEBPACK_IMPORTED_MODULE_0__["default"]); 

/***/ }),

/***/ "./src/js/components/ProgressBar.vue?vue&type=template&id=70fb958a&":
/*!**************************************************************************!*\
  !*** ./src/js/components/ProgressBar.vue?vue&type=template&id=70fb958a& ***!
  \**************************************************************************/
/*! exports provided: render, staticRenderFns */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_ProgressBar_vue_vue_type_template_id_70fb958a___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!../../../node_modules/vue-loader/lib??vue-loader-options!./ProgressBar.vue?vue&type=template&id=70fb958a& */ "./node_modules/vue-loader/lib/loaders/templateLoader.js?!./node_modules/vue-loader/lib/index.js?!./src/js/components/ProgressBar.vue?vue&type=template&id=70fb958a&");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "render", function() { return _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_ProgressBar_vue_vue_type_template_id_70fb958a___WEBPACK_IMPORTED_MODULE_0__["render"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "staticRenderFns", function() { return _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_ProgressBar_vue_vue_type_template_id_70fb958a___WEBPACK_IMPORTED_MODULE_0__["staticRenderFns"]; });



/***/ }),

/***/ "./src/js/components/SkateTestEquivalency/DisciplineForm.vue":
/*!*******************************************************************!*\
  !*** ./src/js/components/SkateTestEquivalency/DisciplineForm.vue ***!
  \*******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _DisciplineForm_vue_vue_type_script_lang_ts___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DisciplineForm.vue?vue&type=script&lang=ts& */ "./src/js/components/SkateTestEquivalency/DisciplineForm.vue?vue&type=script&lang=ts&");
/* empty/unused harmony star reexport *//* harmony import */ var _node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js */ "./node_modules/vue-loader/lib/runtime/componentNormalizer.js");
var render, staticRenderFns




/* normalize component */

var component = Object(_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_1__["default"])(
  _DisciplineForm_vue_vue_type_script_lang_ts___WEBPACK_IMPORTED_MODULE_0__["default"],
  render,
  staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var api; }
component.options.__file = "src/js/components/SkateTestEquivalency/DisciplineForm.vue"
/* harmony default export */ __webpack_exports__["default"] = (component.exports);

/***/ }),

/***/ "./src/js/components/SkateTestEquivalency/DisciplineForm.vue?vue&type=script&lang=ts&":
/*!********************************************************************************************!*\
  !*** ./src/js/components/SkateTestEquivalency/DisciplineForm.vue?vue&type=script&lang=ts& ***!
  \********************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_ts_loader_index_js_ref_5_node_modules_vue_loader_lib_index_js_vue_loader_options_DisciplineForm_vue_vue_type_script_lang_ts___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../node_modules/ts-loader??ref--5!../../../../node_modules/vue-loader/lib??vue-loader-options!./DisciplineForm.vue?vue&type=script&lang=ts& */ "./node_modules/ts-loader/index.js?!./node_modules/vue-loader/lib/index.js?!./src/js/components/SkateTestEquivalency/DisciplineForm.vue?vue&type=script&lang=ts&");
/* empty/unused harmony star reexport */ /* harmony default export */ __webpack_exports__["default"] = (_node_modules_ts_loader_index_js_ref_5_node_modules_vue_loader_lib_index_js_vue_loader_options_DisciplineForm_vue_vue_type_script_lang_ts___WEBPACK_IMPORTED_MODULE_0__["default"]); 

/***/ }),

/***/ "./src/js/components/SkateTestHistory/SkateTestHistory.vue":
/*!*****************************************************************!*\
  !*** ./src/js/components/SkateTestHistory/SkateTestHistory.vue ***!
  \*****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _SkateTestHistory_vue_vue_type_script_lang_ts___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SkateTestHistory.vue?vue&type=script&lang=ts& */ "./src/js/components/SkateTestHistory/SkateTestHistory.vue?vue&type=script&lang=ts&");
/* empty/unused harmony star reexport *//* harmony import */ var _node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js */ "./node_modules/vue-loader/lib/runtime/componentNormalizer.js");
var render, staticRenderFns




/* normalize component */

var component = Object(_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_1__["default"])(
  _SkateTestHistory_vue_vue_type_script_lang_ts___WEBPACK_IMPORTED_MODULE_0__["default"],
  render,
  staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var api; }
component.options.__file = "src/js/components/SkateTestHistory/SkateTestHistory.vue"
/* harmony default export */ __webpack_exports__["default"] = (component.exports);

/***/ }),

/***/ "./src/js/components/SkateTestHistory/SkateTestHistory.vue?vue&type=script&lang=ts&":
/*!******************************************************************************************!*\
  !*** ./src/js/components/SkateTestHistory/SkateTestHistory.vue?vue&type=script&lang=ts& ***!
  \******************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_ts_loader_index_js_ref_5_node_modules_vue_loader_lib_index_js_vue_loader_options_SkateTestHistory_vue_vue_type_script_lang_ts___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../node_modules/ts-loader??ref--5!../../../../node_modules/vue-loader/lib??vue-loader-options!./SkateTestHistory.vue?vue&type=script&lang=ts& */ "./node_modules/ts-loader/index.js?!./node_modules/vue-loader/lib/index.js?!./src/js/components/SkateTestHistory/SkateTestHistory.vue?vue&type=script&lang=ts&");
/* empty/unused harmony star reexport */ /* harmony default export */ __webpack_exports__["default"] = (_node_modules_ts_loader_index_js_ref_5_node_modules_vue_loader_lib_index_js_vue_loader_options_SkateTestHistory_vue_vue_type_script_lang_ts___WEBPACK_IMPORTED_MODULE_0__["default"]); 

/***/ }),

/***/ "./src/js/config/AppConfig.ts":
/*!************************************!*\
  !*** ./src/js/config/AppConfig.ts ***!
  \************************************/
/*! exports provided: URL_CONFIG, PracticeIceConfig, CREDIT_CARD_GAP_SEPARATOR, DATE_INPUT_GAP_SEPARATOR, SKIP_VALIDATION, ENTITY_CHECK_IN_DEBUG, AUTOLOAD_ENTITY_CHECK_IN_INDEX, COMPETITION_MANAGEMENT_COOKIE_NAME, SERIES_REGISTRATION_COOKIE_NAME, TEAM_REGISTRATION_TEAM_ID_COOKIE_NAME, TEAM_REGISTRATION_COMPETITION_ID_COOKIE_NAME, COMPETITION_PORTAL_ACTIVE_COMPETITION_ID_COOKIE_NAME, COMPETITION_PORTAL_ACTIVE_TEAM_ID_COOKIE_NAME, SERIES_REGISTRATION_ACTIVE_TEAM_ID_COOKIE_NAME */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "URL_CONFIG", function() { return URL_CONFIG; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PracticeIceConfig", function() { return PracticeIceConfig; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CREDIT_CARD_GAP_SEPARATOR", function() { return CREDIT_CARD_GAP_SEPARATOR; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DATE_INPUT_GAP_SEPARATOR", function() { return DATE_INPUT_GAP_SEPARATOR; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SKIP_VALIDATION", function() { return SKIP_VALIDATION; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ENTITY_CHECK_IN_DEBUG", function() { return ENTITY_CHECK_IN_DEBUG; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AUTOLOAD_ENTITY_CHECK_IN_INDEX", function() { return AUTOLOAD_ENTITY_CHECK_IN_INDEX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "COMPETITION_MANAGEMENT_COOKIE_NAME", function() { return COMPETITION_MANAGEMENT_COOKIE_NAME; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SERIES_REGISTRATION_COOKIE_NAME", function() { return SERIES_REGISTRATION_COOKIE_NAME; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TEAM_REGISTRATION_TEAM_ID_COOKIE_NAME", function() { return TEAM_REGISTRATION_TEAM_ID_COOKIE_NAME; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TEAM_REGISTRATION_COMPETITION_ID_COOKIE_NAME", function() { return TEAM_REGISTRATION_COMPETITION_ID_COOKIE_NAME; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "COMPETITION_PORTAL_ACTIVE_COMPETITION_ID_COOKIE_NAME", function() { return COMPETITION_PORTAL_ACTIVE_COMPETITION_ID_COOKIE_NAME; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "COMPETITION_PORTAL_ACTIVE_TEAM_ID_COOKIE_NAME", function() { return COMPETITION_PORTAL_ACTIVE_TEAM_ID_COOKIE_NAME; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SERIES_REGISTRATION_ACTIVE_TEAM_ID_COOKIE_NAME", function() { return SERIES_REGISTRATION_ACTIVE_TEAM_ID_COOKIE_NAME; });
var URL_CONFIG = {
    login: '/Account/CheckLogin',
    getSkaterComps: '/EMS/UpcomingCompsSkater',
    getCompetitionList: '/api/competitions'
};
var PracticeIceConfig = {
    allow_all_dates_filter: false
};
var CREDIT_CARD_GAP_SEPARATOR = ' ';
var DATE_INPUT_GAP_SEPARATOR = '/';
/**
 * Whether to bypass validation for forms.  Used for development
 *
 * @note: not all forms are tied to this value as of this writing and may still validate even when this is true
 */
var SKIP_VALIDATION = false;
/**
 * Enable debug mode for entity check-in:
 *
 * 1. Shows all subpage items on entity check-in index
 */
var ENTITY_CHECK_IN_DEBUG = false;
/**
 * Start check-in with an entity active.
 *
 * Set to a number to load the appropriate entity.
 * Set to false or undefined to prevent autoload.
 */
var AUTOLOAD_ENTITY_CHECK_IN_INDEX = false;
/**
 * Name of cookie from which active Competition Management Competition ID can be read.
 *
 * False if cookie is not being used.
 */
var COMPETITION_MANAGEMENT_COOKIE_NAME = false; // 'competition_management_active_competition_id';
/**
 * Name of cookie from which active Series Registration Series ID can be read
 */
var SERIES_REGISTRATION_COOKIE_NAME = 'series_registration_series_id';
/**
 * Name of cookie from which active Team Registration Team ID can be read
 */
var TEAM_REGISTRATION_TEAM_ID_COOKIE_NAME = 'team_competition_registration_team_id';
/**
 * Name of cookie from which active Team Registration Competition ID can be read
 */
var TEAM_REGISTRATION_COMPETITION_ID_COOKIE_NAME = 'team_competition_registration_competition_id';
/**
 * Name of cookie that tracks the active competition ID within the Competition Portal
 */
var COMPETITION_PORTAL_ACTIVE_COMPETITION_ID_COOKIE_NAME = 'competition_portal_competition_id';
/**
 * Name of cookie that tracks the active team ID within the Competition Portal
 */
var COMPETITION_PORTAL_ACTIVE_TEAM_ID_COOKIE_NAME = 'competition_portal_team_id';
/**
 * Name of cookie that tracks the active team ID within Series Registration
 */
var SERIES_REGISTRATION_ACTIVE_TEAM_ID_COOKIE_NAME = 'series_registration_team_id';


/***/ }),

/***/ "./src/js/helpers/CompetitionSearchHelpers.ts":
/*!****************************************************!*\
  !*** ./src/js/helpers/CompetitionSearchHelpers.ts ***!
  \****************************************************/
/*! exports provided: CompetitionSearchHelpers */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CompetitionSearchHelpers", function() { return CompetitionSearchHelpers; });
/* harmony import */ var _DateFilterer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DateFilterer */ "./src/js/helpers/DateFilterer.ts");

/**
 * Class to help search the competition list
 */
var CompetitionSearchHelpers = /** @class */ (function () {
    function CompetitionSearchHelpers() {
    }
    /**
     * Whether a competition passes active filters
     */
    CompetitionSearchHelpers.competitionPassesFilter = function (competition, search_criteria) {
        var search_field = search_criteria.search_field, search_term = search_criteria.search_term;
        // Competition passes if no search field or term are present
        if (!search_field || !search_term) {
            return true;
        }
        var competition_field = search_field;
        // If the search field isn't the date, attempt a string match and return the result
        if (search_field !== "date") {
            if (competition_field in competition) {
                var competition_value = competition[competition_field];
                if (typeof competition_value === "string") {
                    return competition_value.toLowerCase().match(search_term.toLowerCase());
                }
            }
        }
        return this.passesDateFilter(competition, search_term);
    };
    /**
     * Whether a competition passes a user's date filter
     */
    CompetitionSearchHelpers.passesDateFilter = function (competition, search_term) {
        var start = new Date(competition.start_date_ts);
        var end = new Date(competition.end_date_ts);
        var filterer = new _DateFilterer__WEBPACK_IMPORTED_MODULE_0__["DateFilterer"](start, end, search_term);
        return filterer.passed;
    };
    return CompetitionSearchHelpers;
}());



/***/ }),

/***/ "./src/js/helpers/DateFilterer.ts":
/*!****************************************!*\
  !*** ./src/js/helpers/DateFilterer.ts ***!
  \****************************************/
/*! exports provided: DateFilterer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DateFilterer", function() { return DateFilterer; });
/**
 * @important_note:
 * Edge cases that result in failure:
 * Near-year span with lower end dates (1/2/19-1/1/20)
 * Multi-year spans (1/2/19 - 4/3/21)
 * Given the real-world use cases at this time, leaving as is for competition list filtering
 */
var DateFilterer = /** @class */ (function () {
    function DateFilterer(start_date, end_date, search_term) {
        this.passed = false;
        this.start_month = start_date.getUTCMonth() + 1;
        this.end_month = end_date.getUTCMonth() + 1;
        this.start_date = start_date.getUTCDate();
        this.end_date = end_date.getUTCDate();
        this.start_year = String(start_date.getUTCFullYear()).slice(2);
        this.end_year = String(end_date.getUTCFullYear()).slice(2);
        this.months_equal = this.start_month === this.end_month;
        this.query = DateFilterer.sanitizeQuery(search_term);
        this.passed = this.run();
    }
    DateFilterer.prototype.run = function () {
        return this.checkMonths();
    };
    /**
     * Determine whether the active date range passes the queried filter
     * For each month between the start and the end month, compare to query.
     * If no month matches, return false.
     *  Otherwise, go deeper and check days
     */
    DateFilterer.prototype.checkMonths = function () {
        if (!this.query) {
            return false;
        }
        if (!this.query.month.check) {
            return true;
        }
        var start_month = this.start_month;
        var end_month = this.end_month;
        // For spans across new years, set relative values
        if (start_month > end_month) {
            end_month += 12;
        }
        var active_index = start_month;
        while (active_index <= end_month) {
            // The actual month number in play cannot exceed 12
            var month_key = active_index > 12 ? active_index % 12 : active_index;
            if (this.query.month.check.test(String(month_key))) {
                if (this.checkDaysForMonth(month_key)) {
                    return true;
                }
            }
            active_index++;
        }
        return false;
    };
    /**
     * Determine whether the active date range passes the queried filter for days
     * If start and end month are the same, check every date from start to end.
     * Otherwise, check all the days through the end of the month for the start month,
     *  or every day back to the beginning of the month for the end month.
     *
     *  Months in between automatically pass
     */
    DateFilterer.prototype.checkDaysForMonth = function (month) {
        if (!this.query) {
            return false;
        }
        if (!this.query.date.check) {
            return true;
        }
        var start_date = this.start_date;
        var end_date = this.end_date;
        /**
         * Months are equal.  Check all dates between start and end
         */
        if (this.months_equal) {
            while (start_date <= end_date) {
                if (this.query.date.check.test(String(start_date))) {
                    return this.checkYearForMonth(month);
                }
                start_date++;
            }
            return false;
        }
        /**
         * Month being checked is start month. Check all dates through to the end of the month.
         */
        if (month === this.start_month) {
            while (start_date < 32) {
                if (this.query.date.check.test(String(start_date))) {
                    return this.checkYearForMonth(month);
                }
                start_date++;
            }
            return false;
        }
        /**
         * Month is end month. Check every date from 1 to end date
         */
        if (month === this.end_month) {
            var date_index = 1;
            while (date_index <= end_date) {
                if (this.query.date.check.test(String(date_index))) {
                    return this.checkYearForMonth(month);
                }
                date_index++;
            }
            return false;
        }
        /**
         * Month lies between start and end months.  All days are valid.  Go deeper
         */
        return this.checkYearForMonth(month);
    };
    /**
     * Given a month, make sure its year is valid
     * If the month is the start month, make sure it matches the start month year
     * If the month is the end month, make sure it matches the end month year
     * If the month is not the start month, and it's larger than the end month, use the start month
     */
    DateFilterer.prototype.checkYearForMonth = function (month) {
        if (!this.query) {
            return false;
        }
        if (!this.query.year.check) {
            return true;
        }
        /**
         * If the month is the start month, direct compare
         * If the month is larger than the end month, it must belong to the start year
         */
        if (month === this.start_month || month > this.end_month) {
            return this.query.year.check.test(this.start_year);
        }
        return this.query.year.check.test(this.end_year);
    };
    /**
     * Create a sanitized query from the search term.  Return false if input is bad.
     */
    DateFilterer.sanitizeQuery = function (search_term) {
        var split = search_term.split("/");
        // If there's 3 or more slashes, the input date is bad and won't match anything
        if (split.length > 3) {
            return false;
        }
        //Whether the month has been "completed" by the user with a slash
        var month_complete = split.length > 1;
        //Whether the day has been "completed" by the user with a slash
        var date_complete = split.length > 2;
        var month_value = split[0] || undefined;
        var date_value = split[1] || undefined;
        var year_value = split[2];
        if (month_value && !(/[0-9]+/.test(month_value))) {
            return false;
        }
        if (date_value && !(/[0-9]+/.test(date_value))) {
            return false;
        }
        if (year_value && !(/[0-9]+/.test(year_value))) {
            return false;
        }
        //Double slashes invalid
        if (month_complete && !month_value || date_complete && !date_value) {
            return false;
        }
        //If month/date numbers are invalid, return false
        var MONTH_LENGTHS = {
            "1": 31,
            "2": 29,
            "3": 31,
            "4": 30,
            "5": 31,
            "6": 30,
            "7": 31,
            "8": 31,
            "9": 30,
            "10": 31,
            "11": 30,
            "12": 31,
        };
        if (month_value) {
            var month_int = parseInt(month_value);
            if (month_int > 12 || month_int < 1) {
                return false;
            }
            if (date_value) {
                var date_int = parseInt(date_value);
                if (date_int > MONTH_LENGTHS[month_value]) {
                    return false;
                }
            }
        }
        // Compile regex testers for available values
        var month_regex;
        if (month_value) {
            var month_query = "^" + month_value;
            if (month_complete) {
                month_query += '$';
            }
            month_regex = new RegExp(month_query);
        }
        var date_regex;
        if (date_value) {
            var date_query = "^" + date_value;
            if (date_complete) {
                date_query += '$';
            }
            date_regex = new RegExp(date_query);
        }
        var year_regex;
        if (year_value) {
            var year_query = "^" + year_value;
            year_regex = new RegExp(year_query);
        }
        return {
            month: {
                value: month_value,
                check: month_regex
            },
            date: {
                value: date_value,
                check: date_regex
            },
            year: {
                value: year_value,
                check: year_regex
            },
        };
    };
    /* eslint-enable */
    /**
     * Determine if a date range lies within a date window
     *
     * @param {[Date,Date]} date_range  - The date range to check
     * @param {[Date|null,Date|null]} window - The window to check against.
     *
     * @return bool - Whether the date range to check has any dates within the window
     */
    DateFilterer.dateRangeWithinWindow = function (date_range, window) {
        var window_end = window[1];
        var window_start = window[0];
        var date_range_start = date_range[0];
        var date_range_end = date_range[1];
        // Invalid window - Window start is after window end
        if (window_start && window_end && window_end < window_start) {
            return false;
        }
        // Date range start is after window end
        if (window_end && date_range_start > window_end) {
            return false;
        }
        // Date rage end is before window start
        if (window_start && date_range_end < window_start) {
            return false;
        }
        return true;
    };
    return DateFilterer;
}());



/***/ }),

/***/ "./src/js/helpers/SearchResultHelpers.ts":
/*!***********************************************!*\
  !*** ./src/js/helpers/SearchResultHelpers.ts ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var SearchResultHelpers = /** @class */ (function () {
    function SearchResultHelpers() {
    }
    SearchResultHelpers.getSpread = function (result_count, active_page_index, per_page) {
        if (result_count === 0) {
            return {
                start: 0,
                end: 0
            };
        }
        var start = 1;
        var end = result_count;
        if (typeof per_page === "number") {
            start = per_page * active_page_index + 1;
            end = per_page * (active_page_index + 1);
        }
        return {
            start: start,
            end: end < result_count ? end : result_count
        };
    };
    /**
     * Create pagination that always contains 7 items (unless source pages are shorter)
     * Pagination always includes first and last page
     * Pagination contains 5 remaining items surrounding the active page
     * For non-sequential pagination elements, display ellipsis.
     */
    SearchResultHelpers.getPaginationOptions = function (paginated_data, active_page_index) {
        var first_page = {
            page_number: 1,
            page_index: 0
        };
        var last_page = {
            page_number: paginated_data.length,
            page_index: paginated_data.length - 1
        };
        var result = [
            first_page,
            last_page
        ];
        /**
         * If only 1 page of data, return the first item in our result set
         */
        if (paginated_data.length === 1) {
            return result.splice(0, 1);
        }
        var spread = SearchResultHelpers.getPaginationSpread(paginated_data, active_page_index);
        result.splice.apply(result, [1, 0].concat(spread));
        /**
         *
         */
        return result.map(function (item, index) {
            /**
             * Preserve first and last items
             */
            if (index === 0 || index === result.length - 1) {
                return item;
            }
            var previous_item = result[index - 1];
            var next_item = result[index + 1];
            /**
             * If a next item isn't sequentially 1 step above the current, replace current with ellipsis
             */
            if (next_item && next_item.page_number > item.page_number + 1) {
                return {
                    page_number: "...",
                    page_index: false
                };
            }
            /**
             * If a previous item isn't sequentially 1 step below the current, replace current with ellipsis
             */
            if (previous_item && previous_item.page_number < item.page_number - 1) {
                return {
                    page_number: "...",
                    page_index: false
                };
            }
            return item;
        });
    };
    /**
     * Get the spread of pages surrounding the active page
     */
    SearchResultHelpers.getPaginationSpread = function (paginated_data, active_page_index) {
        var full_spread_length = 5;
        var spread = [];
        var max_spread = paginated_data.length - 2;
        var spread_length = max_spread < full_spread_length ? max_spread : full_spread_length;
        /**
         * Add the active page first if it's not the first or last page
         */
        var active_page_not_first = active_page_index > 0;
        var active_page_not_last = active_page_index < paginated_data.length - 1;
        if (active_page_not_first && active_page_not_last) {
            spread.push({
                page_number: active_page_index + 1,
                page_index: active_page_index
            });
        }
        /**
         * Build the spread according to it's length.
         *
         * Add previous pages while applicable before the current spread
         * Add next pages while applicable to the end of the spread
         */
        for (var j = 1; j <= spread_length; j++) {
            var previous_index = active_page_index - j;
            var next_index = active_page_index + j;
            if (previous_index > 0) {
                spread.unshift({
                    page_number: previous_index + 1,
                    page_index: previous_index
                });
            }
            if (next_index < paginated_data.length - 1) {
                spread.push({
                    page_number: next_index + 1,
                    page_index: next_index
                });
            }
            if (spread.length >= spread_length) {
                break;
            }
        }
        return spread;
    };
    return SearchResultHelpers;
}());
/* harmony default export */ __webpack_exports__["default"] = (SearchResultHelpers);


/***/ }),

/***/ "./src/js/helpers/time.ts":
/*!********************************!*\
  !*** ./src/js/helpers/time.ts ***!
  \********************************/
/*! exports provided: meridian, twelveHourHour, prettyTime, fullMinutes, hoursMinutes, DateFormat, UTCDateFormatNoYear, TwoDigitYear, DateFormatAbridgedYear, FormInputDate */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "meridian", function() { return meridian; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "twelveHourHour", function() { return twelveHourHour; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "prettyTime", function() { return prettyTime; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fullMinutes", function() { return fullMinutes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hoursMinutes", function() { return hoursMinutes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DateFormat", function() { return DateFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UTCDateFormatNoYear", function() { return UTCDateFormatNoYear; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TwoDigitYear", function() { return TwoDigitYear; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DateFormatAbridgedYear", function() { return DateFormatAbridgedYear; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FormInputDate", function() { return FormInputDate; });
function meridian(date) {
    var hours = date.getHours();
    if (hours >= 12) {
        return "PM";
    }
    return "AM";
}
function twelveHourHour(date) {
    var hours = date.getHours();
    if (hours > 12) {
        hours = hours - 12;
    }
    else if (hours == 0) {
        hours = 12;
    }
    return hours;
}
function prettyTime(date) {
    return twelveHourHour(date) + ":" + fullMinutes(date);
}
function fullMinutes(date) {
    var minutes = date.getMinutes();
    var pretty_minutes = String(minutes);
    if (minutes < 10) {
        pretty_minutes = "0" + pretty_minutes;
    }
    return pretty_minutes;
}
function hoursMinutes(date) {
    return twelveHourHour(date) + ":" + fullMinutes(date);
}
function DateFormat(date) {
    return date.getMonth() + 1 + "/" + date.getDate() + "/" + date.getFullYear();
}
/**
 * Format a UTC date as M/D
 */
function UTCDateFormatNoYear(date) {
    return date.getUTCMonth() + 1 + "/" + date.getUTCDate();
}
function TwoDigitYear(date) {
    return String(date.getFullYear()).substring(2);
}
function DateFormatAbridgedYear(date) {
    return date.getMonth() + 1 + "/" + date.getDate() + "/" + TwoDigitYear(date);
}
/**
 * Format a date in MM/DD/YYYY format
 */
function FormInputDate(date) {
    var value = [];
    var month = date.getUTCMonth() + 1;
    var day = date.getUTCDate();
    var year = date.getUTCFullYear();
    value.push(String(month));
    if (month < 10) {
        value[0] = "0" + value[0];
    }
    value.push(String(day));
    if (day < 10) {
        value[1] = "0" + value[1];
    }
    value.push(year);
    return value.join('/');
}


/***/ }),

/***/ "./src/js/mixins/EventSelectionMixin.ts":
/*!**********************************************!*\
  !*** ./src/js/mixins/EventSelectionMixin.ts ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
/* harmony import */ var _services_PaginationService__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../services/PaginationService */ "./src/js/services/PaginationService.ts");


var CONFIG = {
    feedback_in_duration: 250,
    feedback_show_duration: 600,
    error_show_duration: 850,
    my_event_change_duration: 600,
    results_per_page: 4
};
/* harmony default export */ __webpack_exports__["default"] = (vue__WEBPACK_IMPORTED_MODULE_0__["default"].extend({
    props: {
        state_available_events: {
            type: Array
        }
    },
    /**
     * Reactive data
     */
    // eslint-disable-next-line max-lines-per-function
    data: function () {
        return {
            /**
             * The active type of events to show
             */
            active_type: null,
            /**
             * The active page index of paginated event results
             */
            active_page_index: 0,
            /**
             * Whether an event was recently added.  For my events state transition
             */
            element_added: false,
            /**
             * Whether an event was recently removed.  For my events state transition
             */
            element_removed: false,
            /**
             * The ID of the current event being added or removed.  Used for error message location on event failure
             * events in "my events" are identified with a negative id
             */
            active_event_tracking_id: null,
            /**
             * The message for the latest event submission interaction
             */
            active_event_message: null,
            /**
             * The type of message for the latest submission interaction.
             * Determines the class styling of the feedback element
             */
            active_event_status: 'success',
            /**
             * Whether actions on event cards should be disabled. True when an event action is being submitted
             * Disables action buttons on event cards, but not referenced within component methods
             */
            disable_event_selection: false,
            /**
             * Whether data needed for component to function has been loaded
             */
            dependencies: {
                screen: false,
                competition: false
            },
            /**
             * The list of available events, local to the component
             */
            available_events: [],
            /**
             * Buffer for active events.  Allows component to update display without direct binding to state
             */
            available_events_buffer: [],
            /**
             * Display of amount of "my events"
             */
            my_events_count: 0,
            /**
             * Buffer for my events count.  Allows component to update display without direct binding to state
             */
            my_events_count_buffer: 0
        };
    },
    computed: {
        /**
         * The types that the event list can be filtered by.
         * Populate the list with each event type/category unique value
         */
        event_type_options: function () {
            return this.available_events.reduce(function (carry, event) {
                if (carry.indexOf(event.category) === -1) {
                    carry.push(event.category);
                }
                return carry;
            }, []);
        },
        /**
         * The events that have been selected by the user
         */
        selected_events: function () {
            return this.available_events.filter(function (event) {
                return event.is_selected;
            });
        },
        /**
         * Events to show in "My Events" tray
         * Selected and registered events
         */
        my_events: function () {
            return this.available_events.filter(function (event) {
                return event.is_registered_for || event.is_selected;
            });
        },
        /**
         * List of events for display in the available event area
         */
        display_events: function () {
            var type_filter = this.active_type;
            if (!type_filter) {
                return this.available_events;
            }
            return this.available_events.filter(function (event) {
                return event.category === type_filter;
            });
        },
        /**
         * The paginated list of display events
         */
        paginated_events: function () {
            return _services_PaginationService__WEBPACK_IMPORTED_MODULE_1__["PaginationService"].paginate(this.display_events, CONFIG.results_per_page);
        },
        /**
         * The events from the active page of the pagination
         */
        visible_events: function () {
            return this.paginated_events[this.active_page_index];
        },
        /**
         * Whether to show the pagination
         */
        show_pagination: function () {
            return this.visible_events.length > 0;
        }
    },
    watch: {
        /**
         * When active type filter changes, go to first page of paginated results
         */
        active_type: function () {
            this.active_page_index = 0;
            var pagination_component = this.$refs.pagination ? this.$refs.pagination : null;
            if (pagination_component) {
                pagination_component.setActivePage(0);
            }
        },
        /**
         * Watch available events from state and update the buffer on change
         */
        state_available_events: function (value) {
            this.available_events_buffer = value;
        },
        /**
         * Watch change to my events length and update my events count buffer
         */
        'my_events.length': function (value) {
            this.my_events_count_buffer = value;
        }
    },
    /**
     * On creation, set the initial state of available events and my events count
     */
    created: function () {
        var _this = this;
        this.available_events = this.state_available_events.slice();
        this.$nextTick(function () {
            _this.my_events_count = _this.my_events.length;
        });
    },
    methods: {
        /**
         * Update local state values following an update to state
         * 1. Find the new page within the pagination of the active event
         * 2. Assign the active page and the events list to local state
         * 3. Update pagination component to display proper page
         */
        updateAvailableEvents: function () {
            var _this = this;
            var new_events = this.available_events_buffer.slice();
            var new_page_index = 0;
            // If the event was added/removed from the available area, find what its new page would be and preload it
            var index = 0;
            if (this.active_event_tracking_id && this.active_event_tracking_id > 0) {
                for (var i = 0; i < new_events.length; i++) {
                    var newEvent = new_events[i];
                    // if there's an active type filter and the event doesn't match, it won't factor into pagination
                    if (this.active_type && newEvent.category !== this.active_type) {
                        // eslint-disable-next-line no-continue
                        continue;
                    }
                    if (newEvent.id === this.active_event_tracking_id) {
                        new_page_index = Math.floor(index / CONFIG.results_per_page);
                        break;
                    }
                    index++;
                }
            }
            this.available_events = new_events;
            this.active_page_index = new_page_index;
            this.$nextTick(function () {
                var pagination_component = _this.$refs.pagination ? _this.$refs.pagination : null;
                if (pagination_component) {
                    pagination_component.setActivePage(new_page_index);
                }
            });
        },
        /**
         * Animate changes to "My Events" section
         */
        animateMyEventsChange: function (prop) {
            var _this = this;
            this[prop] = true;
            setTimeout(function () {
                _this[prop] = false;
            }, CONFIG.my_event_change_duration);
            setTimeout(function () {
                _this.my_events_count = _this.my_events_count_buffer;
            }, CONFIG.my_event_change_duration / 2);
        },
        /**
         * Handle component flows following a change to state values
         * 1. Trigger local events state update.
         * 2. Trigger My Events animation change
         * 3. Clear the active item messaging
         */
        postEventsChange: function (change_type) {
            var _this = this;
            this.disable_event_selection = false;
            this.updateAvailableEvents();
            this.animateMyEventsChange(change_type);
            setTimeout(function () {
                _this.clearActiveMessage();
            }, CONFIG.feedback_show_duration / 2);
        },
        /**
         * Handle component flows following a submission error
         * 1. Display error message, then clear it
         */
        postEventError: function (error_message) {
            var _this = this;
            this.displayMessage(error_message, 'error');
            setTimeout(function () {
                _this.clearActiveMessage();
                _this.disable_event_selection = false;
            }, CONFIG.error_show_duration);
        },
        /**
         * Handle the add event fired on an event tile.
         * Start add data submission process and respond with success or error messaging
         */
        addEvent: function (event, event_tracking_id) {
            var _this = this;
            this.active_event_tracking_id = event_tracking_id;
            this.active_event_message = null;
            this.disable_event_selection = true;
            this.addEventAction(event)
                .then(function () {
                _this.displayMessage('Event added', 'success');
                setTimeout(function () {
                    _this.postEventsChange('element_added');
                }, CONFIG.feedback_in_duration + (CONFIG.feedback_show_duration / 2));
            })
                .catch(function (error_message) {
                _this.postEventError(error_message);
            });
        },
        /**
         * Action to perform add event
         */
        addEventAction: function (event) {
            return new Promise(function (resolve, reject) {
                reject("Add event action not configured for " + event.name);
            });
        },
        /**
         * Handle the remove event fired on an event tile.
         * Start remove data submission process and respond with success or error messaging
         */
        removeEvent: function (event, tracking_id) {
            var _this = this;
            this.active_event_tracking_id = tracking_id;
            this.active_event_message = null;
            this.disable_event_selection = true;
            var my_events_section_removal_flag = tracking_id < 0;
            this.removeEventAction(event)
                .then(function () {
                /**
                 * If removing from my events, don't display a message and just fire the post message display event
                 */
                if (my_events_section_removal_flag) {
                    _this.postEventsChange('element_removed');
                    return;
                }
                /**
                 * Otherwise, follow standard change flow
                 */
                _this.displayMessage('Event removed', 'error');
                setTimeout(function () {
                    _this.postEventsChange('element_removed');
                }, CONFIG.feedback_in_duration + (CONFIG.feedback_show_duration / 2));
            })
                .catch(function (error_message) {
                _this.postEventError(error_message);
            });
        },
        /**
         * Action to perform remove event
         */
        removeEventAction: function (event) {
            return new Promise(function (resolve, reject) {
                reject("Remove event action not configured for " + event.name);
            });
        },
        /**
         * Set the current display message for the active event tile
         */
        displayMessage: function (message, status) {
            this.active_event_message = message;
            this.active_event_status = status;
        },
        /**
         * Clear the current active messaging component properties
         * Clear the message and reset the active event index
         */
        clearActiveMessage: function () {
            this.active_event_message = null;
            this.active_event_status = null;
            this.active_event_tracking_id = null;
        },
        /**
         * Handle the event where a user clicks the close button on an event error message
         * Clear the current timeout that would hide the message, and reset component error-related properties
         */
        closeEventError: function () {
            this.clearActiveMessage();
            this.disable_event_selection = false;
        },
        /**
         * Get the active error message for a event tile index.
         * Returns false if no error message active on the tile
         */
        eventMessage: function (index) {
            if (!this.active_event_message) {
                return false;
            }
            if (index === this.active_event_tracking_id) {
                return this.active_event_message;
            }
            return false;
        },
        /**
         * Handle the active page change on the pagination
         */
        updateActivePage: function (page_index) {
            this.active_page_index = page_index;
        }
    }
}));


/***/ }),

/***/ "./src/js/mixins/FormMixin.ts":
/*!************************************!*\
  !*** ./src/js/mixins/FormMixin.ts ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _models_FormValidator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../models/FormValidator */ "./src/js/models/FormValidator.ts");
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
/* harmony import */ var _models_FormState__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../models/FormState */ "./src/js/models/FormState.ts");



/**
 * Mixin to be used as a foundation for a form.
 * Include form state data
 * Run validator against form state
 * Provide field class and message information based on validation state
 *
 */
/* harmony default export */ __webpack_exports__["default"] = (vue__WEBPACK_IMPORTED_MODULE_1__["default"].extend({
    props: {
        /**
         * External error provided by parent
         */
        external_error: {
            type: String,
            required: false
        },
        /**
         * Whether parent is submitting emitted data
         */
        submitting: {
            type: Boolean,
            required: false
        }
    },
    data: function () {
        return {
            /**
             * The validator to use against the form data
             */
            validator_class: _models_FormValidator__WEBPACK_IMPORTED_MODULE_0__["FormValidator"],
            /**
             * State form data class
             */
            form_data: new _models_FormState__WEBPACK_IMPORTED_MODULE_2__["FormState"](),
            /**
             * Whether a submission attempt has been made
             */
            submit_attempt: false
        };
    },
    methods: {
        /**
         * Class to apply to a field.  Error and success states based on validation state
         */
        fieldClass: function (field_name) {
            if (!this.submit_attempt) {
                return;
            }
            if (field_name in this.errors) {
                return "has-error";
            }
            if (this.form_data[field_name]) {
                return "has-success";
            }
        },
        /**
         * Message to display for a field.  Based on validation state
         */
        fieldMessage: function (field_name) {
            if (!this.submit_attempt) {
                return;
            }
            if (field_name in this.messages) {
                return this.messages[field_name][0];
            }
        },
    },
    computed: {
        /**
         * The validation result on the form
         */
        validation_result: function () {
            return new this.validator_class(this.form_data).validate();
        },
        /**
         * Validation errors on the form
         */
        errors: function () {
            return this.validation_result.errors;
        },
        /**
         * Validation messages on the form
         */
        messages: function () {
            return this.validation_result.messages;
        },
        /**
         * Whether the form is valid
         */
        valid: function () {
            return Object.keys(this.errors).length === 0;
        },
    },
    watch: {
        form_data: {
            handler: function () {
                this.$emit('changed');
            },
            deep: true
        }
    }
}));


/***/ }),

/***/ "./src/js/mixins/HasCompetitionRegistrationCompetitionMixin.ts":
/*!*********************************************************************!*\
  !*** ./src/js/mixins/HasCompetitionRegistrationCompetitionMixin.ts ***!
  \*********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");

/* harmony default export */ __webpack_exports__["default"] = (vue__WEBPACK_IMPORTED_MODULE_0__["default"].extend({
    computed: {
        active_competition: function () {
            return this.$store.getters['competition_registration/active_competition'];
        },
        competition: function () {
            return this.active_competition.competition;
        }
    }
}));


/***/ }),

/***/ "./src/js/mixins/HasDataDependencies.ts":
/*!**********************************************!*\
  !*** ./src/js/mixins/HasDataDependencies.ts ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");

/* harmony default export */ __webpack_exports__["default"] = (vue__WEBPACK_IMPORTED_MODULE_0__["default"].extend({
    /**
     * Handle data loading and loading state-related variables upon component creation
     */
    created: function () {
        var _this = this;
        this.initLoadingTimeout();
        this.preDataLoad()
            .then(function () {
            _this.loadData().catch(function () {
                _this.load_error = true;
            });
        });
    },
    data: function () {
        return {
            /**
             * Dependencies for component loading
             */
            dependencies: {},
            /**
             * Whether there was an error loading component dependencies
             */
            load_error: false,
            /**
             * Timeout after which to display a loading message if data is not yet loaded
             */
            loading_timeout: false,
        };
    },
    methods: {
        /**
         * Start the loading timeout.  Log value after expiration
         */
        initLoadingTimeout: function () {
            var _this = this;
            setTimeout(function () {
                _this.loading_timeout = true;
            }, 200);
        },
        /**
         * Load dependencies
         */
        loadData: function () {
            return new Promise(function (resolve, reject) {
                resolve();
            });
        },
        /**
         * Action to take prior to data load attempt
         */
        preDataLoad: function () {
            return new Promise(function (resolve) {
                resolve();
            });
        }
    },
    computed: {
        /**
         * Whether the component data is fully loaded.
         */
        loaded: function () {
            for (var i in this.dependencies) {
                if (this.dependencies.hasOwnProperty(i)) {
                    var obj = this.dependencies[i];
                    if (obj !== true) {
                        return false;
                    }
                }
            }
            return true;
        },
        /**
         * Whether the component successfully loaded
         */
        component_loaded: function () {
            return this.loaded && !this.load_error;
        }
    }
}));


/***/ }),

/***/ "./src/js/models/BillingAddress.ts":
/*!*****************************************!*\
  !*** ./src/js/models/BillingAddress.ts ***!
  \*****************************************/
/*! exports provided: BillingAddress */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BillingAddress", function() { return BillingAddress; });
var BillingAddress = /** @class */ (function () {
    function BillingAddress(parameters) {
        this.street_2 = null;
        this.is_default = false;
        var id = parameters.id, first_name = parameters.first_name, last_name = parameters.last_name, street = parameters.street, street_2 = parameters.street_2, city = parameters.city, state = parameters.state, zip_code = parameters.zip_code, is_default = parameters.is_default, country = parameters.country, province = parameters.province;
        this.id = id;
        this.first_name = first_name;
        this.last_name = last_name;
        this.street = street;
        if (street_2) {
            this.street_2 = street_2;
        }
        this.city = city;
        this.state = state || null;
        this.country = country || null;
        this.province = province || null;
        this.zip_code = zip_code;
        this.is_default = is_default;
    }
    Object.defineProperty(BillingAddress.prototype, "full_name", {
        get: function () {
            return this.first_name + " " + this.last_name;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BillingAddress.prototype, "city_state_zip", {
        get: function () {
            return this.city + ", " + (this.state ? this.state.label : (this.province ? this.province.label : "")) + " " + this.zip_code;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BillingAddress.prototype, "full_address", {
        get: function () {
            var address = this.street;
            if (this.street_2) {
                address += ", " + this.street_2;
            }
            address += ", " + this.city_state_zip;
            return address;
        },
        enumerable: true,
        configurable: true
    });
    return BillingAddress;
}());



/***/ }),

/***/ "./src/js/models/Cart/Cart.ts":
/*!************************************!*\
  !*** ./src/js/models/Cart/Cart.ts ***!
  \************************************/
/*! exports provided: Cart */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Cart", function() { return Cart; });
/* harmony import */ var _Collections_CartSessionCollection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Collections/CartSessionCollection */ "./src/js/models/Collections/CartSessionCollection.ts");
/* harmony import */ var _CartCreditCollection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./CartCreditCollection */ "./src/js/models/Cart/CartCreditCollection.ts");
/* harmony import */ var _CartCreditPackageCollection__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./CartCreditPackageCollection */ "./src/js/models/Cart/CartCreditPackageCollection.ts");
var __assign = (undefined && undefined.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};



var Cart = /** @class */ (function () {
    function Cart(sessions, cost, credits, credit_packages) {
        this.total_cost = 0;
        this._additional_fees = [];
        this._subtotal = null;
        this.registration_items = [];
        this.scheduled_sessions = new _Collections_CartSessionCollection__WEBPACK_IMPORTED_MODULE_0__["CartSessionCollection"](sessions);
        this.credits = new _CartCreditCollection__WEBPACK_IMPORTED_MODULE_1__["CartCreditCollection"](credits);
        this.credit_packages = new _CartCreditPackageCollection__WEBPACK_IMPORTED_MODULE_2__["CartCreditPackageCollection"](credit_packages);
        this.total_cost = cost;
    }
    Object.defineProperty(Cart.prototype, "subtotal", {
        get: function () {
            return this._subtotal;
        },
        set: function (value) {
            this._subtotal = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Cart.prototype, "additional_fees", {
        get: function () {
            return this._additional_fees;
        },
        set: function (value) {
            this._additional_fees = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Cart.prototype, "session_ids", {
        get: function () {
            return this.scheduled_sessions.ids();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Cart.prototype, "sessions", {
        get: function () {
            return this.scheduled_sessions.session_collection;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Cart.prototype, "item_count", {
        get: function () {
            return this.scheduled_sessions.count() + this.credits.credit_count() + this.credit_packages.count() + this.registration_items.length;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Cart.prototype, "items", {
        get: function () {
            var result = this.scheduled_sessions.all();
            result = result.concat(this.credit_packages.all());
            result = result.concat(this.credits.export());
            result = result.concat(this.registration_items);
            return result;
        },
        enumerable: true,
        configurable: true
    });
    Cart.prototype.isEmpty = function () {
        return this.item_count === 0;
    };
    Cart.prototype.addSession = function (cart_session) {
        this.scheduled_sessions.add(cart_session);
        this.total_cost += cart_session.cost;
    };
    Cart.prototype.removeSession = function (session_id) {
        var cart_session = this.scheduled_sessions.find(session_id);
        if (cart_session) {
            this.total_cost -= cart_session.cost;
        }
        this.scheduled_sessions.remove(session_id);
    };
    Cart.prototype.contains = function (session) {
        return this.scheduled_sessions.containsSession(session);
    };
    Cart.prototype.addCredits = function (credits) {
        for (var i = 0; i < credits.length; i++) {
            var credit = credits[i];
            this.credits.add(credit);
            this.total_cost += credit.cost;
        }
    };
    Cart.prototype.addPackages = function (packages) {
        for (var i = 0; i < packages.length; i++) {
            var credit_package = packages[i];
            this.credit_packages.add(credit_package);
            this.total_cost += credit_package.cost;
        }
    };
    Cart.prototype.getIndexedEventCreditsUsed = function (event_ids, exclude_credits) {
        var result = {};
        for (var i = 0; i < event_ids.length; i++) {
            var event_id = event_ids[i];
            result[event_id] = this.getEventCreditsUsed(event_id, exclude_credits);
        }
        return result;
    };
    /**
     * Get IndexedEventCreditList for listing all session credit types used, and all credit/packages of the specified types used
     */
    Cart.prototype.getIndexedEventCreditsSpent = function (event_ids, session_types) {
        var index_cart_session_credits = this.getIndexedEventCreditsUsed(event_ids, true);
        var cart_filled_credit_types = this.getEventCreditsUsedFiltered(event_ids, session_types);
        for (var i in cart_filled_credit_types) {
            var obj = cart_filled_credit_types[i];
            if (!index_cart_session_credits.hasOwnProperty(String(obj.event_id))) {
                index_cart_session_credits[obj.event_id] = {
                    event_id: obj.event_id,
                    opi: 0,
                    upi: 0,
                    wu: 0
                };
            }
            index_cart_session_credits[obj.event_id].opi += obj.opi;
            index_cart_session_credits[obj.event_id].upi += obj.upi;
            index_cart_session_credits[obj.event_id].wu += obj.wu;
        }
        return index_cart_session_credits;
    };
    /**
     * Report the credits present in the cart for an event.
     *
     * Includes single credits and credit packages
     */
    Cart.prototype.getCreditReport = function (event_id) {
        var result = {
            opi: 0,
            upi: 0,
            wu: 0
        };
        var single_credit_report = this.credits.getEventReport(event_id);
        var package_report = this.credit_packages.getEventReport(event_id);
        for (var i in result) {
            result[i] = single_credit_report[i] + package_report[i];
        }
        return result;
    };
    /**
     * For an event, add up the credits used by sessions and credits and in the cart
     *
     * Option to exclude credits from totals
     */
    Cart.prototype.getEventCreditsUsed = function (event_id, exclude_credits) {
        var result = __assign({ event_id: event_id }, this.scheduled_sessions.eventId(event_id).creditsUsed());
        if (exclude_credits !== true) {
            var credit_counts = this.getCreditReport(event_id);
            for (var i in result) {
                if (i === 'event_id') {
                    continue;
                }
                result[i] += credit_counts[i] ? credit_counts[i] : 0;
            }
        }
        return result;
    };
    Cart.prototype.removeCredit = function (credit) {
        this.credits.remove(credit);
        this.total_cost -= credit.cost;
    };
    Cart.prototype.removeCreditPackage = function (credit_package) {
        this.credit_packages.remove(credit_package);
        this.total_cost -= credit_package.cost;
    };
    Cart.prototype.containsPackage = function (credit_package) {
        return this.credit_packages.contains(credit_package);
    };
    Cart.prototype.getEventCreditsUsedFiltered = function (event_ids, schedulable_session_types) {
        var result = {};
        for (var i = 0; i < event_ids.length; i++) {
            var event_id = event_ids[i];
            var event_credit_report = this.getCreditReport(event_id);
            var types = ['opi', 'upi', 'wu'];
            for (var j = 0; j < types.length; j++) {
                var type = types[j];
                if (schedulable_session_types.indexOf(type) === -1) {
                    event_credit_report[type] = 0;
                }
            }
            result[event_id] = __assign({ event_id: event_id }, event_credit_report);
        }
        return result;
    };
    Cart.prototype.setCostProperties = function (cost_properties) {
        if (cost_properties.total !== false) {
            this.total_cost = cost_properties.total;
        }
        if (cost_properties.additional_fees !== false) {
            this.additional_fees = cost_properties.additional_fees;
        }
        if (cost_properties.subtotal !== false) {
            this.subtotal = cost_properties.subtotal;
        }
    };
    return Cart;
}());



/***/ }),

/***/ "./src/js/models/Cart/CartAdaptor.ts":
/*!*******************************************!*\
  !*** ./src/js/models/Cart/CartAdaptor.ts ***!
  \*******************************************/
/*! exports provided: CartAdaptor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CartAdaptor", function() { return CartAdaptor; });
/* harmony import */ var _CartCreditPackage__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CartCreditPackage */ "./src/js/models/Cart/CartCreditPackage.ts");
/* harmony import */ var _Sessions_CartSession__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Sessions/CartSession */ "./src/js/models/Sessions/CartSession.ts");
var __assign = (undefined && undefined.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};


var CartAdaptor = /** @class */ (function () {
    function CartAdaptor() {
    }
    CartAdaptor.adaptCreditPackage = function (parameters) {
        var credit_package = parameters.credit_package, event = parameters.event, competition = parameters.competition;
        return new _CartCreditPackage__WEBPACK_IMPORTED_MODULE_0__["CartCreditPackage"]({
            id: credit_package.id,
            cost: credit_package.cost,
            event_id: event.id,
            event_name: event.name,
            competition_name: competition.name,
            competition_id: competition.id,
            name: credit_package.name,
            credits: credit_package.credits
        });
    };
    CartAdaptor.adaptCartSessionPayloadCartSession = function (payload) {
        return new _Sessions_CartSession__WEBPACK_IMPORTED_MODULE_1__["CartSession"](__assign({}, payload.session, { cost: payload.cost, competition_id: payload.competition_id, scheduled_event_name: payload.event_name, competition_name: payload.competition_name }));
    };
    return CartAdaptor;
}());



/***/ }),

/***/ "./src/js/models/Cart/CartCredit.ts":
/*!******************************************!*\
  !*** ./src/js/models/Cart/CartCredit.ts ***!
  \******************************************/
/*! exports provided: CartCredit */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CartCredit", function() { return CartCredit; });
var CartCredit = /** @class */ (function () {
    function CartCredit(parameters) {
        this.cart_item_type_key = "credit";
        var competition_id = parameters.competition_id, event_name = parameters.event_name, competition_name = parameters.competition_name, event_id = parameters.event_id, credit_type = parameters.credit_type, amount = parameters.amount, cost = parameters.cost;
        this.competition_id = competition_id;
        this.event_name = event_name;
        this.competition_name = competition_name;
        this.event_id = event_id;
        this.credit_type = credit_type;
        this.amount = amount;
        this.cost = cost;
        this.cart_description = this.credit_type.toUpperCase() + " Credit";
    }
    return CartCredit;
}());



/***/ }),

/***/ "./src/js/models/Cart/CartCreditCollection.ts":
/*!****************************************************!*\
  !*** ./src/js/models/Cart/CartCreditCollection.ts ***!
  \****************************************************/
/*! exports provided: CartCreditCollection */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CartCreditCollection", function() { return CartCreditCollection; });
var __assign = (undefined && undefined.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
var CartCreditCollection = /** @class */ (function () {
    function CartCreditCollection(init_credits) {
        this.cart_credits = [];
        this.cart_credits = init_credits ? init_credits : [];
    }
    CartCreditCollection.prototype.credit_count = function () {
        var total = 0;
        for (var i = 0; i < this.cart_credits.length; i++) {
            total += this.cart_credits[i].amount;
        }
        return total;
    };
    CartCreditCollection.prototype.count = function () {
        return this.cart_credits.length;
    };
    CartCreditCollection.prototype.add = function (credit) {
        this.cart_credits.push(credit);
    };
    CartCreditCollection.prototype.remove = function (credit) {
        for (var i = 0; i < this.cart_credits.length; i++) {
            var cart_credit = this.cart_credits[i];
            var unit_cost = cart_credit.cost / cart_credit.amount;
            if (cart_credit.event_id == credit.event_id && cart_credit.credit_type == credit.credit_type && cart_credit.amount > 0) {
                cart_credit.amount--;
                cart_credit.cost -= unit_cost;
                return;
            }
        }
    };
    CartCreditCollection.prototype.eventId = function (event_id) {
        return new CartCreditCollection(this.cart_credits.filter(function (cart_credit) {
            return cart_credit.event_id === event_id;
        }));
    };
    CartCreditCollection.prototype.getReport = function () {
        var credits = {};
        return this.cart_credits.reduce(function (accumulator, credit) {
            if (!accumulator.hasOwnProperty(String(credit.event_id))) {
                accumulator[credit.event_id] = {
                    event_id: credit.event_id,
                    opi: 0,
                    upi: 0,
                    wu: 0
                };
            }
            accumulator[credit.event_id][credit.credit_type] += credit.amount;
            return accumulator;
        }, credits);
    };
    CartCreditCollection.prototype.getEventReport = function (event_id) {
        var result = {
            opi: 0,
            upi: 0,
            wu: 0
        };
        var event_credits = this.eventId(event_id);
        if (event_credits.count() === 0) {
            return result;
        }
        var temp = __assign({}, event_credits.getReport()[event_id]);
        delete temp['event_id'];
        return temp;
    };
    CartCreditCollection.prototype.export = function () {
        return this.cart_credits.reduce(function (accumulator, cart_credit) {
            var credit_single_cost = cart_credit.cost / cart_credit.amount;
            for (var i = 0; i < cart_credit.amount; i++) {
                accumulator.push(__assign({}, cart_credit, { cost: credit_single_cost, amount: 1 }));
            }
            return accumulator;
        }, []);
    };
    return CartCreditCollection;
}());



/***/ }),

/***/ "./src/js/models/Cart/CartCreditPackage.ts":
/*!*************************************************!*\
  !*** ./src/js/models/Cart/CartCreditPackage.ts ***!
  \*************************************************/
/*! exports provided: CartCreditPackage */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CartCreditPackage", function() { return CartCreditPackage; });
var CartCreditPackage = /** @class */ (function () {
    function CartCreditPackage(parameters) {
        this.cart_item_type_key = "credit_package";
        this.cost = parameters.cost;
        this.competition_id = parameters.competition_id;
        this.event_id = parameters.event_id;
        this.event_name = parameters.event_name;
        this.competition_name = parameters.competition_name;
        this.id = parameters.id;
        this.name = parameters.name;
        this.credits = parameters.credits;
    }
    Object.defineProperty(CartCreditPackage.prototype, "cart_description", {
        get: function () {
            return "Credit Package: " + this.name;
        },
        enumerable: true,
        configurable: true
    });
    return CartCreditPackage;
}());



/***/ }),

/***/ "./src/js/models/Cart/CartCreditPackageCollection.ts":
/*!***********************************************************!*\
  !*** ./src/js/models/Cart/CartCreditPackageCollection.ts ***!
  \***********************************************************/
/*! exports provided: CartCreditPackageCollection */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CartCreditPackageCollection", function() { return CartCreditPackageCollection; });
var CartCreditPackageCollection = /** @class */ (function () {
    function CartCreditPackageCollection(init_packages) {
        this.credit_packages = [];
        this.credit_packages = init_packages ? init_packages : [];
    }
    CartCreditPackageCollection.prototype.add = function (credit_package) {
        this.credit_packages.push(credit_package);
    };
    CartCreditPackageCollection.prototype.count = function () {
        return this.credit_packages.length;
    };
    CartCreditPackageCollection.prototype.contains = function (credit_package_check) {
        for (var i = 0; i < this.credit_packages.length; i++) {
            var credit_package = this.credit_packages[i];
            if (credit_package_check.id === credit_package.id) {
                return true;
            }
        }
        return false;
    };
    CartCreditPackageCollection.prototype.all = function () {
        return this.credit_packages;
    };
    CartCreditPackageCollection.prototype.remove = function (credit_package) {
        for (var i = 0; i < this.credit_packages.length; i++) {
            var internal = this.credit_packages[i];
            if (internal.id === credit_package.id) {
                this.credit_packages.splice(i, 1);
                return;
            }
        }
    };
    /**
     * Get the total amount of credits represented by a CreditPackageCollection
     */
    CartCreditPackageCollection.prototype.totalCredits = function () {
        var initialValue = {
            opi: 0,
            upi: 0,
            wu: 0
        };
        return this.credit_packages.reduce(function (accumulator, credit_package) {
            var credits = credit_package.credits;
            for (var i in accumulator) {
                accumulator[i] += credits[i];
            }
            return accumulator;
        }, initialValue);
    };
    /**
     * Filter by a certain event id
     */
    CartCreditPackageCollection.prototype.eventId = function (event_id) {
        return new CartCreditPackageCollection(this.credit_packages.filter(function (credit_package) {
            return credit_package.event_id === event_id;
        }));
    };
    /**
     * Get the credits used for a certain event
     */
    CartCreditPackageCollection.prototype.getEventReport = function (event_id) {
        return this.eventId(event_id).totalCredits();
    };
    return CartCreditPackageCollection;
}());



/***/ }),

/***/ "./src/js/models/Collections/CartSessionCollection.ts":
/*!************************************************************!*\
  !*** ./src/js/models/Collections/CartSessionCollection.ts ***!
  \************************************************************/
/*! exports provided: CartSessionCollection */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CartSessionCollection", function() { return CartSessionCollection; });
/* harmony import */ var _ScheduledSessionCollection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ScheduledSessionCollection */ "./src/js/models/Collections/ScheduledSessionCollection.ts");
/* harmony import */ var _SessionCollection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SessionCollection */ "./src/js/models/Collections/SessionCollection.ts");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();


var CartSessionCollection = /** @class */ (function (_super) {
    __extends(CartSessionCollection, _super);
    function CartSessionCollection(scheduled_sessions) {
        var _this = _super.call(this, scheduled_sessions) || this;
        _this.scheduled_sessions = scheduled_sessions;
        return _this;
    }
    CartSessionCollection.prototype.find = function (session_id) {
        return _super.prototype.find.call(this, session_id);
    };
    CartSessionCollection.prototype.getTotalCost = function () {
        return this.scheduled_sessions.reduce(function (result, scheduled_session) {
            return result + scheduled_session.cost;
        }, 0);
    };
    CartSessionCollection.prototype.all = function () {
        return this.scheduled_sessions;
    };
    Object.defineProperty(CartSessionCollection.prototype, "session_collection", {
        get: function () {
            var result = new _SessionCollection__WEBPACK_IMPORTED_MODULE_1__["SessionCollection"]([]);
            for (var i = 0; i < this.scheduled_sessions.length; i++) {
                var scheduled_session = this.scheduled_sessions[i];
                result.add(scheduled_session.session);
            }
            return result;
        },
        enumerable: true,
        configurable: true
    });
    return CartSessionCollection;
}(_ScheduledSessionCollection__WEBPACK_IMPORTED_MODULE_0__["ScheduledSessionCollection"]));



/***/ }),

/***/ "./src/js/models/Collections/ScheduledSessionCollection.ts":
/*!*****************************************************************!*\
  !*** ./src/js/models/Collections/ScheduledSessionCollection.ts ***!
  \*****************************************************************/
/*! exports provided: ScheduledSessionCollection */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ScheduledSessionCollection", function() { return ScheduledSessionCollection; });
var ScheduledSessionCollection = /** @class */ (function () {
    function ScheduledSessionCollection(scheduled_sessions) {
        this.scheduled_sessions = scheduled_sessions;
    }
    ScheduledSessionCollection.prototype.all = function () {
        return this.scheduled_sessions;
    };
    ScheduledSessionCollection.prototype.count = function () {
        return this.scheduled_sessions.length;
    };
    ScheduledSessionCollection.prototype.ids = function () {
        return this.scheduled_sessions.map(function (session) {
            return session.session.id;
        });
    };
    ScheduledSessionCollection.prototype.add = function (scheduled_session) {
        this.scheduled_sessions.push(scheduled_session);
    };
    ScheduledSessionCollection.prototype.eventId = function (event_id) {
        return new ScheduledSessionCollection(this.scheduled_sessions.filter(function (scheduled_session) {
            return scheduled_session.scheduled_event_id === event_id;
        }));
    };
    ScheduledSessionCollection.prototype.sessions = function () {
        return this.scheduled_sessions.map(function (scheduled_session) {
            return scheduled_session.session;
        });
    };
    ScheduledSessionCollection.prototype.creditsUsed = function () {
        var result = {
            opi: 0,
            upi: 0,
            wu: 0
        };
        this.scheduled_sessions.forEach(function (session) {
            result[session.scheduled_as]++;
        });
        return result;
    };
    ScheduledSessionCollection.prototype.getEventScheduledTypeAmounts = function (event_id) {
        this.eventId(event_id).creditsUsed();
    };
    ScheduledSessionCollection.prototype.containsSession = function (session) {
        for (var i = 0; i < this.scheduled_sessions.length; i++) {
            var scheduled_session = this.scheduled_sessions[i];
            if (scheduled_session.session.id === session.id) {
                return true;
            }
        }
        return false;
    };
    ScheduledSessionCollection.prototype.find = function (session_id) {
        for (var i = 0; i < this.scheduled_sessions.length; i++) {
            var obj = this.scheduled_sessions[i];
            if (obj.session.id === session_id) {
                return obj;
            }
        }
        return null;
    };
    ScheduledSessionCollection.prototype.remove = function (session_id) {
        var session_index = -1;
        for (var i = 0; i < this.scheduled_sessions.length; i++) {
            var obj = this.scheduled_sessions[i];
            if (obj.session.id === session_id) {
                session_index = i;
            }
        }
        if (session_index !== -1) {
            this.scheduled_sessions.splice(session_index, 1);
            return true;
        }
        return false;
    };
    ScheduledSessionCollection.prototype.reorderSessionTimeStart = function () {
        this.scheduled_sessions.sort(function (a, b) {
            if (a.session.time_start > b.session.time_start) {
                return 1;
            }
            if (b.session.time_start > a.session.time_start) {
                return -1;
            }
            return 0;
        });
    };
    ScheduledSessionCollection.prototype.creditReport = function () {
        var result = {};
        for (var i = 0; i < this.scheduled_sessions.length; i++) {
            var session = this.scheduled_sessions[i];
            if (!result.hasOwnProperty(String(session.scheduled_event_id))) {
                result[session.scheduled_event_id] = {
                    event_id: session.scheduled_event_id,
                    opi: 0,
                    upi: 0,
                    wu: 0
                };
            }
            result[session.scheduled_event_id][session.scheduled_as]++;
        }
        return result;
    };
    return ScheduledSessionCollection;
}());



/***/ }),

/***/ "./src/js/models/Collections/SessionCollection.ts":
/*!********************************************************!*\
  !*** ./src/js/models/Collections/SessionCollection.ts ***!
  \********************************************************/
/*! exports provided: SessionCollection */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SessionCollection", function() { return SessionCollection; });
/**
 * Class to manage sets of sessions
 */
var SessionCollection = /** @class */ (function () {
    function SessionCollection(sessions) {
        this.sessions = sessions;
    }
    /**
     * Return sessions that belong to a rink
     */
    SessionCollection.filterRink = function (rink_id, session_collection) {
        return new SessionCollection(session_collection.sessions.filter(function (session) {
            return session.rink.id == rink_id;
        }));
    };
    /**
     * Order sessions by date
     */
    SessionCollection.orderDate = function (session_collection) {
        return new SessionCollection(session_collection.sessions.sort(function (a, b) {
            if (a.time_start > b.time_start) {
                return 1;
            }
            if (b.time_start > a.time_start) {
                return -1;
            }
            return 0;
        }));
    };
    /**
     * Return sessions that match a date stamp
     */
    SessionCollection.filterDate = function (datestamp, session_collection) {
        if (!datestamp) {
            return session_collection;
        }
        var filter_date = new Date();
        filter_date.setTime(datestamp);
        return new SessionCollection(session_collection.sessions.filter(function (session) {
            return session.date.getFullYear() === filter_date.getFullYear() &&
                session.date.getMonth() === filter_date.getMonth() &&
                session.date.getDate() == filter_date.getDate();
        }));
    };
    /**
     * Return sessions of a certain type(s)
     * @param types - array of type_keys.  Session will be returned if it matches any of them
     * @param collection SessionCollection - collection to filter.
     */
    SessionCollection.filterType = function (types, collection) {
        return new SessionCollection(collection.sessions.filter(function (session) {
            return types.indexOf(session.type_key) !== -1;
        }));
    };
    /**
     * Return sessions that aren't fully booked
     */
    SessionCollection.filterAvailable = function (session_collection) {
        return new SessionCollection(session_collection.sessions.filter(function (session) {
            return session.is_available;
        }));
    };
    /**
     * Instance accessor
     */
    SessionCollection.prototype.filterRink = function (rink_id) {
        return SessionCollection.filterRink(rink_id, this);
    };
    /**
     * Instance accessor
     */
    SessionCollection.prototype.orderDate = function () {
        return SessionCollection.orderDate(this);
    };
    /**
     * Instance accessor
     */
    SessionCollection.prototype.filterType = function (types) {
        return SessionCollection.filterType(types, this);
    };
    /**
     * Instance accessor
     */
    SessionCollection.prototype.filterAvailable = function () {
        return SessionCollection.filterAvailable(this);
    };
    /**
     * Get an array of unique dates
     */
    SessionCollection.prototype.unique_dates = function () {
        var results = [];
        var added = [];
        this.sessions.forEach(function (session) {
            var date = new Date(session.date.getFullYear(), session.date.getMonth(), session.date.getDate(), 0, 0, 0);
            if (added.indexOf(date.getTime()) === -1) {
                results.push(date);
                added.push(date.getTime());
            }
        });
        return results;
    };
    /**
     * Instance accessor
     */
    SessionCollection.prototype.filterDate = function (datestamp) {
        return SessionCollection.filterDate(datestamp, this);
    };
    SessionCollection.filterEventIds = function (event_ids, session_collection) {
        return new SessionCollection(session_collection.sessions.filter(function (session) {
            for (var i = 0; i < session.event_ids.length; i++) {
                var event_id = session.event_ids[i];
                if (event_ids.indexOf(event_id) !== -1) {
                    return true;
                }
            }
            return false;
        }));
    };
    SessionCollection.prototype.filterEventIds = function (event_ids) {
        return SessionCollection.filterEventIds(event_ids, this);
    };
    /**
     * Return all sessions in a collection
     */
    SessionCollection.prototype.all = function () {
        return this.sessions;
    };
    /**
     * Determine if a session is in the collection
     */
    SessionCollection.prototype.contains = function (session) {
        for (var i = 0; i < this.sessions.length; i++) {
            var internal_session = this.sessions[i];
            if (internal_session.id == session.id) {
                return true;
            }
        }
        return false;
    };
    /**
     * Return a collection that only contains sessions in both collections
     */
    SessionCollection.intersect = function (target, append) {
        return new SessionCollection(append.sessions.filter(function (session) {
            return target.contains(session);
        }));
    };
    SessionCollection.exclude = function (source, exclude) {
        return new SessionCollection(source.sessions.filter(function (session) {
            return !exclude.contains(session);
        }));
    };
    SessionCollection.prototype.exclude = function (session_collecton) {
        return SessionCollection.exclude(this, session_collecton);
    };
    SessionCollection.prototype.intersect = function (append) {
        return SessionCollection.intersect(this, append);
    };
    /**
     * Return the union of two session collections.
     *
     * Result contains all shared sessions between the two with no duplicates
     */
    SessionCollection.combine = function (source, addor) {
        var source_unique = source.sessions.filter(function (session) {
            return !addor.contains(session);
        });
        return new SessionCollection(source_unique.concat(addor.sessions));
    };
    SessionCollection.prototype.combine = function (append) {
        return SessionCollection.combine(this, append);
    };
    /**
     * Add a new session to the collection
     */
    SessionCollection.prototype.add = function (session) {
        this.sessions.push(session);
    };
    /**
     * Get the amount of sessions in the collection
     */
    SessionCollection.prototype.count = function () {
        return this.sessions.length;
    };
    /**
     * Remove a session
     */
    SessionCollection.prototype.remove = function (session) {
        var index = -1;
        for (var i = 0; i < this.sessions.length; i++) {
            var internal_session = this.sessions[i];
            if (internal_session.id == session.id) {
                index = i;
            }
        }
        if (index === -1) {
            return;
        }
        this.sessions.splice(index, 1);
    };
    SessionCollection.prototype.first = function () {
        return this.sessions[0];
    };
    SessionCollection.prototype.firstDate = function () {
        var sessionCollection = this.orderDate();
        var first = sessionCollection.first();
        if (!first) {
            return null;
        }
        var date = first.date;
        return new Date(date.getFullYear(), date.getMonth(), date.getDate());
    };
    return SessionCollection;
}());



/***/ }),

/***/ "./src/js/models/Collections/SkaterCoachedEventCollection.ts":
/*!*******************************************************************!*\
  !*** ./src/js/models/Collections/SkaterCoachedEventCollection.ts ***!
  \*******************************************************************/
/*! exports provided: SkaterCoachedEventCategoryCollection */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SkaterCoachedEventCategoryCollection", function() { return SkaterCoachedEventCategoryCollection; });
var SkaterCoachedEventCategoryCollection = /** @class */ (function () {
    /**
     * Create a new SkaterCoachedEventCategoryCollection instance
     */
    function SkaterCoachedEventCategoryCollection(event_categories) {
        this._skater_coached_event_categories = [];
        if (event_categories) {
            this._skater_coached_event_categories = event_categories;
        }
    }
    /**
     * Get the array of all items in collection
     */
    SkaterCoachedEventCategoryCollection.prototype.all = function () {
        return this._skater_coached_event_categories;
    };
    /**
     * Return the event item in collection for a given event category id
     */
    SkaterCoachedEventCategoryCollection.prototype.eventCategoryId = function (event_category_id) {
        for (var i = 0; i < this._skater_coached_event_categories.length; i++) {
            var event = this._skater_coached_event_categories[i];
            if (event.id === event_category_id) {
                return event;
            }
        }
        return false;
    };
    /**
     * Return whether the collection contains a certain coach for a given event category
     */
    SkaterCoachedEventCategoryCollection.prototype.containsEventCategoryCoach = function (event_category_id, coach_id) {
        var event = this.eventCategoryId(event_category_id);
        if (event) {
            for (var i = 0; i < event.coaches.length; i++) {
                var coach = event.coaches[i];
                if (coach.id === coach_id) {
                    return true;
                }
            }
        }
        return false;
    };
    /**
     * Remove a coach given a event category id and coach id
     */
    SkaterCoachedEventCategoryCollection.prototype.remove = function (event_category_id, coach_id) {
        var event_category = this.eventCategoryId(event_category_id);
        if (event_category) {
            for (var i = 0; i < event_category.coaches.length; i++) {
                var coach = event_category.coaches[i];
                if (coach.id === coach_id) {
                    event_category.coaches.splice(i, 1);
                    return;
                }
            }
        }
    };
    /**
     * Add a coach given an event category id
     * If specified event category is not in collection, do nothing silently
     */
    SkaterCoachedEventCategoryCollection.prototype.add = function (event_category_id, coach) {
        var event_category = this.eventCategoryId(event_category_id);
        if (event_category) {
            event_category.coaches.push(coach);
        }
    };
    /**
     * Replace a specified coach given an event category ID
     * If specified event category is not in collection, do nothing silently
     */
    SkaterCoachedEventCategoryCollection.prototype.replace = function (event_category_id, previous_coach_id, replacement_coach) {
        var event_category = this.eventCategoryId(event_category_id);
        if (event_category) {
            for (var i = 0; i < event_category.coaches.length; i++) {
                var coach = event_category.coaches[i];
                if (previous_coach_id === coach.id) {
                    event_category.coaches.splice(i, 1, replacement_coach);
                    return;
                }
            }
        }
    };
    /**
     * Get the total coach count
     */
    SkaterCoachedEventCategoryCollection.prototype.coach_count = function () {
        var total = 0;
        for (var i = 0; i < this._skater_coached_event_categories.length; i++) {
            var event = this._skater_coached_event_categories[i];
            total += event.coaches.length;
        }
        return total;
    };
    return SkaterCoachedEventCategoryCollection;
}());



/***/ }),

/***/ "./src/js/models/Collections/SkatingEventCollection.ts":
/*!*************************************************************!*\
  !*** ./src/js/models/Collections/SkatingEventCollection.ts ***!
  \*************************************************************/
/*! exports provided: SkatingEventCollection */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SkatingEventCollection", function() { return SkatingEventCollection; });
var __assign = (undefined && undefined.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
var SkatingEventCollection = /** @class */ (function () {
    function SkatingEventCollection(events) {
        this.events = events;
    }
    SkatingEventCollection.prototype.ids = function () {
        return this.events.map(function (item) {
            return item.id;
        });
    };
    SkatingEventCollection.prototype.all = function () {
        return this.events;
    };
    SkatingEventCollection.prototype.add = function (event) {
        this.events.push(event);
    };
    SkatingEventCollection.prototype.find = function (id) {
        for (var i = 0; i < this.events.length; i++) {
            var event = this.events[i];
            if (event.id == id) {
                return event;
            }
        }
        return null;
    };
    SkatingEventCollection.prototype.getTypeLimits = function () {
        return this.all().reduce(function (accumulator, event) {
            accumulator[event.id] = __assign({ event_id: event.id }, event.getCreditLimits());
            return accumulator;
        }, {});
    };
    return SkatingEventCollection;
}());



/***/ }),

/***/ "./src/js/models/Competition/Competition.ts":
/*!**************************************************!*\
  !*** ./src/js/models/Competition/Competition.ts ***!
  \**************************************************/
/*! exports provided: Competition */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Competition", function() { return Competition; });
/* harmony import */ var _helpers_time__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../helpers/time */ "./src/js/helpers/time.ts");

var Competition = /** @class */ (function () {
    function Competition(data) {
        this.competition_information = {};
        this.schedule = {};
        this.name = data.name;
        this.start_date = new Date(data.start_date);
        this.end_date = new Date(data.end_date);
        this.id = data.id;
        this.icon = data.icon;
        this._schedule_available = data.schedule_available;
        this._practice_ice_available = data.practice_ice_available;
        this._active_sales_window = data.active_sales_window;
        this._directions = data.directions;
        this._announcement_url = data.announcement_url;
        this._website_url = data.website_url;
        this.start_date_pretty = Object(_helpers_time__WEBPACK_IMPORTED_MODULE_0__["DateFormat"])(this.start_date);
        this.end_date_pretty = Object(_helpers_time__WEBPACK_IMPORTED_MODULE_0__["DateFormat"])(this.end_date);
        this._detail_link = this._parseDetailLink();
        this._schedule_link = this._parseScheduleLink();
        this._information_link = this._parseInfoLink();
        this._practice_ice_link = this._parsePracticeIceLink();
        this._contacts_link = this._parseContactsLink();
        this._my_skaters_link = this._parseMySkatersLink();
        this._my_coaches_link = this._parseMyCoachesLink();
        this._music_and_ppc_link = this._parseMusicAndPPCLink();
        this._coach_competition_schedule_link = this._parseCoachCompetitionScheduleLink();
        this._coach_schedule_link = this._parseCoachScheduleLink();
    }
    Object.defineProperty(Competition.prototype, "coach_schedule_link", {
        get: function () {
            return this._coach_schedule_link;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Competition.prototype, "coach_competition_schedule_link", {
        get: function () {
            return this._coach_competition_schedule_link;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Competition.prototype, "music_and_ppc_link", {
        get: function () {
            return this._music_and_ppc_link;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Competition.prototype, "active_sales_window", {
        get: function () {
            return this._active_sales_window;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Competition.prototype, "detail_link", {
        get: function () {
            return this._detail_link;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Competition.prototype, "schedule_link", {
        get: function () {
            return this._schedule_link;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Competition.prototype, "information_link", {
        get: function () {
            return this._information_link;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Competition.prototype, "practice_ice_link", {
        get: function () {
            return this._practice_ice_link;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Competition.prototype, "contacts_link", {
        get: function () {
            return this._contacts_link;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Competition.prototype, "my_skaters_link", {
        get: function () {
            return this._my_skaters_link;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Competition.prototype, "my_coaches_link", {
        get: function () {
            return this._my_coaches_link;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Competition.prototype, "practice_ice_available", {
        get: function () {
            return this._practice_ice_available;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Competition.prototype, "schedule_available", {
        get: function () {
            return this._schedule_available;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Competition.prototype, "directions", {
        get: function () {
            return this._directions || [];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Competition.prototype, "announcement_url", {
        get: function () {
            return this._announcement_url || null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Competition.prototype, "website_url", {
        get: function () {
            return this._website_url || null;
        },
        enumerable: true,
        configurable: true
    });
    Competition.prototype.setInformation = function (information) {
        this.competition_information = information;
    };
    Competition.prototype.setSchedule = function (schedule) {
        this.schedule = schedule;
    };
    Competition.prototype._parsePracticeIceLink = function () {
        if (this.active_sales_window === "pre_purchase") {
            return "/pages/practice-ice-pre-purchase?id=" + this.id;
        }
        return "/pages/practice-ice-schedule?id=" + this.id;
    };
    Competition.prototype._parseInfoLink = function () {
        return "/pages/competition-information?id=" + this.id;
    };
    Competition.prototype._parseDetailLink = function () {
        return "/CompetitionProfile/Index?id=" + this.id;
    };
    Competition.prototype._parseScheduleLink = function () {
        return "/pages/my-schedule?id=" + this.id;
    };
    Competition.prototype._parseContactsLink = function () {
        return "/pages/competition-contacts?id=" + this.id;
    };
    Competition.prototype._parseMySkatersLink = function () {
        return "/pages/my-skaters?id=" + this.id;
    };
    Competition.prototype._parseMyCoachesLink = function () {
        return "/pages/my-coaches?id=" + this.id;
    };
    Competition.prototype._parseMusicAndPPCLink = function () {
        return "/pages/music-and-ppc?id=" + this.id;
    };
    Competition.prototype._parseCoachCompetitionScheduleLink = function () {
        return "/pages/coach-competition-schedule?id=" + this.id;
    };
    Competition.prototype._parseCoachScheduleLink = function () {
        return "/pages/coach-schedule?id=" + this.id;
    };
    return Competition;
}());



/***/ }),

/***/ "./src/js/models/Competition/CompetitionInformation.ts":
/*!*************************************************************!*\
  !*** ./src/js/models/Competition/CompetitionInformation.ts ***!
  \*************************************************************/
/*! exports provided: CompetitionInformation */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CompetitionInformation", function() { return CompetitionInformation; });
/* harmony import */ var _Collections_SkatingEventCollection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Collections/SkatingEventCollection */ "./src/js/models/Collections/SkatingEventCollection.ts");

var CompetitionInformation = /** @class */ (function () {
    function CompetitionInformation(parameters) {
        this.sales_windows = [];
        this.pricing_message = false;
        var competition_id = parameters.competition_id, sales_windows = parameters.sales_windows, skating_events = parameters.skating_events, practice_ice_instructions = parameters.practice_ice_instructions, practice_ice_terminology = parameters.practice_ice_terminology, schedulable_session_types = parameters.schedulable_session_types, _a = parameters.pricing_message, pricing_message = _a === void 0 ? false : _a, music_ppc_deadline_description = parameters.music_ppc_deadline_description, _b = parameters.ppc_deadline, ppc_deadline = _b === void 0 ? null : _b, _c = parameters.music_deadline, music_deadline = _c === void 0 ? null : _c;
        this.competition_id = competition_id;
        this.schedulable_session_types = schedulable_session_types;
        this.sales_windows = sales_windows;
        this.practice_ice_instructions = practice_ice_instructions;
        this.practice_ice_terminology = practice_ice_terminology;
        this.music_ppc_deadline_description = music_ppc_deadline_description;
        this.ppc_deadline = ppc_deadline;
        this.music_deadline = music_deadline;
        this.pricing_message = pricing_message;
        this._events = new _Collections_SkatingEventCollection__WEBPACK_IMPORTED_MODULE_0__["SkatingEventCollection"](skating_events);
        this.active_sales_window_index = CompetitionInformation._parseActiveSalesWindowIndex(sales_windows);
        /**
         * @deprecated - 2020-06-17
         */
        this.competition_documents = parameters.competition_documents;
    }
    Object.defineProperty(CompetitionInformation.prototype, "events", {
        get: function () {
            return this._events.all();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CompetitionInformation.prototype, "event_ids", {
        get: function () {
            return this._events.ids();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CompetitionInformation.prototype, "music_and_ppc_information", {
        get: function () {
            return {
                description: this.music_ppc_deadline_description,
                ppc: this.ppc_deadline,
                music: this.music_deadline
            };
        },
        enumerable: true,
        configurable: true
    });
    CompetitionInformation.blank = function () {
        return new CompetitionInformation({
            competition_id: -1,
            sales_windows: [],
            skating_events: [],
            practice_ice_instructions: '',
            practice_ice_terminology: '',
            schedulable_session_types: [],
            pricing_message: false,
            music_ppc_deadline_description: '',
            ppc_deadline: null,
            music_deadline: null,
            /**
             * @deprecated - 2020-06-17
             */
            competition_documents: {
                action_documents: [],
                reference_documents: []
            }
        });
    };
    CompetitionInformation._parseActiveSalesWindowIndex = function (sales_windows) {
        for (var i = 0; i < sales_windows.length; i++) {
            var sales_window = sales_windows[i];
            if (sales_window.is_passed) {
                continue;
            }
            if (sales_window.is_open) {
                return i;
            }
        }
        return -1;
    };
    CompetitionInformation.prototype.getEvent = function (event_id) {
        return this._events.find(event_id);
    };
    CompetitionInformation.prototype.getEventTypeLimit = function (event_id, type) {
        var event = this.getEvent(event_id);
        if (!event) {
            return 0;
        }
        return event.getTypeLimit(type);
    };
    CompetitionInformation.prototype.getEventTypeCost = function (event_id, type) {
        var event = this.getEvent(event_id);
        if (!event) {
            return 0;
        }
        return event.getTypeCost(type);
    };
    CompetitionInformation.prototype.sessionTypeIsSelectable = function (type) {
        return this.schedulable_session_types.indexOf(type) !== -1;
    };
    /**
     * Get an array of the session's types that are skater selectable
     */
    CompetitionInformation.prototype.filterSessionSchedulableTypes = function (session) {
        var valid_session_types = this.schedulable_session_types;
        return session.credit_types.filter(function (session_type) {
            return valid_session_types.indexOf(session_type) !== -1;
        });
    };
    CompetitionInformation.prototype.getEventsTypeLimits = function () {
        return this._events.getTypeLimits();
    };
    return CompetitionInformation;
}());



/***/ }),

/***/ "./src/js/models/Competition/CompetitionSchedule.ts":
/*!**********************************************************!*\
  !*** ./src/js/models/Competition/CompetitionSchedule.ts ***!
  \**********************************************************/
/*! exports provided: CompetitionSchedule */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CompetitionSchedule", function() { return CompetitionSchedule; });
/* harmony import */ var _RinkSchedule_RinkSchedule__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../RinkSchedule/RinkSchedule */ "./src/js/models/RinkSchedule/RinkSchedule.ts");
/* harmony import */ var _Collections_SessionCollection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Collections/SessionCollection */ "./src/js/models/Collections/SessionCollection.ts");


var CompetitionSchedule = /** @class */ (function () {
    function CompetitionSchedule(facilities, rinks, sessions) {
        this.rink_schedules = [];
        this._legend = null;
        this._links = {};
        this.rinks = rinks;
        this.sessions = new _Collections_SessionCollection__WEBPACK_IMPORTED_MODULE_1__["SessionCollection"](sessions);
        this._unique_dates = this.sessions.unique_dates();
        this.facilities = facilities;
        this._buildRinkSchedules(rinks, sessions);
    }
    Object.defineProperty(CompetitionSchedule.prototype, "legend", {
        get: function () {
            return this._legend;
        },
        set: function (value) {
            this._legend = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CompetitionSchedule.prototype, "links", {
        get: function () {
            return this._links;
        },
        set: function (value) {
            this._links = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CompetitionSchedule.prototype, "download_schedule_link", {
        /**
         * Get the download schedule link, if it's available
         */
        get: function () {
            if (this.links && typeof this.links.download_schedule === 'string') {
                return this.links.download_schedule;
            }
            return null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CompetitionSchedule.prototype, "admin_edit_schedule_link", {
        get: function () {
            if (this.links && typeof this.links.admin_edit === 'string') {
                return this.links.admin_edit;
            }
            return null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CompetitionSchedule.prototype, "unique_dates", {
        get: function () {
            return this._unique_dates;
        },
        enumerable: true,
        configurable: true
    });
    CompetitionSchedule.prototype._buildRinkSchedules = function (rinks, sessions) {
        var _loop_1 = function (i) {
            var rink = rinks[i];
            var rink_sessions = sessions.filter(function (session) {
                return session.rink.id === rink.id;
            });
            this_1.rink_schedules.push(new _RinkSchedule_RinkSchedule__WEBPACK_IMPORTED_MODULE_0__["RinkSchedule"](rink, rink_sessions));
        };
        var this_1 = this;
        for (var i = 0; i < rinks.length; i++) {
            _loop_1(i);
        }
    };
    return CompetitionSchedule;
}());



/***/ }),

/***/ "./src/js/models/Credits/CreditPackage.ts":
/*!************************************************!*\
  !*** ./src/js/models/Credits/CreditPackage.ts ***!
  \************************************************/
/*! exports provided: CreditPackage */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CreditPackage", function() { return CreditPackage; });
/* harmony import */ var _adaptors_NullableCreditListCreditListAdaptor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../adaptors/NullableCreditListCreditListAdaptor */ "./src/js/adaptors/NullableCreditListCreditListAdaptor.ts");

var CreditPackage = /** @class */ (function () {
    function CreditPackage(parameters) {
        //@refactor: remove limit prop
        this.limit = 1;
        var cost = parameters.cost, limit = parameters.limit, id = parameters.id, event_id = parameters.event_id;
        this.cost = cost;
        // this.limit = limit;
        this.id = id;
        this.event_id = event_id;
        this.credits = _adaptors_NullableCreditListCreditListAdaptor__WEBPACK_IMPORTED_MODULE_0__["NullableCreditListCreditListAdaptor"].adapt(parameters.credits);
        this.name = this._parseName(this.credits);
    }
    CreditPackage.prototype._parseName = function (credits) {
        var components = [];
        for (var i in credits) {
            var credit = credits[i];
            if (credit > 0) {
                components.push(i.toUpperCase() + ":" + credit);
            }
        }
        return components.join('/');
    };
    Object.defineProperty(CreditPackage.prototype, "summary", {
        get: function () {
            var result = "(";
            var components = [];
            for (var i in this.credits) {
                var credit = this.credits[i];
                if (credit > 0) {
                    components.push(i.toUpperCase() + ":" + credit);
                }
            }
            result += components.join(', ');
            result += ")";
            result += ": $" + this.cost;
            return result;
        },
        enumerable: true,
        configurable: true
    });
    return CreditPackage;
}());



/***/ }),

/***/ "./src/js/models/Credits/CreditsCollection.ts":
/*!****************************************************!*\
  !*** ./src/js/models/Credits/CreditsCollection.ts ***!
  \****************************************************/
/*! exports provided: CreditsCollection */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CreditsCollection", function() { return CreditsCollection; });
var CreditsCollection = /** @class */ (function () {
    function CreditsCollection(initial_config) {
        this._upi = 0;
        this._opi = 0;
        this._wu = 0;
        if (initial_config) {
            for (var i in initial_config) {
                this[i] = initial_config[i];
            }
        }
    }
    Object.defineProperty(CreditsCollection.prototype, "upi", {
        get: function () {
            return this._upi;
        },
        set: function (value) {
            this._upi = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CreditsCollection.prototype, "opi", {
        get: function () {
            return this._opi;
        },
        set: function (value) {
            this._opi = value;
        },
        enumerable: true,
        configurable: true
    });
    CreditsCollection.prototype.export = function () {
        return {
            opi: this._opi,
            upi: this._upi,
            wu: this._wu
        };
    };
    Object.defineProperty(CreditsCollection.prototype, "wu", {
        get: function () {
            return this._wu;
        },
        set: function (value) {
            this._wu = value;
        },
        enumerable: true,
        configurable: true
    });
    CreditsCollection.combine = function (source, to_add) {
        var result = new CreditsCollection({
            opi: source.opi,
            upi: source.upi,
            wu: source.wu,
        });
        for (var i = 0; i < to_add.length; i++) {
            var addor = to_add[i];
            result.opi += addor.opi;
            result.upi += addor.upi;
            result.wu += addor.wu;
        }
        return result;
    };
    CreditsCollection.diff = function (subtractant, subtractor) {
        return new CreditsCollection({
            opi: subtractant._opi - subtractor._opi,
            upi: subtractant._upi - subtractor._upi,
            wu: subtractant._wu - subtractor._wu,
        });
    };
    CreditsCollection.prototype.combine = function (to_add) {
        return CreditsCollection.combine(this, to_add);
    };
    /**
     * @deprecated
     */
    CreditsCollection.prototype.add = function (type, amount) {
        if (type && type in this) {
            this[type] += amount;
        }
    };
    CreditsCollection.prototype.decrement = function (type) {
        if (type && type in this) {
            this[type]--;
        }
    };
    CreditsCollection.prototype.increment = function (type) {
        if (type && type in this) {
            this[type]++;
        }
    };
    CreditsCollection.prototype.is_empty = function () {
        return this._upi === 0 &&
            this._opi === 0 &&
            this._wu === 0;
    };
    CreditsCollection.prototype.creditsAvailable = function (types) {
        if (typeof types === "string") {
            return types in this && this[types] > 0;
        }
        for (var i = 0; i < types.length; i++) {
            var type = types[i];
            if (this.creditsAvailable(type)) {
                return true;
            }
        }
        return false;
    };
    CreditsCollection.prototype.maxCreditAvailableType = function (types) {
        var key_max = 0;
        var max_key = null;
        for (var i = 0; i < types.length; i++) {
            var key = types[i];
            if (this[key] > key_max) {
                key_max = this[key];
                max_key = key;
            }
        }
        return max_key;
    };
    return CreditsCollection;
}());



/***/ }),

/***/ "./src/js/models/Credits/SkaterCredits.ts":
/*!************************************************!*\
  !*** ./src/js/models/Credits/SkaterCredits.ts ***!
  \************************************************/
/*! exports provided: SkaterCredits */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SkaterCredits", function() { return SkaterCredits; });
/* harmony import */ var _CreditsCollection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CreditsCollection */ "./src/js/models/Credits/CreditsCollection.ts");

/**
 * Class to track all of a skater's event credits
 */
var SkaterCredits = /** @class */ (function () {
    function SkaterCredits(event_credits, purchased_package_ids) {
        this._event_credits = [];
        this._purchased_package_ids = [];
        if (event_credits) {
            this._event_credits = event_credits;
        }
        if (purchased_package_ids) {
            this._purchased_package_ids = purchased_package_ids;
        }
    }
    Object.defineProperty(SkaterCredits.prototype, "purchased_package_ids", {
        get: function () {
            return this._purchased_package_ids;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SkaterCredits.prototype, "available_credits", {
        /**
         * ? total available across all events?
         */
        get: function () {
            var result = new _CreditsCollection__WEBPACK_IMPORTED_MODULE_0__["CreditsCollection"]();
            if (this._event_credits.length) {
                for (var i = 0; i < this._event_credits.length; i++) {
                    var ec = this._event_credits[i];
                    result = result.combine([ec.available_credits]);
                }
            }
            return result;
        },
        enumerable: true,
        configurable: true
    });
    SkaterCredits.prototype.find = function (event_id) {
        for (var i = 0; i < this._event_credits.length; i++) {
            var event_credit = this._event_credits[i];
            if (event_credit.event_id == event_id) {
                return event_credit;
            }
        }
        return null;
    };
    SkaterCredits.prototype.decrement = function (event_id, type) {
        var event_credits = this.find(event_id);
        if (!type || !event_credits) {
            return;
        }
        return event_credits.decrement(type);
    };
    SkaterCredits.prototype.increment = function (event_id, type) {
        var event_credits = this.find(event_id);
        if (!type || !event_credits) {
            return;
        }
        event_credits.increment(type);
        return;
    };
    SkaterCredits.prototype.add = function (event_credits) {
        this._event_credits.push(event_credits);
    };
    SkaterCredits.prototype.maxCreditAvailableType = function (event_id, types) {
        var event_credits = this.find(event_id);
        if (!event_credits) {
            return null;
        }
        return event_credits.maxCreditAvailableType(types);
    };
    SkaterCredits.prototype.creditsAvailable = function (event_id, types) {
        var event_credits = this.find(event_id);
        if (!event_credits) {
            return false;
        }
        return event_credits.creditsAvailable(types);
    };
    SkaterCredits.prototype.purchasedCredits = function (event_id) {
        var event_credits = this.find(event_id);
        if (!event_credits) {
            return {
                opi: 0,
                upi: 0,
                wu: 0
            };
        }
        return event_credits.purchased_credits.export();
    };
    SkaterCredits.prototype.unscheduledCredits = function (event_id) {
        var event_credits = this.find(event_id);
        if (!event_credits) {
            return {
                opi: 0,
                upi: 0,
                wu: 0
            };
        }
        return event_credits.available_credits.export();
    };
    SkaterCredits.prototype.scheduledEventCredits = function (event_id) {
        var event_credits = this.find(event_id);
        if (!event_credits) {
            return false;
        }
        return event_credits.all_scheduled_credits;
    };
    SkaterCredits.prototype.scheduledEventCreditsOfType = function (event_id, type) {
        var creditsScheduled2 = this.scheduledEventCredits(event_id);
        if (!creditsScheduled2) {
            return 0;
        }
        return creditsScheduled2[type];
    };
    SkaterCredits.prototype.unscheduled_credits = function () {
        for (var i = 0; i < this._event_credits.length; i++) {
            var obj = this._event_credits[i];
            if (obj.unscheduled_credits()) {
                return true;
            }
        }
        return false;
    };
    SkaterCredits.prototype.getAvailableCreditList = function () {
        var result = [];
        for (var i = 0; i < this._event_credits.length; i++) {
            var obj = this._event_credits[i];
            if (obj.unscheduled_credits()) {
                result.push({
                    event_id: obj.event_id,
                    opi: obj.available_credits.opi,
                    upi: obj.available_credits.upi,
                    wu: obj.available_credits.wu,
                });
            }
        }
        return result;
    };
    return SkaterCredits;
}());



/***/ }),

/***/ "./src/js/models/Credits/SkaterEventCredits.ts":
/*!*****************************************************!*\
  !*** ./src/js/models/Credits/SkaterEventCredits.ts ***!
  \*****************************************************/
/*! exports provided: SkaterEventCredits */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SkaterEventCredits", function() { return SkaterEventCredits; });
/* harmony import */ var _CreditsCollection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CreditsCollection */ "./src/js/models/Credits/CreditsCollection.ts");

/**
 * Manage the credits a skater has for a single event
 */
var SkaterEventCredits = /** @class */ (function () {
    function SkaterEventCredits(event_id, total_credits, scheduled_credits) {
        this._total_credits = new _CreditsCollection__WEBPACK_IMPORTED_MODULE_0__["CreditsCollection"](total_credits);
        this._scheduled_credits = new _CreditsCollection__WEBPACK_IMPORTED_MODULE_0__["CreditsCollection"](scheduled_credits);
        this._available_credits = _CreditsCollection__WEBPACK_IMPORTED_MODULE_0__["CreditsCollection"].diff(this._total_credits, this._scheduled_credits);
        this._event_id = event_id;
    }
    Object.defineProperty(SkaterEventCredits.prototype, "event_id", {
        get: function () {
            return this._event_id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SkaterEventCredits.prototype, "available_credits", {
        get: function () {
            return this._available_credits;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SkaterEventCredits.prototype, "purchased_credits", {
        get: function () {
            return this._total_credits;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SkaterEventCredits.prototype, "all_scheduled_credits", {
        get: function () {
            return this._scheduled_credits;
        },
        enumerable: true,
        configurable: true
    });
    SkaterEventCredits.prototype.creditsAvailable = function (types) {
        return this._available_credits.creditsAvailable(types);
    };
    SkaterEventCredits.prototype.decrement = function (type) {
        if (type) {
            this._available_credits.decrement(type);
            this._scheduled_credits.increment(type);
        }
    };
    SkaterEventCredits.prototype.increment = function (type) {
        if (type) {
            this._available_credits.increment(type);
            this._scheduled_credits.decrement(type);
        }
    };
    SkaterEventCredits.prototype.maxCreditAvailableType = function (types) {
        return this._available_credits.maxCreditAvailableType(types);
    };
    SkaterEventCredits.prototype.unscheduled_credits = function () {
        return !this._available_credits.is_empty();
    };
    return SkaterEventCredits;
}());



/***/ }),

/***/ "./src/js/models/Facility.ts":
/*!***********************************!*\
  !*** ./src/js/models/Facility.ts ***!
  \***********************************/
/*! exports provided: Facility */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Facility", function() { return Facility; });
var Facility = /** @class */ (function () {
    function Facility(name, id) {
        this._name = name;
        this._id = id;
    }
    Object.defineProperty(Facility.prototype, "name", {
        get: function () {
            return this._name;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Facility.prototype, "id", {
        get: function () {
            return this._id;
        },
        enumerable: true,
        configurable: true
    });
    return Facility;
}());



/***/ }),

/***/ "./src/js/models/FormState.ts":
/*!************************************!*\
  !*** ./src/js/models/FormState.ts ***!
  \************************************/
/*! exports provided: FormState */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FormState", function() { return FormState; });
/**
 * Baseline class to track state of abstract Form data
 */
var FormState = /** @class */ (function () {
    function FormState() {
    }
    return FormState;
}());



/***/ }),

/***/ "./src/js/models/FormValidator.ts":
/*!****************************************!*\
  !*** ./src/js/models/FormValidator.ts ***!
  \****************************************/
/*! exports provided: FormValidator */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FormValidator", function() { return FormValidator; });
/* harmony import */ var _ValidationFunctions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ValidationFunctions */ "./src/js/models/ValidationFunctions.ts");

var FormValidator = /** @class */ (function () {
    function FormValidator(form_data) {
        this.rules = {};
        this.messages = {
            "required": "This field is required"
        };
        this.form_data = form_data;
    }
    FormValidator.prototype.validate = function () {
        var errors = {};
        var messages = {};
        for (var field in this.rules) {
            var field_rules = this.rules[field];
            for (var i = 0; i < field_rules.length; i++) {
                var field_rule = field_rules[i].toString();
                var formDatum = this.form_data[field];
                if (!this.validateRule(field_rule, formDatum)) {
                    this.addError(errors, field, field_rule);
                    this.addMessage(messages, field, field_rule);
                }
            }
        }
        return {
            errors: errors,
            messages: messages
        };
    };
    FormValidator.prototype.validateRule = function (rule_params, value) {
        var split = rule_params.split(':');
        var rule = split[0];
        var attributes = split[1];
        /**
         * If rule is equal, get the value of the field from data for comparison
         */
        if (rule === "equal") {
            attributes = this.form_data[attributes];
        }
        return FormValidator.validators[rule](value, attributes);
    };
    FormValidator.prototype.addMessage = function (messages, field, field_rule) {
        var split = field_rule.split(':');
        var rule = split[0];
        var attributes = split[1];
        if (!messages.hasOwnProperty(field)) {
            messages[field] = [];
        }
        var message_def = this.messages[rule];
        var message = typeof message_def === 'string' ? message_def : message_def(attributes);
        messages[field].push(message);
    };
    FormValidator.prototype.addError = function (errors, field, field_rule) {
        var split = field_rule.split(':');
        var rule = split[0];
        if (!errors.hasOwnProperty(field)) {
            errors[field] = [];
        }
        errors[field].push(rule);
    };
    /**
     * Ensure a validation result has the necessary foundation for a field's errors and messages
     * If errors and messages properties don't contain a key for a field, add baseline
     */
    FormValidator.prototype.ensureValidationResultFieldPresence = function (field_key, result) {
        if (!result.errors[field_key]) {
            result.errors[field_key] = [];
        }
        if (!result.messages[field_key]) {
            result.messages[field_key] = [];
        }
    };
    FormValidator.validators = {
        required: function (value) {
            return Object(_ValidationFunctions__WEBPACK_IMPORTED_MODULE_0__["validateRequired"])(value, false);
        },
        /**
         *
         * Right now we're allowing a lot of input through with the goal of not displaying errors for fringe case zip codes
         */
        zip: function (value) {
            return Object(_ValidationFunctions__WEBPACK_IMPORTED_MODULE_0__["validateMinLength"])(value, 5) && Object(_ValidationFunctions__WEBPACK_IMPORTED_MODULE_0__["validateMaxLength"])(value, 10);
            // return validateZipCode(value);
        },
        cvc: function (value) {
            return Object(_ValidationFunctions__WEBPACK_IMPORTED_MODULE_0__["validateCVC"])(value);
        },
        credit_card_number: function (value) {
            return Object(_ValidationFunctions__WEBPACK_IMPORTED_MODULE_0__["validateCreditCardNumber"])(value);
        },
        integer: function (value) {
            return Object(_ValidationFunctions__WEBPACK_IMPORTED_MODULE_0__["validateInteger"])(value);
        },
        max: function (value, limit) {
            return Object(_ValidationFunctions__WEBPACK_IMPORTED_MODULE_0__["validateMax"])(value, limit);
        },
        email: function (value) {
            return Object(_ValidationFunctions__WEBPACK_IMPORTED_MODULE_0__["validateEmail"])(value);
        },
        nullable_email: function (value) {
            return Object(_ValidationFunctions__WEBPACK_IMPORTED_MODULE_0__["validateNullableEmail"])(value);
        },
        equal: function (value, match_field) {
            return Object(_ValidationFunctions__WEBPACK_IMPORTED_MODULE_0__["validateEqual"])(value, match_field);
        },
        min_length: function (value, limit) {
            return Object(_ValidationFunctions__WEBPACK_IMPORTED_MODULE_0__["validateMinLength"])(value, limit);
        },
        date_formatted: function (value) {
            return Object(_ValidationFunctions__WEBPACK_IMPORTED_MODULE_0__["validateDateFormatted"])(value);
        },
        date_not_future: function (value) {
            return Object(_ValidationFunctions__WEBPACK_IMPORTED_MODULE_0__["validateDateNotFuture"])(value);
        },
        confirmed: function (value) {
            return Object(_ValidationFunctions__WEBPACK_IMPORTED_MODULE_0__["validateConfirmed"])(value);
        }
    };
    return FormValidator;
}());



/***/ }),

/***/ "./src/js/models/Forms/EditProfileFormState.ts":
/*!*****************************************************!*\
  !*** ./src/js/models/Forms/EditProfileFormState.ts ***!
  \*****************************************************/
/*! exports provided: EditProfileFormState */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EditProfileFormState", function() { return EditProfileFormState; });
/* harmony import */ var _FormState__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../FormState */ "./src/js/models/FormState.ts");
/* harmony import */ var _helpers_time__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../helpers/time */ "./src/js/helpers/time.ts");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();


var EditProfileFormState = /** @class */ (function (_super) {
    __extends(EditProfileFormState, _super);
    function EditProfileFormState() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.prefix = null;
        _this.first_name = null;
        _this.pronunciation_firstname = null;
        _this.middle_name = null;
        _this.last_name = null;
        _this.pronunciation_lastname = null;
        _this.suffix = null;
        _this.birth_date = null;
        _this.primary_email = null;
        _this.publish_primary_email = false;
        _this.opt_out_primary_email = false;
        _this.secondary_email = null;
        _this.publish_secondary_email = false;
        _this.opt_out_secondary_email = false;
        _this.primary_phone = null;
        _this.primary_phone_carrier = null;
        return _this;
    }
    EditProfileFormState.prototype.import = function (profile_data) {
        //Simple Fields
        this.first_name = profile_data.first_name;
        this.pronunciation_firstname = profile_data.pronunciation_firstname;
        this.middle_name = profile_data.middle_name;
        this.last_name = profile_data.last_name;
        this.pronunciation_lastname = profile_data.pronunciation_lastname;
        //Complex fields
        this.prefix = profile_data.prefix ? profile_data.prefix.value : null;
        this.suffix = profile_data.suffix ? profile_data.suffix.value : null;
        this.primary_email = profile_data.primary_email ? profile_data.primary_email.value : null;
        this.publish_primary_email = profile_data.primary_email ? profile_data.primary_email.publish : false;
        this.opt_out_primary_email = profile_data.primary_email ? profile_data.primary_email.opt_out : false;
        this.secondary_email = profile_data.secondary_email ? profile_data.secondary_email.value : null;
        this.publish_secondary_email = profile_data.secondary_email ? profile_data.secondary_email.publish : false;
        this.opt_out_secondary_email = profile_data.secondary_email ? profile_data.secondary_email.opt_out : false;
        this.primary_phone = profile_data.primary_phone ? profile_data.primary_phone.value : null;
        this.primary_phone_carrier = profile_data.primary_phone && profile_data.primary_phone.carrier ? profile_data.primary_phone.carrier.value : null;
        //transformed fields
        this.birth_date = profile_data.birth_date ? Object(_helpers_time__WEBPACK_IMPORTED_MODULE_1__["FormInputDate"])(new Date(profile_data.birth_date.timestamp)) : null;
    };
    return EditProfileFormState;
}(_FormState__WEBPACK_IMPORTED_MODULE_0__["FormState"]));



/***/ }),

/***/ "./src/js/models/Forms/EditProfileFormValidator.ts":
/*!*********************************************************!*\
  !*** ./src/js/models/Forms/EditProfileFormValidator.ts ***!
  \*********************************************************/
/*! exports provided: EditProfileFormValidator */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EditProfileFormValidator", function() { return EditProfileFormValidator; });
/* harmony import */ var _FormValidator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../FormValidator */ "./src/js/models/FormValidator.ts");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();

var EditProfileFormValidator = /** @class */ (function (_super) {
    __extends(EditProfileFormValidator, _super);
    function EditProfileFormValidator(form_data) {
        var _this = _super.call(this, form_data) || this;
        _this.rules = {
            first_name: ["required"],
            last_name: ["required"],
            birth_date: ['required', 'date_formatted', 'date_not_future'],
            primary_email: ["nullable_email"],
            secondary_email: ["nullable_email"],
        };
        _this.messages = {
            required: "This field is required",
            nullable_email: "Enter a valid email address",
            date_formatted: "Enter a valid date in the format mm/dd/yyyy",
            date_not_future: "Enter a date that's not in the future",
        };
        return _this;
    }
    return EditProfileFormValidator;
}(_FormValidator__WEBPACK_IMPORTED_MODULE_0__["FormValidator"]));



/***/ }),

/***/ "./src/js/models/Music/EventSegmentMusic.ts":
/*!**************************************************!*\
  !*** ./src/js/models/Music/EventSegmentMusic.ts ***!
  \**************************************************/
/*! exports provided: EventSegmentMusic */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EventSegmentMusic", function() { return EventSegmentMusic; });
/**
 * Represents Music as associated with an Event Segment
 */
var EventSegmentMusic = /** @class */ (function () {
    function EventSegmentMusic(parameters) {
        var competition_id = parameters.competition_id, event_id = parameters.event_id, event_segment_id = parameters.event_segment_id, competition_skated_event_id = parameters.competition_skated_event_id, music = parameters.music;
        this.competition_id = competition_id;
        this.event_id = event_id;
        this.event_segment_id = event_segment_id;
        this.competition_skated_event_id = competition_skated_event_id;
        this.music = music;
    }
    return EventSegmentMusic;
}());



/***/ }),

/***/ "./src/js/models/Music/Music.ts":
/*!**************************************!*\
  !*** ./src/js/models/Music/Music.ts ***!
  \**************************************/
/*! exports provided: Music */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Music", function() { return Music; });
/* harmony import */ var _MusicCopyright__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MusicCopyright */ "./src/js/models/Music/MusicCopyright.ts");
var __assign = (undefined && undefined.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};

var Music = /** @class */ (function () {
    function Music(parameters) {
        this._has_been_played = false;
        this._name = "";
        this._copyrights = [];
        this._file = null;
        this.active_copyright_context_id = 1;
        if (parameters) {
            this._name = parameters.name;
            this._has_been_played = parameters.has_been_played;
            this._copyrights = parameters.copyrights;
            this._file = parameters.file;
            this.active_copyright_context_id = parameters.active_copyright_context_id;
        }
    }
    Object.defineProperty(Music.prototype, "file", {
        get: function () {
            return this._file;
        },
        set: function (value) {
            this._file = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Music.prototype, "copyrights", {
        get: function () {
            return this._copyrights;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Music.prototype, "has_been_played", {
        get: function () {
            return this._has_been_played;
        },
        set: function (value) {
            this._has_been_played = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Music.prototype, "name", {
        get: function () {
            return this._name;
        },
        set: function (value) {
            this._name = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Update the copyright at a given index with new data.
     *
     * Replaces existing copyright instance
     */
    Music.prototype.updateCopyright = function (copyright_data, copyright_index) {
        var context_id = this.getCopyrightContextIDByIndex(copyright_index);
        var copyright = _MusicCopyright__WEBPACK_IMPORTED_MODULE_0__["MusicCopyright"].createFromFormData(copyright_data, context_id);
        this._copyrights.splice(copyright_index, 1, copyright);
    };
    /**
     * Remove a copyright item
     */
    Music.prototype.removeCopyright = function (copyright_index) {
        this._copyrights.splice(copyright_index, 1);
    };
    /**
     * Create a deep copy
     */
    Music.prototype.clone = function () {
        var args = this.getCloneArgs();
        return new Music(args);
    };
    /**
     * Compare to another instance to determine if they're equivalent
     */
    Music.prototype.equals = function (compare) {
        var top_level_properties = [
            'has_been_played',
            'name'
        ];
        for (var i = 0; i < top_level_properties.length; i++) {
            var prop = top_level_properties[i];
            if (this[prop] !== compare[prop]) {
                return false;
            }
        }
        if (!this.files_equivalent(compare.file)) {
            return false;
        }
        if (this.copyrights.length !== compare.copyrights.length) {
            return false;
        }
        for (var i = 0; i < this.copyrights.length; i++) {
            var copyright = this.copyrights[i];
            if (!copyright.equals(compare.copyrights[i])) {
                return false;
            }
        }
        return true;
    };
    /**
     * Music files are equivalent if
     * 1. They're both set and the ids are the same
     * 2. They're both null
     */
    Music.prototype.files_equivalent = function (compare_music_file_prop) {
        if (this.file && compare_music_file_prop) {
            return this.file.id === compare_music_file_prop.id;
        }
        return this.file === null && compare_music_file_prop === null;
    };
    /**
     * Export data to transferable object
     */
    Music.prototype.export = function () {
        return {
            has_been_played: this._has_been_played,
            name: this._name,
            copyrights: this._copyrights.map(function (copyright) {
                return copyright.export();
            }),
            // @downstream-sync 2020-07-02 - downstream music items have id:string typing
            file: this.file ? this.file : { id: "", url: "" }
        };
    };
    /**
     * Get the arguments from the instance for creating a clone
     */
    Music.prototype.getCloneArgs = function () {
        return {
            has_been_played: this._has_been_played,
            name: this._name,
            copyrights: this._copyrights.map(function (copyright) {
                return copyright.clone();
            }),
            file: this.file ? __assign({}, this.file) : null,
            active_copyright_context_id: this.active_copyright_context_id
        };
    };
    /**
     * Get the context ID for a copyright based on its index
     */
    Music.prototype.getCopyrightContextIDByIndex = function (copyright_index) {
        var existing_copyright = this._copyrights[copyright_index];
        if (existing_copyright) {
            return existing_copyright.context_id;
        }
        return this.active_copyright_context_id++;
    };
    return Music;
}());



/***/ }),

/***/ "./src/js/models/Music/MusicCopyright.ts":
/*!***********************************************!*\
  !*** ./src/js/models/Music/MusicCopyright.ts ***!
  \***********************************************/
/*! exports provided: MusicCopyright */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MusicCopyright", function() { return MusicCopyright; });
/**
 * A copyright on a Music instance
 * @property context_id - Unique identifier for Copyright within its parent context (eg: parent Music class)
 */
var MusicCopyright = /** @class */ (function () {
    function MusicCopyright(parameters) {
        this.title = null;
        this.artist = null;
        this.arrangement = null;
        this.record_label = null;
        this.duration_minutes = null;
        this.duration_seconds = null;
        var context_id = parameters.context_id, title = parameters.title, artist = parameters.artist, arrangement = parameters.arrangement, record_label = parameters.record_label, duration_minutes = parameters.duration_minutes, duration_seconds = parameters.duration_seconds;
        this.artist = artist;
        this.arrangement = arrangement;
        this.record_label = record_label;
        this.duration_minutes = duration_minutes;
        this.duration_seconds = duration_seconds;
        this.title = title;
        this.context_id = context_id;
    }
    Object.defineProperty(MusicCopyright.prototype, "duration", {
        get: function () {
            if (!this.duration_minutes && !this.duration_seconds) {
                return null;
            }
            var duration_minutes_formatted = this.duration_minutes ? this.duration_minutes : "0";
            var duration_seconds_formatted = "00";
            if (this.duration_seconds) {
                duration_seconds_formatted = String(this.duration_seconds);
                if (this.duration_seconds < 10 && String(this.duration_seconds).length != 2) {
                    duration_seconds_formatted = "0" + this.duration_seconds;
                }
            }
            return duration_minutes_formatted + ":" + duration_seconds_formatted;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Create an instance from Copyright Form data
     */
    MusicCopyright.createFromFormData = function (form_data, context_id) {
        var title = form_data.title, artist = form_data.artist, arrangement = form_data.arrangement, record_label = form_data.record_label, duration_minutes = form_data.duration_minutes, duration_seconds = form_data.duration_seconds;
        if (typeof duration_seconds === "string") {
            duration_seconds = parseInt(duration_seconds);
        }
        if (typeof duration_minutes === "string") {
            duration_minutes = parseInt(duration_minutes);
        }
        var args = {
            title: title,
            artist: artist,
            arrangement: arrangement,
            record_label: record_label,
            duration_minutes: duration_minutes,
            duration_seconds: duration_seconds,
            context_id: context_id
        };
        return new MusicCopyright(args);
    };
    /**
     * Get Copyright Form data from the instance
     */
    MusicCopyright.prototype.getFormData = function () {
        return {
            title: this.title,
            artist: this.artist,
            arrangement: this.arrangement,
            record_label: this.record_label,
            duration_minutes: this.duration_minutes,
            duration_seconds: this.duration_seconds,
        };
    };
    /**
     * Make a deep copy of the instance
     */
    MusicCopyright.prototype.clone = function () {
        var args = {
            title: this.title,
            artist: this.artist,
            arrangement: this.arrangement,
            record_label: this.record_label,
            duration_minutes: this.duration_minutes,
            duration_seconds: this.duration_seconds,
            context_id: this.context_id
        };
        return new MusicCopyright(args);
    };
    /**
     * Compare with another copyright to determine if they're equivalent
     */
    MusicCopyright.prototype.equals = function (compare) {
        var keys = Object.keys(this);
        for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            if (this[key] !== compare[key]) {
                return false;
            }
        }
        return true;
    };
    /**
     * Export to a transferable data object
     */
    MusicCopyright.prototype.export = function () {
        return {
            title: this.title,
            artist: this.artist,
            arrangement: this.arrangement,
            record_label: this.record_label,
            duration_minutes: this.duration_minutes,
            duration_seconds: this.duration_seconds,
        };
    };
    return MusicCopyright;
}());



/***/ }),

/***/ "./src/js/models/Music/SavedMusic.ts":
/*!*******************************************!*\
  !*** ./src/js/models/Music/SavedMusic.ts ***!
  \*******************************************/
/*! exports provided: SavedMusic */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SavedMusic", function() { return SavedMusic; });
/* harmony import */ var _Music__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Music */ "./src/js/models/Music/Music.ts");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (undefined && undefined.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};

/**
 * Music that has been saved on the backend to the user's library
 */
var SavedMusic = /** @class */ (function (_super) {
    __extends(SavedMusic, _super);
    function SavedMusic(parameters) {
        var _this = _super.call(this, parameters) || this;
        _this._has_been_played = true;
        _this._id = parameters.id;
        _this._has_been_played = true;
        _this._is_assigned_to_program = parameters.is_assigned_to_program;
        return _this;
    }
    Object.defineProperty(SavedMusic.prototype, "id", {
        // @downstream-sync 2020-07-02 - downstream music items have id:string typing
        get: function () {
            return this._id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SavedMusic.prototype, "is_assigned_to_program", {
        get: function () {
            return this._is_assigned_to_program;
        },
        enumerable: true,
        configurable: true
    });
    // @downstream-sync 2020-07-02 - downstream music items have id:string typing
    SavedMusic.createFromMusic = function (music, id) {
        var args = __assign({}, music.getCloneArgs(), { is_assigned_to_program: true, id: id });
        return new SavedMusic(args);
    };
    SavedMusic.prototype.clone = function () {
        var args = {
            id: this.id,
            name: this._name,
            has_been_played: this._has_been_played,
            copyrights: this._copyrights.map(function (copyright) {
                return copyright.clone();
            }),
            file: this.file ? __assign({}, this.file) : null,
            is_assigned_to_program: this.is_assigned_to_program,
            active_copyright_context_id: this.active_copyright_context_id
        };
        return new SavedMusic(args);
    };
    SavedMusic.prototype.export = function () {
        var base = _super.prototype.export.call(this);
        return __assign({}, base, { id: this.id });
    };
    return SavedMusic;
}(_Music__WEBPACK_IMPORTED_MODULE_0__["Music"]));



/***/ }),

/***/ "./src/js/models/PPC/PPC.ts":
/*!**********************************!*\
  !*** ./src/js/models/PPC/PPC.ts ***!
  \**********************************/
/*! exports provided: PPC */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PPC", function() { return PPC; });
/* harmony import */ var _PPCElement__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PPCElement */ "./src/js/models/PPC/PPCElement.ts");

var PPC = /** @class */ (function () {
    function PPC(parameters) {
        this._elements = [];
        this.current_element_id = 1;
        this._event_segment_id = -1;
        this._competition_id = -1;
        this._event_id = -1;
        this._competition_skated_event_id = -1;
        if (parameters) {
            this._elements = parameters.elements;
            this._competition_id = parameters.competition_id;
            this._event_id = parameters.event_id;
            this._event_segment_id = parameters.event_segment_id;
            this._competition_skated_event_id = parameters.competition_skated_event_id;
            if (parameters.current_element_id) {
                this.current_element_id = parameters.current_element_id;
            }
        }
        for (var i = 0; i < this._elements.length; i++) {
            var element = this._elements[i];
            element.id = this.current_element_id++;
        }
    }
    Object.defineProperty(PPC.prototype, "competition_skated_event_id", {
        get: function () {
            return this._competition_skated_event_id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PPC.prototype, "event_segment_id", {
        get: function () {
            return this._event_segment_id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PPC.prototype, "competition_id", {
        get: function () {
            return this._competition_id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PPC.prototype, "event_id", {
        get: function () {
            return this._event_id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PPC.prototype, "length", {
        get: function () {
            return this._elements.length;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PPC.prototype, "elements", {
        get: function () {
            return this._elements;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Compare to a another PPC to see if they're equivalent
     * They're equivalent if they have all the same type, element type and moves
     */
    PPC.prototype.equals = function (compare) {
        var source_elements = this.export().elements;
        var compare_elements = compare.export().elements;
        if (this.length !== compare.length) {
            return false;
        }
        for (var i = 0; i < source_elements.length; i++) {
            var source_element = source_elements[i];
            var compare_element = compare_elements[i];
            if (source_element.type.id !== compare_element.type.id) {
                return false;
            }
            if (source_element.element.id !== compare_element.element.id) {
                return false;
            }
            if (source_element.moves.length !== compare_element.moves.length) {
                return false;
            }
            for (var j = 0; j < source_element.moves.length; j++) {
                var move = compare_element.moves[j];
                if (move.id !== source_element.moves[j].id) {
                    return false;
                }
            }
        }
        return true;
    };
    PPC.prototype.export = function () {
        var elements = this.elements;
        return {
            elements: elements.reduce(function (accumulator, element) {
                var exported_element = element.export();
                if (exported_element) {
                    accumulator.push(exported_element);
                }
                return accumulator;
            }, [])
        };
    };
    PPC.prototype.addElement = function () {
        var element = new _PPCElement__WEBPACK_IMPORTED_MODULE_0__["PPCElement"](undefined, this.current_element_id++);
        this._elements.push(element);
        return element.id;
    };
    PPC.prototype.removeElement = function (element_index) {
        this._elements.splice(element_index, 1);
    };
    PPC.prototype.reorderElement = function (direction, element_index) {
        var to_index = direction === "up" ? element_index - 1 : element_index + 1;
        if (to_index > -1 && to_index < this._elements.length) {
            this._elements.splice(to_index, 0, this._elements.splice(element_index, 1)[0]);
        }
    };
    /**
     * Reorder elements according the position of their IDs in an array
     */
    PPC.prototype.orderElements = function (order_map) {
        this.elements.sort(function (element, element_b) {
            return order_map.indexOf(element.id) > order_map.indexOf(element_b.id) ? 1 : -1;
        });
    };
    /**
     * Make a clone of a PPC
     */
    PPC.prototype.clone = function () {
        var elements = this.elements.map(function (element) {
            return element.clone();
        });
        var args = {
            elements: elements,
            event_segment_id: this.event_segment_id,
            competition_id: this.competition_id,
            event_id: this.event_id,
            competition_skated_event_id: this.competition_skated_event_id
        };
        return new PPC(args);
    };
    return PPC;
}());



/***/ }),

/***/ "./src/js/models/PPC/PPCElement.ts":
/*!*****************************************!*\
  !*** ./src/js/models/PPC/PPCElement.ts ***!
  \*****************************************/
/*! exports provided: PPCElement */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PPCElement", function() { return PPCElement; });
var PPCElement = /** @class */ (function () {
    function PPCElement(parameters, id) {
        this.id = -1;
        this.is_new = true;
        this._moves = [];
        if (parameters) {
            var moves = parameters.moves, type = parameters.type, element = parameters.element;
            this._moves = moves;
            this._type = type;
            this._element = element;
            this.is_new = false;
            this._transition_description = parameters.transition_description;
        }
        if (id) {
            this.id = id;
        }
    }
    Object.defineProperty(PPCElement.prototype, "moves", {
        get: function () {
            return this._moves;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PPCElement.prototype, "element", {
        get: function () {
            return this._element;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PPCElement.prototype, "type", {
        get: function () {
            return this._type;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PPCElement.prototype, "type_description", {
        get: function () {
            return this._type ? this._type.name : "";
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PPCElement.prototype, "element_description", {
        get: function () {
            return this._element ? this._element.name : "";
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PPCElement.prototype, "short_description", {
        get: function () {
            if (this._moves.length) {
                return this._moves.map(function (move) {
                    return move.code;
                }).join(" + ");
            }
            return this._element && this._element.code ? this._element.code : "";
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PPCElement.prototype, "transition_description", {
        get: function () {
            return this._transition_description;
        },
        enumerable: true,
        configurable: true
    });
    PPCElement.prototype.update = function (data) {
        this.is_new = false;
        this._type = data.type;
        this._element = data.element;
        this._moves = data.moves;
        this._transition_description = data.transition_description;
    };
    PPCElement.prototype.export = function () {
        if (this.type && this.element) {
            var export_value = {
                moves: this.moves,
                type: this.type,
                element: this.element
            };
            if (this._transition_description) {
                export_value.transition_description = this._transition_description;
            }
            return export_value;
        }
        return null;
    };
    PPCElement.prototype.clone = function () {
        var exported = this.export();
        if (exported) {
            var args = exported;
            return new PPCElement(args, this.id);
        }
        return new PPCElement();
    };
    return PPCElement;
}());



/***/ }),

/***/ "./src/js/models/Rink.ts":
/*!*******************************!*\
  !*** ./src/js/models/Rink.ts ***!
  \*******************************/
/*! exports provided: Rink */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Rink", function() { return Rink; });
var Rink = /** @class */ (function () {
    function Rink(name, facility, id) {
        this._name = name;
        this._facility = facility;
        this._id = id;
        this._full_name = name + " - " + facility.name;
    }
    Object.defineProperty(Rink.prototype, "facility", {
        get: function () {
            return this._facility;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Rink.prototype, "id", {
        get: function () {
            return this._id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Rink.prototype, "name", {
        get: function () {
            return this._name;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Rink.prototype, "full_name", {
        get: function () {
            return this._full_name;
        },
        enumerable: true,
        configurable: true
    });
    return Rink;
}());



/***/ }),

/***/ "./src/js/models/RinkSchedule/RinkSchedule.ts":
/*!****************************************************!*\
  !*** ./src/js/models/RinkSchedule/RinkSchedule.ts ***!
  \****************************************************/
/*! exports provided: RinkSchedule */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RinkSchedule", function() { return RinkSchedule; });
/* harmony import */ var _Collections_SessionCollection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Collections/SessionCollection */ "./src/js/models/Collections/SessionCollection.ts");

/**
 * Class for managing rink schedules
 *
 * Child of competition schedule
 */
var RinkSchedule = /** @class */ (function () {
    function RinkSchedule(rink, sessions) {
        this._rink = rink;
        this.session_collection = new _Collections_SessionCollection__WEBPACK_IMPORTED_MODULE_0__["SessionCollection"](sessions);
    }
    Object.defineProperty(RinkSchedule.prototype, "rink", {
        get: function () {
            return this._rink;
        },
        enumerable: true,
        configurable: true
    });
    RinkSchedule.prototype.getDates = function () {
        return this.session_collection.unique_dates();
    };
    return RinkSchedule;
}());



/***/ }),

/***/ "./src/js/models/SalesWindow.ts":
/*!**************************************!*\
  !*** ./src/js/models/SalesWindow.ts ***!
  \**************************************/
/*! exports provided: SalesWindow */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SalesWindow", function() { return SalesWindow; });
var SalesWindow = /** @class */ (function () {
    function SalesWindow(parameters) {
        var key = parameters.key, name = parameters.name, start_datetime_timestamp = parameters.start_datetime_timestamp, end_datetime_timestamp = parameters.end_datetime_timestamp, start_datetime_formatted = parameters.start_datetime_formatted, end_datetime_formatted = parameters.end_datetime_formatted;
        this._key = key;
        this._name = name;
        this._start_datetime = new Date(start_datetime_timestamp);
        this._end_datetime = new Date(end_datetime_timestamp);
        this._start_time_formatted = start_datetime_formatted;
        this._end_time_formatted = end_datetime_formatted;
    }
    Object.defineProperty(SalesWindow.prototype, "key", {
        get: function () {
            return this._key;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SalesWindow.prototype, "end_time_formatted", {
        get: function () {
            return this._end_time_formatted;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SalesWindow.prototype, "start_time_formatted", {
        get: function () {
            return this._start_time_formatted;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SalesWindow.prototype, "is_passed", {
        get: function () {
            return this._end_datetime < new Date();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SalesWindow.prototype, "is_open", {
        get: function () {
            var now = new Date();
            return this._start_datetime <= now && this._end_datetime > now;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SalesWindow.prototype, "name", {
        get: function () {
            return this._name;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SalesWindow.prototype, "start_datetime", {
        get: function () {
            return this._start_datetime;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SalesWindow.prototype, "end_datetime", {
        get: function () {
            return this._end_datetime;
        },
        enumerable: true,
        configurable: true
    });
    return SalesWindow;
}());



/***/ }),

/***/ "./src/js/models/Schedule/CoachSkatersSchedule.ts":
/*!********************************************************!*\
  !*** ./src/js/models/Schedule/CoachSkatersSchedule.ts ***!
  \********************************************************/
/*! exports provided: CoachSkatersSchedule */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CoachSkatersSchedule", function() { return CoachSkatersSchedule; });
/* harmony import */ var _Collections_SessionCollection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Collections/SessionCollection */ "./src/js/models/Collections/SessionCollection.ts");
/* harmony import */ var _SessionSchedule__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SessionSchedule */ "./src/js/models/Schedule/SessionSchedule.ts");
/* harmony import */ var _Sessions_ScheduledSession__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Sessions/ScheduledSession */ "./src/js/models/Sessions/ScheduledSession.ts");
/* harmony import */ var _Collections_ScheduledSessionCollection__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Collections/ScheduledSessionCollection */ "./src/js/models/Collections/ScheduledSessionCollection.ts");




/**
 * A coach's schedule based on the sessions of the skaters they're coaching for a competition.
 */
var CoachSkatersSchedule = /** @class */ (function () {
    function CoachSkatersSchedule(sessions, skater_session_map) {
        this.sessions = sessions;
        this.skater_session_map = skater_session_map;
        this._schedule = this._createSchedule(sessions);
    }
    Object.defineProperty(CoachSkatersSchedule.prototype, "schedule", {
        get: function () {
            return this._schedule;
        },
        enumerable: true,
        configurable: true
    });
    CoachSkatersSchedule.blank = function () {
        return new CoachSkatersSchedule(new _Collections_SessionCollection__WEBPACK_IMPORTED_MODULE_0__["SessionCollection"]([]), {});
    };
    /**
     * Get the skaters for a given session_id in the schedule
     */
    CoachSkatersSchedule.prototype.getSessionSkaters = function (session_id) {
        if (this.skater_session_map.hasOwnProperty(String(session_id))) {
            return this.skater_session_map[session_id];
        }
        return [];
    };
    /**
     * Create a schedule from the supplied session collection.
     *
     * Creates spoofed Scheduled Session from Session's first credit_type and event_id to work with SessionSchedule API
     *  - These properties are not used in the CoachSkatersSchedule context, so their arbitrary construction will not pose issues as of this writing
     */
    CoachSkatersSchedule.prototype._createSchedule = function (sessions) {
        return new _SessionSchedule__WEBPACK_IMPORTED_MODULE_1__["SessionSchedule"](new _Collections_ScheduledSessionCollection__WEBPACK_IMPORTED_MODULE_3__["ScheduledSessionCollection"](sessions.all().map(function (session) {
            return new _Sessions_ScheduledSession__WEBPACK_IMPORTED_MODULE_2__["ScheduledSession"]({
                session: session,
                scheduled_as: session.credit_types[0],
                scheduled_event_id: session.event_ids[0]
            });
        })));
    };
    return CoachSkatersSchedule;
}());



/***/ }),

/***/ "./src/js/models/Schedule/ScheduleDay.ts":
/*!***********************************************!*\
  !*** ./src/js/models/Schedule/ScheduleDay.ts ***!
  \***********************************************/
/*! exports provided: ScheduleDay */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ScheduleDay", function() { return ScheduleDay; });
/* harmony import */ var _Collections_ScheduledSessionCollection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Collections/ScheduledSessionCollection */ "./src/js/models/Collections/ScheduledSessionCollection.ts");

/**
 * Class that represents a single day in a Schedule of Sessions
 */
var ScheduleDay = /** @class */ (function () {
    function ScheduleDay(date, scheduled_sessions) {
        this._date = date;
        this._pretty_date = ScheduleDay._parsePrettyDate(this._date);
        if (!scheduled_sessions) {
            scheduled_sessions = [];
        }
        this.scheduled_sessions = new _Collections_ScheduledSessionCollection__WEBPACK_IMPORTED_MODULE_0__["ScheduledSessionCollection"](scheduled_sessions);
        this.sortSessions();
    }
    Object.defineProperty(ScheduleDay.prototype, "date", {
        get: function () {
            return this._date;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ScheduleDay.prototype, "pretty_date", {
        get: function () {
            return this._pretty_date;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ScheduleDay.prototype, "sessions", {
        get: function () {
            return this.scheduled_sessions.all();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Return the date in "Mon 3/27" format
     */
    ScheduleDay._parsePrettyDate = function (date) {
        var days_of_week = ['Sun', 'Mon', 'Tue', 'Wed', 'Thurs', 'Fri', 'Sat'];
        return days_of_week[date.getDay()] + " " + (date.getMonth() + 1) + "/" + date.getDate();
    };
    /**
     * Add a session to the day
     */
    ScheduleDay.prototype.add = function (scheduled_session) {
        this.scheduled_sessions.add(scheduled_session);
        this.sortSessions();
    };
    /**
     * @refactor: change to scheduled_session
     */
    ScheduleDay.prototype.remove = function (session) {
        this.scheduled_sessions.remove(session.id);
    };
    /**
     * Sort sessions in start time order
     */
    ScheduleDay.prototype.sortSessions = function () {
        this.scheduled_sessions.reorderSessionTimeStart();
    };
    ScheduleDay.prototype.isEmpty = function () {
        return this.scheduled_sessions.count() === 0;
    };
    return ScheduleDay;
}());



/***/ }),

/***/ "./src/js/models/Schedule/SessionSchedule.ts":
/*!***************************************************!*\
  !*** ./src/js/models/Schedule/SessionSchedule.ts ***!
  \***************************************************/
/*! exports provided: SessionSchedule */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SessionSchedule", function() { return SessionSchedule; });
/* harmony import */ var _ScheduleDay__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ScheduleDay */ "./src/js/models/Schedule/ScheduleDay.ts");

var SessionSchedule = /** @class */ (function () {
    function SessionSchedule(sessions) {
        this.days = [];
        this._importSessions(sessions);
        this._orderDays();
    }
    /**
     * Add a session to the schedule within its appropriate ScheduleDay
     */
    SessionSchedule.prototype.add = function (scheduled_session) {
        var day_index = this._scheduleDayIndex(scheduled_session.session);
        if (day_index !== -1) {
            this.days[day_index].add(scheduled_session);
            return;
        }
        this._addScheduleDay(scheduled_session);
    };
    SessionSchedule.prototype.removeDay = function (day_index) {
        this.days.splice(day_index, 1);
    };
    /**
     * Remove a session from the schedule
     * 1. Make sure session is in schedule
     * 2. Remove the session from the day
     * 3. If resulting day is empty, remove it from the days
     * @refactor: change to scheduled_session
     */
    SessionSchedule.prototype.remove = function (session) {
        var day_index = this._scheduleDayIndex(session);
        if (day_index === -1) {
            return;
        }
        var scheduleDay = this.days[day_index];
        scheduleDay.remove(session);
        if (scheduleDay.isEmpty()) {
            this.removeDay(day_index);
        }
    };
    SessionSchedule.prototype._importSessions = function (session_collection) {
        var timestampIndexedDays = {};
        /**
         * Loop over all scheduled sessions.  Create object with timestamp index containing schedule day for
         * sessions with that date. Add sessions to appropriate days
         */
        session_collection.all().forEach(function (scheduled_session) {
            var timestamp = scheduled_session.session.date.getTime();
            if (!timestampIndexedDays.hasOwnProperty(String(timestamp))) {
                timestampIndexedDays[timestamp] = new _ScheduleDay__WEBPACK_IMPORTED_MODULE_0__["ScheduleDay"](new Date(timestamp));
            }
            timestampIndexedDays[timestamp].add(scheduled_session);
        });
        /**
         * Loop over all days, sort the sessions in each and add it to the days array
         */
        for (var i in timestampIndexedDays) {
            var obj = timestampIndexedDays[i];
            obj.sortSessions();
            this.days.push(obj);
        }
    };
    /**
     * Sort the schedule days in date order
     */
    SessionSchedule.prototype._orderDays = function () {
        this.days.sort(function (a, b) {
            if (a.date > b.date) {
                return 1;
            }
            if (b.date > a.date) {
                return -1;
            }
            return 0;
        });
    };
    /**
     * Get the corresponding index for the appropriate ScheduleDay for a Session within the Schedule
     * Returns index if it exists, -1 if one doesn't
     * @note: depends on sessions date being a timestamp for 0:00:00:00 on the date
     */
    SessionSchedule.prototype._scheduleDayIndex = function (session) {
        for (var i = 0; i < this.days.length; i++) {
            var day = this.days[i];
            if (day.date.getTime() == session.date.getTime()) {
                return i;
            }
        }
        return -1;
    };
    /**
     * Add a new ScheduleDay to the schedule for a session
     */
    SessionSchedule.prototype._addScheduleDay = function (scheduled_session) {
        this.days.push(new _ScheduleDay__WEBPACK_IMPORTED_MODULE_0__["ScheduleDay"](scheduled_session.session.date, [scheduled_session]));
        this._orderDays();
    };
    return SessionSchedule;
}());



/***/ }),

/***/ "./src/js/models/Schedule/SkaterSchedule.ts":
/*!**************************************************!*\
  !*** ./src/js/models/Schedule/SkaterSchedule.ts ***!
  \**************************************************/
/*! exports provided: SkaterSchedule */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SkaterSchedule", function() { return SkaterSchedule; });
/* harmony import */ var _Collections_SessionCollection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Collections/SessionCollection */ "./src/js/models/Collections/SessionCollection.ts");
/* harmony import */ var _Collections_SkatingEventCollection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Collections/SkatingEventCollection */ "./src/js/models/Collections/SkatingEventCollection.ts");
/* harmony import */ var _SessionSchedule__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./SessionSchedule */ "./src/js/models/Schedule/SessionSchedule.ts");
/* harmony import */ var _Collections_ScheduledSessionCollection__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Collections/ScheduledSessionCollection */ "./src/js/models/Collections/ScheduledSessionCollection.ts");




/**
 * @refactor: remove unused members and methods
 */
var SkaterSchedule = /** @class */ (function () {
    function SkaterSchedule(scheduled_sessions, events) {
        this.scheduled_sessions = new _Collections_ScheduledSessionCollection__WEBPACK_IMPORTED_MODULE_3__["ScheduledSessionCollection"](scheduled_sessions);
        this.sessions = new _Collections_SessionCollection__WEBPACK_IMPORTED_MODULE_0__["SessionCollection"](this.scheduled_sessions.sessions());
        this._schedule = new _SessionSchedule__WEBPACK_IMPORTED_MODULE_2__["SessionSchedule"](this.scheduled_sessions);
        this._registered_events = new _Collections_SkatingEventCollection__WEBPACK_IMPORTED_MODULE_1__["SkatingEventCollection"](events);
    }
    Object.defineProperty(SkaterSchedule.prototype, "schedule", {
        get: function () {
            return this._schedule;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SkaterSchedule.prototype, "registered_events", {
        get: function () {
            return this._registered_events.all();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SkaterSchedule.prototype, "event_ids", {
        get: function () {
            return this._registered_events.ids();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SkaterSchedule.prototype, "session_ids", {
        get: function () {
            return this.scheduled_sessions.ids();
        },
        enumerable: true,
        configurable: true
    });
    SkaterSchedule.prototype.findEvent = function (event_id) {
        return this._registered_events.find(event_id);
    };
    SkaterSchedule.prototype.getScheduledSessionsForEvent = function (event_id) {
        return this.scheduled_sessions.eventId(event_id);
    };
    SkaterSchedule.prototype.contains = function (session) {
        return this.sessions.contains(session);
    };
    SkaterSchedule.prototype.add = function (scheduled_session) {
        this.scheduled_sessions.add(scheduled_session);
        this.sessions.add(scheduled_session.session);
        this._schedule.add(scheduled_session);
    };
    SkaterSchedule.prototype.findScheduledSession = function (session_id) {
        return this.scheduled_sessions.find(session_id);
    };
    SkaterSchedule.prototype.remove = function (scheduled_session) {
        this.scheduled_sessions.remove(scheduled_session.session.id);
        this.sessions.remove(scheduled_session.session);
        this._schedule.remove(scheduled_session.session);
    };
    //@refactor: remove if unused
    SkaterSchedule.prototype.getfirstDate = function () {
        var ordered = this.sessions.orderDate();
        if (ordered.count()) {
            var date = ordered.sessions[0].date;
            return new Date(date.getFullYear(), date.getMonth(), date.getDate());
        }
        return null;
    };
    SkaterSchedule.prototype.getfirstRinkDate = function (rink_id) {
        var filtered = this.sessions.filterRink(rink_id).orderDate();
        if (filtered.count()) {
            var date = filtered.sessions[0].date;
            return new Date(date.getFullYear(), date.getMonth(), date.getDate());
        }
        return null;
    };
    SkaterSchedule.prototype.getEventScheduledTypeAmount = function (event_id, session_type) {
        return this.scheduled_sessions.eventId(event_id).creditsUsed()[session_type];
    };
    SkaterSchedule.prototype.getEventScheduledTypeCounts = function (event_id) {
        return this.scheduled_sessions.eventId(event_id).creditsUsed();
    };
    /**
     * Return an array of event ids contained within the session that the skater is registered for
     */
    SkaterSchedule.prototype.filterAvailableSessionEventIds = function (session) {
        var schedulable_event_ids = this.event_ids;
        return session.event_ids.filter(function (event_id) {
            return schedulable_event_ids.indexOf(event_id) !== -1;
        });
    };
    return SkaterSchedule;
}());



/***/ }),

/***/ "./src/js/models/SessionValidator.ts":
/*!*******************************************!*\
  !*** ./src/js/models/SessionValidator.ts ***!
  \*******************************************/
/*! exports provided: SessionValidator */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SessionValidator", function() { return SessionValidator; });
var __assign = (undefined && undefined.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
var SessionValidator = /** @class */ (function () {
    function SessionValidator(skater, competition_information, active_sales_window) {
        this.valid_type_keys = ['warm_up', 'practice_ice'];
        this.default_validation_result = {
            valid: true,
            tests: {
                selectable_category: true,
                session_not_full: true,
                session_and_skater_share_events: true,
                session_and_competition_share_types: true,
                has_non_maxed_credit_types: true,
                selection_window_credits_available: true,
                is_not_on_site_sales: true
            },
            session_in_schedule: false,
            session_in_cart: false,
            available: true
        };
        this.skater = skater;
        this.competition_information = competition_information;
        this.active_sales_window = active_sales_window;
        this.skater_schedule = skater.schedule;
        this.skater_credits = skater.credits;
        this.schedule_session_ids = skater.schedule.session_ids;
        this.cart_session_ids = skater.cart.session_ids;
        this.skater_filled_session_types = skater.getSpentCredits(competition_information.schedulable_session_types);
        this.event_limits = competition_information.getEventsTypeLimits();
    }
    /*
      * Validate whether a session is available (available) or able to be interacted with by the user (valid)
      * Available:
      * Session is PI type
      * Session isn't full
      * Session isn't in schedule
      * Session isn't in cart
      * Session belongs to an event for which skater is registered
      * Of the types on the session, and the events for which  the skater is registered, no credit limits have been exceeded or the user has applicable unscheduled credits
      *
      * Selectable:
      * Session is PI type
      * Session isn't full
      * Session isn't in schedule
      * Session isn't in cart
      * Session belongs to an event for which skater is registered
      * Session has selectable type
      * Of the types on the session, and the events for which  the skater is registered, no credit limits have been exceeded or the user has applicable unscheduled credits
      * The window is selection, and the skater has applicable credits
      * The active sales window isn't on site
      */
    SessionValidator.prototype.validate = function (session) {
        var result = __assign({}, this.default_validation_result);
        /**
         * 1. Session isn't practice ice or Warm Up
         */
        if (this.valid_type_keys.indexOf(session.type_key) === -1) {
            result.tests.selectable_category = false;
            result.valid = false;
            result.available = false;
        }
        /**
         * 4. Session is full
         */
        if (session.is_full) {
            result.valid = false;
            result.available = false;
            result.tests.session_not_full = false;
        }
        /**
         * 2. Session is already in schedule
         */
        if (this.schedule_session_ids.indexOf(session.id) !== -1) {
            result.available = false;
            result.session_in_schedule = true;
        }
        /**
         * 3. Session is already in cart
         */
        if (this.cart_session_ids.indexOf(session.id) !== -1) {
            result.available = false;
            result.session_in_cart = true;
        }
        /**
         * 6. Session doesn't have any events for which the skater is registered
         * @refactor remove skater_schedule dependency
         */
        var valid_event_ids = this.skater_schedule.filterAvailableSessionEventIds(session);
        if (valid_event_ids.length === 0) {
            result.valid = false;
            result.available = false;
            result.tests.session_and_skater_share_events = false;
        }
        /**
         * 5. Session doesn't have any selectable types
         * Note - these sessions are available, but not selectable
         */
        var schedulable_types_from_session = this.competition_information.filterSessionSchedulableTypes(session);
        if (schedulable_types_from_session.length === 0) {
            result.valid = false;
            result.tests.session_and_competition_share_types = false;
        }
        /**
         * 7. Within the events the skater and session share, at least one of the session's credit type hasn't exceeded the max
         */
        if (!SessionValidator.checkLimits(valid_event_ids, this.event_limits, session.credit_types, this.skater_filled_session_types, this.skater_credits)) {
            result.valid = false;
            result.available = false;
            result.tests.has_non_maxed_credit_types = false;
        }
        /**
         * W-1
         * If active sales window is selection and the user doesn't have credits, invalid
         * in this case, it's still available
         */
        if (this.active_sales_window === "selection" && !SessionValidator.sessionCanBeScheduled(session, this.skater_credits)) {
            result.valid = false;
            result.tests.selection_window_credits_available = false;
        }
        /**
         * W-2
         */
        if (this.active_sales_window === "on_site") {
            result.valid = false;
            result.tests.is_not_on_site_sales = false;
        }
        return __assign({}, result, { valid_event_ids: valid_event_ids, schedulable_types_from_session: schedulable_types_from_session });
    };
    /**
     * Check to see if any of the session type/event id combinations have not yet been maxed out
     *
     * @param event_ids all the session's event id's the skater qualifies for
     * @param event_caps - the caps for each type for each event
     * @param session_types - the session types belonging to the session that are skater selectable
     * @param spent_credits - the config for the spent credits by the skater
     * @param skater_credits - active skater credits
     */
    SessionValidator.checkLimits = function (event_ids, event_caps, session_types, spent_credits, skater_credits) {
        for (var i = 0; i < event_ids.length; i++) {
            var event_id = event_ids[i];
            var event_credit_limits = event_caps[event_id];
            for (var j = 0; j < session_types.length; j++) {
                var session_type = session_types[j];
                var available_amount = event_credit_limits[session_type] - spent_credits[event_id][session_type];
                if (available_amount > 0) {
                    return true;
                }
                if (skater_credits.creditsAvailable(event_id, session_type)) {
                    return true;
                }
            }
        }
        return false;
    };
    /**
     * Check to see if any of the event/type combinations on the session have user credits available
     */
    SessionValidator.sessionCanBeScheduled = function (session, skater_credits) {
        var event_ids = session.event_ids;
        var session_types = session.credit_types;
        for (var i = 0; i < event_ids.length; i++) {
            var event_id = event_ids[i];
            for (var j = 0; j < session_types.length; j++) {
                var session_type = session_types[j];
                if (skater_credits.creditsAvailable(event_id, session_type)) {
                    return true;
                }
            }
        }
        return false;
    };
    return SessionValidator;
}());



/***/ }),

/***/ "./src/js/models/Sessions/CartSession.ts":
/*!***********************************************!*\
  !*** ./src/js/models/Sessions/CartSession.ts ***!
  \***********************************************/
/*! exports provided: CartSession */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CartSession", function() { return CartSession; });
/* harmony import */ var _ScheduledSession__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ScheduledSession */ "./src/js/models/Sessions/ScheduledSession.ts");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();

var CartSession = /** @class */ (function (_super) {
    __extends(CartSession, _super);
    function CartSession(parameters) {
        var _this = _super.call(this, parameters) || this;
        _this.cart_item_type_key = "session";
        _this.competition_id = parameters.competition_id;
        _this.cost = parameters.cost;
        _this.scheduled_event_name = parameters.scheduled_event_name;
        _this.competition_name = parameters.competition_name;
        return _this;
    }
    Object.defineProperty(CartSession.prototype, "event_id", {
        get: function () {
            return this.scheduled_event_id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CartSession.prototype, "event_name", {
        get: function () {
            return this.scheduled_event_name;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CartSession.prototype, "cart_description", {
        get: function () {
            return this.scheduled_as.toUpperCase();
        },
        enumerable: true,
        configurable: true
    });
    return CartSession;
}(_ScheduledSession__WEBPACK_IMPORTED_MODULE_0__["ScheduledSession"]));



/***/ }),

/***/ "./src/js/models/Sessions/PracticeIce.ts":
/*!***********************************************!*\
  !*** ./src/js/models/Sessions/PracticeIce.ts ***!
  \***********************************************/
/*! exports provided: PracticeIce */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PracticeIce", function() { return PracticeIce; });
/* harmony import */ var _Session__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Session */ "./src/js/models/Sessions/Session.ts");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/* eslint-disable */

var PracticeIce = /** @class */ (function (_super) {
    __extends(PracticeIce, _super);
    function PracticeIce(session_data) {
        var _this = _super.call(this, session_data) || this;
        _this._type_key = 'practice_ice';
        _this._types = session_data.practice_ice_types;
        _this._type_code = _this._types.join('/').toUpperCase();
        _this._credit_types = _this._types;
        _this._type_description = _this.importTypeDescription();
        return _this;
    }
    PracticeIce.prototype.importTypeDescription = function () {
        if (this._types.length === 1) {
            return PracticeIce.parseTypeDescription(this._types[0]);
        }
        return "Practice Ice (" + this._type_code + ")";
    };
    Object.defineProperty(PracticeIce.prototype, "types", {
        get: function () {
            return this._types;
        },
        enumerable: true,
        configurable: true
    });
    return PracticeIce;
}(_Session__WEBPACK_IMPORTED_MODULE_0__["Session"]));



/***/ }),

/***/ "./src/js/models/Sessions/Resurface.ts":
/*!*********************************************!*\
  !*** ./src/js/models/Sessions/Resurface.ts ***!
  \*********************************************/
/*! exports provided: Resurface */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Resurface", function() { return Resurface; });
/* harmony import */ var _Session__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Session */ "./src/js/models/Sessions/Session.ts");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();

var Resurface = /** @class */ (function (_super) {
    __extends(Resurface, _super);
    function Resurface(session_data) {
        var _this = _super.call(this, session_data) || this;
        _this._type_description = "Resurface";
        _this.name = "Ice Resurface";
        _this._type_key = 'resurface';
        _this._is_resurface = true;
        return _this;
    }
    return Resurface;
}(_Session__WEBPACK_IMPORTED_MODULE_0__["Session"]));



/***/ }),

/***/ "./src/js/models/Sessions/ScheduledSession.ts":
/*!****************************************************!*\
  !*** ./src/js/models/Sessions/ScheduledSession.ts ***!
  \****************************************************/
/*! exports provided: ScheduledSession */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ScheduledSession", function() { return ScheduledSession; });
/* harmony import */ var _Session__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Session */ "./src/js/models/Sessions/Session.ts");

var ScheduledSession = /** @class */ (function () {
    function ScheduledSession(parameters) {
        var session = parameters.session, scheduled_as = parameters.scheduled_as, scheduled_event_id = parameters.scheduled_event_id;
        this.session = session;
        this.scheduled_as = scheduled_as;
        this.scheduled_event_id = scheduled_event_id;
    }
    Object.defineProperty(ScheduledSession.prototype, "type_description", {
        get: function () {
            if (['upi', 'opi'].indexOf(this.scheduled_as) !== -1) {
                return _Session__WEBPACK_IMPORTED_MODULE_0__["Session"].parseTypeDescription(this.scheduled_as);
            }
            return this.session.type_description;
        },
        enumerable: true,
        configurable: true
    });
    return ScheduledSession;
}());



/***/ }),

/***/ "./src/js/models/Sessions/SelectedSession.ts":
/*!***************************************************!*\
  !*** ./src/js/models/Sessions/SelectedSession.ts ***!
  \***************************************************/
/*! exports provided: SelectedSession */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SelectedSession", function() { return SelectedSession; });
/* harmony import */ var _ScheduledSession__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ScheduledSession */ "./src/js/models/Sessions/ScheduledSession.ts");
var __assign = (undefined && undefined.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};

/**
 * @refactor: remove competition information dependency
 */
var SelectedSession = /** @class */ (function () {
    function SelectedSession(session_args, competition_information, validation_result) {
        this.reduced_event_id = -1;
        this.reduced_session_type = "";
        this.validation_result = validation_result;
        this.session_args = session_args;
        this.competition_information = competition_information;
        this.session = session_args.session;
        this.qualifying_event_ids = validation_result.valid_event_ids;
        this.selectable_types = validation_result.schedulable_types_from_session;
        this.selected_event_id = session_args.selected_event_id;
        this.selected_session_type = session_args.selected_session_type;
        this.reduced_event_id = this.reduceEventId();
        this.reduced_session_type = this.reduceType();
    }
    SelectedSession.prototype.typeisSelectable = function (type) {
        return this.selectable_types.indexOf(type) !== -1;
    };
    SelectedSession.prototype.reduceType = function () {
        //if user has selected a session type and it's selectable
        if (this.session_args.selected_session_type && this.typeisSelectable(this.session_args.selected_session_type)) {
            return this.session_args.selected_session_type;
        }
        // selected session only has one type and it's selectable
        if (this.session_args.session.credit_types.length === 1 && this.typeisSelectable(this.session_args.session.credit_types[0])) {
            return this.session_args.session.credit_types[0];
        }
        return "";
    };
    SelectedSession.prototype.reduceEventId = function () {
        if (this.session_args.selected_event_id) {
            return this.session_args.selected_event_id;
        }
        if (this.qualifying_event_ids.length === 1) {
            return this.qualifying_event_ids[0];
        }
        return -1;
    };
    SelectedSession.prototype.exportSession = function (event_id, type) {
        return new _ScheduledSession__WEBPACK_IMPORTED_MODULE_0__["ScheduledSession"]({
            session: this.session,
            scheduled_as: type,
            scheduled_event_id: event_id
        });
    };
    /**
     * Determine whether the user selected session can be scheduled or added to cart.
     * Validation Results indicate
     * 1. Whether the session is valid to be processed - Returns payload with success:true
     * 2. Whether the session requires further input to be processed
     * 2.a. Select event from multiple qualifying events
     * 2.b. Select session type from multiple qualifying session types
     * 3. Whether the user can't select the session
     * 3.a. Session does not belong to any of user's events
     * 3.b. Session type is not selectable based on competition configuration
     *
     */
    SelectedSession.prototype.export = function () {
        var validation_result = this.validation_result.tests;
        /**
         * WU/OPI/UPI - exclude event and resurface sessions
         */
        if (!validation_result.selectable_category) {
            return SelectedSession.nonSchedulableType();
        }
        /**
         * If session is full, not eligible
         */
        if (!validation_result.session_not_full) {
            return SelectedSession.sessionFull();
        }
        /**
         * If user doesn't have any event overlap, not eligible
         */
        if (this.qualifying_event_ids.length === 0) {
            return SelectedSession.skaterNotEligible();
        }
        /**
         * It's on site sales, no sessions are selectable
         * @note: [2018-06-08] - if we want to allow user to go through steps of selecting event and session type
         * only to be met with "PI managed on site" message, this can be lowered in the process.
         */
        if (!validation_result.is_not_on_site_sales) {
            return SelectedSession.onSiteSalesActive();
        }
        /**
         * Session has no selectable types - tell user to purchase credit
         */
        if (this.selectable_types.length === 0) {
            return this.sessionNotSelectable();
        }
        /**
         * If unable to distill a single qualifying event...
         * 1. Ask for feedback if the user qualifies for 2+
         * 2. Report not eligible
         */
        if (this.reduced_event_id === -1) {
            if (this.qualifying_event_ids.length > 1) {
                return this.multipleQualifyingEvents();
            }
            return SelectedSession.skaterNotEligible();
        }
        /**
         * It's the selection window and the user has no applicable credits available
         *
         * @note: placing after event refinement because messaging is limited to credit type
         * This could be placed before asking the user to select and event with no collateral damage
         */
        if (!validation_result.selection_window_credits_available) {
            return this.noSelectionCreditsAvailable();
        }
        /**
         * If unable to distill a single session type...
         * 1.
         */
        if (this.reduced_session_type === "") {
            if (this.selectable_types.length === 1) {
                var session_types = this.session_args.session.credit_types.slice();
                return this.singleQualifyingTypeAvailable(session_types);
            }
            if (this.selectable_types.length > 1) {
                return this.multipleQualifyingTypes();
            }
            /**
             * Case: this.selectable_types.length===0
             * This will have been handled earlier in the process, but it has been left here for legibility/maintainability
             * Given current structure, this should not execute
             */
            return this.sessionNotSelectable();
        }
        /**
         * User has reached the max credits
         */
        if (!validation_result.has_non_maxed_credit_types) {
            return this.maxTypeReached();
        }
        var exportedSession = this.exportSession(this.reduced_event_id, this.reduced_session_type);
        return SelectedSession.exportSuccess(exportedSession);
    };
    SelectedSession.exportSuccess = function (exportedSession) {
        return __assign({}, defaultSessionValidationResult, { success: true, secondary_action: false, exported_session: exportedSession });
    };
    SelectedSession.prototype.maxTypeReached = function () {
        return __assign({}, defaultSessionValidationResult, { rejection: true, secondary_action: false, rejection_message: "You have reached max " + this.reduced_session_type.toUpperCase() });
    };
    SelectedSession.prototype.sessionNotSelectable = function () {
        return __assign({}, defaultSessionValidationResult, { secondary_action: false, rejection: true, rejection_message: "You cannot schedule this session type. Please purchase " + this.session_args.session.credit_types.join('/').toUpperCase() + " credit." });
    };
    SelectedSession.prototype.noSelectionCreditsAvailable = function () {
        var credit_type = this.validation_result.schedulable_types_from_session.join('/').toUpperCase();
        if (this.selected_session_type) {
            credit_type = this.selected_session_type.toUpperCase();
        }
        return __assign({}, defaultSessionValidationResult, { secondary_action: false, rejection: true, rejection_message: "You don’t have a " + credit_type + " credit available." });
    };
    SelectedSession.prototype.multipleQualifyingTypes = function () {
        return __assign({}, defaultSessionValidationResult, { secondary_action: true, secondary_action_key: "select_type", secondary_action_args: {
                matched_types: this.selectable_types
            } });
    };
    SelectedSession.prototype.singleQualifyingTypeAvailable = function (session_types) {
        var available_type = this.selectable_types[0];
        var alternate_types = session_types.slice();
        alternate_types.splice(alternate_types.indexOf(available_type), 1);
        return __assign({}, defaultSessionValidationResult, { secondary_action: true, secondary_action_key: "confirm_single_type", secondary_action_args: {
                available_type: available_type,
                alternate_types: alternate_types
            } });
    };
    SelectedSession.skaterNotEligible = function () {
        return __assign({}, defaultSessionValidationResult, { secondary_action: false, rejection: true, rejection_message: "You are not eligible for this session." });
    };
    SelectedSession.sessionFull = function () {
        return __assign({}, defaultSessionValidationResult, { secondary_action: false, rejection: true, rejection_message: "This session is full." });
    };
    SelectedSession.nonSchedulableType = function () {
        return __assign({}, defaultSessionValidationResult, { secondary_action: false, rejection: true, rejection_message: "This is not a practice ice session." });
    };
    SelectedSession.onSiteSalesActive = function () {
        return __assign({}, defaultSessionValidationResult, { secondary_action: false, rejection: true, rejection_message: "All practice ice is managed onsite. Please see the LOC." });
    };
    SelectedSession.prototype.multipleQualifyingEvents = function () {
        var self = this;
        return __assign({}, defaultSessionValidationResult, { secondary_action: true, secondary_action_key: "select_event", secondary_action_args: {
                matched_events: this.qualifying_event_ids.reduce(function (result, id) {
                    var event = self.competition_information.getEvent(id);
                    if (event) {
                        result.push(event);
                    }
                    return result;
                }, [])
            } });
    };
    return SelectedSession;
}());

var defaultSessionValidationResult = {
    success: false,
    secondary_action_key: '',
    secondary_action_args: {},
    secondary_action: false,
    rejection: false,
    rejection_message: "",
    exported_session: false
};


/***/ }),

/***/ "./src/js/models/Sessions/Session.ts":
/*!*******************************************!*\
  !*** ./src/js/models/Sessions/Session.ts ***!
  \*******************************************/
/*! exports provided: Session */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Session", function() { return Session; });
/* harmony import */ var _helpers_time__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../helpers/time */ "./src/js/helpers/time.ts");
/* harmony import */ var _adaptors_RinkDataAdaptor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../adaptors/RinkDataAdaptor */ "./src/js/adaptors/RinkDataAdaptor.ts");


var Session = /** @class */ (function () {
    function Session(session_data, rink) {
        this.slots_registered = 0;
        this.slots_available = 0;
        this._is_event = false;
        this._is_resurface = false;
        this._credit_types = [];
        this._location = "";
        this._cost = 0;
        this.name = session_data.name;
        this._id = session_data.id;
        this._date = new Date(session_data.date);
        this._time_start = new Date(session_data.time_start);
        this._time_end = new Date(session_data.time_end);
        this.slots_registered = session_data.slots_registered;
        this.slots_available = session_data.slots_available;
        this._pretty_time_start = Object(_helpers_time__WEBPACK_IMPORTED_MODULE_0__["prettyTime"])(this._time_start);
        this._time_start_meridian = Object(_helpers_time__WEBPACK_IMPORTED_MODULE_0__["meridian"])(this._time_start);
        this._time_end_meridian = Object(_helpers_time__WEBPACK_IMPORTED_MODULE_0__["meridian"])(this._time_end);
        this._pretty_time_end = Object(_helpers_time__WEBPACK_IMPORTED_MODULE_0__["prettyTime"])(this._time_end);
        this._rink = this._importRink(session_data, rink);
        this._facility_name = this._rink.facility.name;
        this._event_ids = session_data.event_ids;
        if (session_data.location) {
            this._location = session_data.location;
        }
    }
    Object.defineProperty(Session.prototype, "location", {
        get: function () {
            return this._location;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Session.prototype, "type_description", {
        get: function () {
            return this._type_description;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Session.prototype, "event_ids", {
        get: function () {
            return this._event_ids;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Session.prototype, "facility_name", {
        get: function () {
            return this._facility_name;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Session.prototype, "is_event", {
        get: function () {
            return this._is_event;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Session.prototype, "id", {
        get: function () {
            return this._id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Session.prototype, "type_code", {
        get: function () {
            return this._type_code ? this._type_code : '';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Session.prototype, "is_full", {
        get: function () {
            return this.slots_registered >= this.slots_available;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Session.prototype, "is_available", {
        get: function () {
            return !this.is_full;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Session.prototype, "type_key", {
        get: function () {
            return this._type_key;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Session.prototype, "date", {
        get: function () {
            return this._date;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Session.prototype, "time_start", {
        get: function () {
            return this._time_start;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Session.prototype, "time_end", {
        get: function () {
            return this._time_end;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Session.prototype, "time_start_meridian", {
        get: function () {
            return this._time_start_meridian;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Session.prototype, "time_end_meridian", {
        get: function () {
            return this._time_end_meridian;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Session.prototype, "is_resurface", {
        get: function () {
            return this._is_resurface;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Session.prototype, "pretty_time_end", {
        get: function () {
            return this._pretty_time_end;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Session.prototype, "pretty_time_start", {
        get: function () {
            return this._pretty_time_start;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Session.prototype, "credit_types", {
        get: function () {
            return this._credit_types;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Session.prototype, "rink", {
        get: function () {
            return this._rink;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Session.prototype, "cost", {
        get: function () {
            return this._cost;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Session.prototype, "full_location", {
        get: function () {
            var result = this.rink.name;
            if (this._location !== "") {
                result += " - " + this._location;
            }
            return result;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @refactor: investigate and refactor/remove
     * Data should be adapted on the adaptor layer, not within the model layer
     */
    Session.prototype._importRink = function (session_data, rink) {
        if (rink) {
            return rink;
        }
        return _adaptors_RinkDataAdaptor__WEBPACK_IMPORTED_MODULE_1__["RinkDataAdaptor"].adaptFull(session_data.rink);
    };
    Session.parseTypeDescription = function (type) {
        if (type === "upi") {
            return "Unofficial Practice Ice (UPI)";
        }
        if (type === "opi") {
            return "Official Practice Ice (OPI)";
        }
        if (type === "wu") {
            return "Warm Up (WU)";
        }
        return "";
    };
    return Session;
}());



/***/ }),

/***/ "./src/js/models/Sessions/SessionSelector.ts":
/*!***************************************************!*\
  !*** ./src/js/models/Sessions/SessionSelector.ts ***!
  \***************************************************/
/*! exports provided: SessionSelector */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SessionSelector", function() { return SessionSelector; });
var SessionSelector = /** @class */ (function () {
    function SessionSelector(parameters) {
        this._dispatcher = parameters.dispatcher;
        this.session_in_cart = parameters.session_in_cart;
        this.session_in_schedule = parameters.session_in_schedule;
        this.competition_information = parameters.competition_information;
        this.skater_credits = parameters.skater_credits;
        this.active_sales_window = parameters.active_sales_window;
    }
    SessionSelector.prototype.processSelection = function (selected_session) {
        if (this.session_in_cart) {
            return this.removeFromCart(selected_session);
        }
        if (this.session_in_schedule) {
            return this.attemptRemoveFromSchedule(selected_session, this.session_in_schedule);
        }
        return this.attemptSelection(selected_session);
    };
    SessionSelector.prototype.attemptSelection = function (selected_session) {
        var selected_session_export_result = selected_session.export();
        if (selected_session_export_result.success) {
            return this.handleValidSelection(selected_session_export_result.exported_session);
        }
        return this.handleInvalidSelection(selected_session_export_result);
    };
    SessionSelector.prototype.removeFromCart = function (selected_session) {
        var dispatcher = this._dispatcher;
        return new Promise(function (resolve, reject) {
            dispatcher('cart/removeSession', selected_session, { root: true }).then(function (resolution_function) {
                resolve({
                    message: "Removed from cart.",
                    type: "error",
                    secondary_action: false,
                    resolution_function: resolution_function
                });
                return;
            }).catch(function () {
                reject('Error removing from cart.');
                return;
            });
        });
    };
    SessionSelector.prototype.attemptRemoveFromSchedule = function (selected_session, scheduled_session) {
        if (this.active_sales_window === "on_site") {
            return SessionSelector.ScheduledEventCannotBeRemoved;
        }
        if (!this.competition_information.sessionTypeIsSelectable(scheduled_session.scheduled_as)) {
            return SessionSelector.ScheduledEventCannotBeRemoved;
        }
        if (!selected_session.session_args.action_confirmed) {
            return SessionSelector.ConfirmRemovalFromSchedule;
        }
        return this.removeSessionFromSchedule(scheduled_session);
    };
    SessionSelector.prototype.handleValidSelection = function (processable_session) {
        var skater_credits = this.skater_credits;
        if (skater_credits.creditsAvailable(processable_session.scheduled_event_id, processable_session.scheduled_as)) {
            return this.addToSchedule(processable_session);
        }
        return this.addToCart(processable_session);
    };
    SessionSelector.prototype.addToSchedule = function (processable_session) {
        var dispatcher = this._dispatcher;
        return new Promise(function (resolve, reject) {
            dispatcher('skater/addSessionToSchedule', {
                scheduled_session: processable_session
            }, { root: true }).then(function (resolution_function) {
                resolve({
                    message: "Added to Schedule",
                    type: "success",
                    secondary_action: false,
                    resolution_function: resolution_function
                });
            }).catch(function () {
                reject('Error Adding to schedule');
            });
            return;
        });
    };
    SessionSelector.prototype.handleInvalidSelection = function (validation_result) {
        var result = validation_result;
        return new Promise(function (resolve) {
            if (result.secondary_action) {
                return resolve({
                    secondary_action: result.secondary_action_key,
                    secondary_action_args: result.secondary_action_args
                });
            }
            return resolve({
                type: 'error',
                message: result.rejection_message,
                secondary_action: false
            });
        });
    };
    SessionSelector.prototype.removeSessionFromSchedule = function (scheduled_session) {
        var dispatcher = this._dispatcher;
        return new Promise(function (resolve, reject) {
            return dispatcher('skater/removeSessionFromSchedule', {
                scheduled_session: scheduled_session
            }, { root: true }).then(function (resolution_function) {
                resolve({
                    message: "Removed from schedule.",
                    type: "error",
                    secondary_action: false,
                    resolution_function: resolution_function
                });
            }).catch(function () {
                reject('Error removing from schedule.');
            });
        });
    };
    SessionSelector.prototype.addToCart = function (processable_session) {
        var dispatcher = this._dispatcher;
        var event_name = this.competition_information.getEvent(processable_session.scheduled_event_id).name;
        var payload = {
            competition_id: this.competition_information.competition_id,
            event_name: event_name,
            session: processable_session,
            cost: this.competition_information.getEventTypeCost(processable_session.scheduled_event_id, processable_session.scheduled_as)
        };
        return new Promise(function (resolve, reject) {
            dispatcher('cart/addSession', payload, { root: true }).then(function (resolution_function) {
                resolve({
                    message: "Added to cart",
                    type: "success",
                    secondary_action: false,
                    resolution_function: resolution_function
                });
            }).catch(function () {
                reject('Error Adding to Cart');
            });
        });
    };
    SessionSelector.ConfirmRemovalFromSchedule = new Promise(function (resolve) {
        resolve({
            secondary_action: "confirm_removal",
        });
    });
    SessionSelector.ScheduledEventCannotBeRemoved = new Promise(function (resolve) {
        resolve({
            message: "This session can only be removed by an an event administrator.",
            type: "error",
            secondary_action: false
        });
    });
    return SessionSelector;
}());



/***/ }),

/***/ "./src/js/models/Sessions/SkatingEventSession.ts":
/*!*******************************************************!*\
  !*** ./src/js/models/Sessions/SkatingEventSession.ts ***!
  \*******************************************************/
/*! exports provided: SkatingEventSession */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SkatingEventSession", function() { return SkatingEventSession; });
/* harmony import */ var _Session__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Session */ "./src/js/models/Sessions/Session.ts");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();

var SkatingEventSession = /** @class */ (function (_super) {
    __extends(SkatingEventSession, _super);
    function SkatingEventSession(session_data) {
        var _this = _super.call(this, session_data) || this;
        _this._type_description = "";
        _this._type_key = 'event';
        _this._is_event = true;
        _this.event_type = "";
        _this.event_type = session_data.event_type;
        if (session_data.icon_color) {
            _this._icon_color = session_data.icon_color;
        }
        return _this;
    }
    Object.defineProperty(SkatingEventSession.prototype, "icon_class", {
        get: function () {
            return "session__icon--" + this.event_type.toLowerCase();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SkatingEventSession.prototype, "icon_style_override", {
        get: function () {
            if (!this._icon_color) {
                return;
            }
            return "background-color:" + this._icon_color + ";";
        },
        enumerable: true,
        configurable: true
    });
    return SkatingEventSession;
}(_Session__WEBPACK_IMPORTED_MODULE_0__["Session"]));



/***/ }),

/***/ "./src/js/models/Sessions/WarmUp.ts":
/*!******************************************!*\
  !*** ./src/js/models/Sessions/WarmUp.ts ***!
  \******************************************/
/*! exports provided: WarmUp */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WarmUp", function() { return WarmUp; });
/* harmony import */ var _Session__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Session */ "./src/js/models/Sessions/Session.ts");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/* eslint-disable */

var WarmUp = /** @class */ (function (_super) {
    __extends(WarmUp, _super);
    function WarmUp(session_data) {
        var _this = _super.call(this, session_data) || this;
        _this._type_description = "Warm Up (WU)";
        _this._type_key = 'warm_up';
        _this._type_code = "WU";
        _this._credit_types = ['wu'];
        return _this;
    }
    return WarmUp;
}(_Session__WEBPACK_IMPORTED_MODULE_0__["Session"]));



/***/ }),

/***/ "./src/js/models/SkateTestEquivalency/SkateTestDisciplineFormState.ts":
/*!****************************************************************************!*\
  !*** ./src/js/models/SkateTestEquivalency/SkateTestDisciplineFormState.ts ***!
  \****************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _FormState__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../FormState */ "./src/js/models/FormState.ts");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (undefined && undefined.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};

/**
 * Class to track state of Skate Test Discipline Form data
 */
var SkateTestDisciplineFormState = /** @class */ (function (_super) {
    __extends(SkateTestDisciplineFormState, _super);
    function SkateTestDisciplineFormState(default_club) {
        if (default_club === void 0) { default_club = true; }
        var _this = _super.call(this) || this;
        _this.test = null;
        _this.club = null;
        _this.club_id = null;
        _this.date = null;
        if (default_club) {
            _this.club = "Foreign";
        }
        return _this;
    }
    /**
     * Export the form data state.
     * Flatten FormOptions
     */
    SkateTestDisciplineFormState.prototype.export = function () {
        return {
            test: this.test ? this.test : { label: "None", value: null, level_id: 0 },
            club: this.club ? this.club : '',
            date: this.date ? this.date : '',
            club_id: this.club_id ? this.club_id : null,
        };
    };
    SkateTestDisciplineFormState.prototype.import = function (data) {
        if (!data) {
            return;
        }
        this.test = __assign({}, data.test);
        this.club = data.club;
        this.date = data.date;
    };
    return SkateTestDisciplineFormState;
}(_FormState__WEBPACK_IMPORTED_MODULE_0__["FormState"]));
/* harmony default export */ __webpack_exports__["default"] = (SkateTestDisciplineFormState);


/***/ }),

/***/ "./src/js/models/SkateTestEquivalency/SkateTestDisciplineFormValidator.ts":
/*!********************************************************************************!*\
  !*** ./src/js/models/SkateTestEquivalency/SkateTestDisciplineFormValidator.ts ***!
  \********************************************************************************/
/*! exports provided: SkateTestDisciplineFormValidator */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SkateTestDisciplineFormValidator", function() { return SkateTestDisciplineFormValidator; });
/* harmony import */ var _FormValidator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../FormValidator */ "./src/js/models/FormValidator.ts");
/* harmony import */ var _config_AppConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../config/AppConfig */ "./src/js/config/AppConfig.ts");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();


/**
 * Validator to be used with Skate Test Discipline Forms
 */
var SkateTestDisciplineFormValidator = /** @class */ (function (_super) {
    __extends(SkateTestDisciplineFormValidator, _super);
    function SkateTestDisciplineFormValidator(form_data) {
        var _this = _super.call(this, form_data) || this;
        _this.rules = {
            test: ['required'],
            club: ['required'],
            date: ['required', 'date_formatted', 'date_not_future']
        };
        _this.messages = {
            required: "This field is required",
            date_formatted: "Enter a valid date in the format mm/dd/yyyy",
            date_not_future: "Enter a date that's not in the future",
        };
        if (_config_AppConfig__WEBPACK_IMPORTED_MODULE_1__["SKIP_VALIDATION"]) {
            _this.rules = {};
        }
        return _this;
    }
    return SkateTestDisciplineFormValidator;
}(_FormValidator__WEBPACK_IMPORTED_MODULE_0__["FormValidator"]));



/***/ }),

/***/ "./src/js/models/Skater.ts":
/*!*********************************!*\
  !*** ./src/js/models/Skater.ts ***!
  \*********************************/
/*! exports provided: Skater */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Skater", function() { return Skater; });
/* harmony import */ var _Schedule_SkaterSchedule__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Schedule/SkaterSchedule */ "./src/js/models/Schedule/SkaterSchedule.ts");
/* harmony import */ var _Cart_Cart__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Cart/Cart */ "./src/js/models/Cart/Cart.ts");
/* harmony import */ var _Credits_SkaterCredits__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Credits/SkaterCredits */ "./src/js/models/Credits/SkaterCredits.ts");



var Skater = /** @class */ (function () {
    function Skater(parameters) {
        var schedule = parameters.schedule, cart = parameters.cart, credits = parameters.credits;
        this._schedule = schedule ? schedule : new _Schedule_SkaterSchedule__WEBPACK_IMPORTED_MODULE_0__["SkaterSchedule"]([], []);
        this._cart = cart ? cart : new _Cart_Cart__WEBPACK_IMPORTED_MODULE_1__["Cart"]([], 0);
        this._credits = credits ? credits : new _Credits_SkaterCredits__WEBPACK_IMPORTED_MODULE_2__["SkaterCredits"]();
    }
    Object.defineProperty(Skater.prototype, "schedule", {
        get: function () {
            return this._schedule;
        },
        set: function (value) {
            this._schedule = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Skater.prototype, "credits", {
        get: function () {
            return this._credits;
        },
        set: function (value) {
            this._credits = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Skater.prototype, "cart", {
        get: function () {
            return this._cart;
        },
        set: function (value) {
            this._cart = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Get the amount of credits used/acquired toward event allowed maximums
     *
     * Get an event_id-indexed list of spent session types to determine whether sessions are available to skaters
     * Spent credits come in the form of sessions in the cart or sessions in the schedule
     *
     * Credits in cart (in the form of packages or single credits) are counted as spent if they are of a selectable type.
     *
     * Unscheduled credits are NOT counted as used, since they can be applied toward selected sessions.  They have a 1-1 increment/decrement cycle
     *
     * By default, gets list for all scheduled event ids. Optional parameter to get list for specific event ids.
     *
     */
    Skater.prototype.getSpentCredits = function (schedulable_session_types) {
        var limit_event_ids = this._schedule.event_ids;
        var index_cart_session_credits = this._cart.getIndexedEventCreditsSpent(limit_event_ids, schedulable_session_types);
        var result = {};
        for (var i = 0; i < limit_event_ids.length; i++) {
            var event_id = limit_event_ids[i];
            result[event_id] = {
                event_id: event_id,
                opi: 0,
                wu: 0,
                upi: 0,
            };
            var keys = [
                'opi',
                'wu',
                'upi'
            ];
            //...get the scheduled session type amounts from schedule for that event
            var scheduled_counts = this._schedule.getEventScheduledTypeCounts(event_id);
            // ... get the cart session type amounts for that event && get the cart credits from cart for that event
            var cart_counts = index_cart_session_credits[event_id];
            // ... get the unscheduled credits from credits for that event
            // ......sum up totals
            for (var j = 0; j < keys.length; j++) {
                var obj = keys[j];
                result[event_id][obj] = scheduled_counts[obj] + cart_counts[obj];
            }
        }
        return result;
    };
    /**
     * Get the amount of credits a user has acquired toward credit purchase maximums
     *
     * Get an event-id indexed dictionary of credits a skater has acquired within the active state
     * Totals Consist of:
     * - Credits in Cart
     * - Sessions in Cart
     * - Sessions in Schedule
     * - Purchased, unscheduled credits
     *
     * By default, gets list for all scheduled event ids. Optional parameter to get list for specific event ids.
     *
     */
    Skater.prototype.getAcquiredCredits = function (limit_event_ids) {
        if (!limit_event_ids || limit_event_ids.length === 0) {
            limit_event_ids = this._schedule.event_ids;
        }
        var indexed_cart_credits = this._cart.getIndexedEventCreditsUsed(limit_event_ids);
        var result = {};
        for (var i = 0; i < limit_event_ids.length; i++) {
            var event_id = limit_event_ids[i];
            result[event_id] = {
                event_id: event_id,
                opi: 0,
                wu: 0,
                upi: 0,
            };
            var keys = [
                'opi',
                'wu',
                'upi'
            ];
            //...get the scheduled session type amounts from schedule for that event
            var scheduled_counts = this._schedule.getEventScheduledTypeCounts(event_id);
            // ... get the cart session type amounts for that event && get the cart credits from cart for that event
            var cart_counts = indexed_cart_credits[event_id];
            // ... get the unscheduled credits from credits for that event
            //@note: purchased credits shouldn't count against max event limits, but should count against credit purchase limits
            // if a session was scheduled with credits, the credit would be double decremented. Only us unscheduled credits to reduce total
            var unscheduled_counts = this._credits.unscheduledCredits(event_id);
            // ......sum up totals
            for (var j = 0; j < keys.length; j++) {
                var obj = keys[j];
                result[event_id][obj] = scheduled_counts[obj] + cart_counts[obj] + unscheduled_counts[obj];
            }
        }
        return result;
    };
    return Skater;
}());



/***/ }),

/***/ "./src/js/models/SkaterCoachedEventCategory.ts":
/*!*****************************************************!*\
  !*** ./src/js/models/SkaterCoachedEventCategory.ts ***!
  \*****************************************************/
/*! exports provided: SkaterCoachedEventCategory */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SkaterCoachedEventCategory", function() { return SkaterCoachedEventCategory; });
;
var SkaterCoachedEventCategory = /** @class */ (function () {
    function SkaterCoachedEventCategory(parameters) {
        var id = parameters.id, name = parameters.name, coach_limit = parameters.coach_limit, coaches = parameters.coaches;
        this.id = id;
        this.name = name;
        this.coach_limit = coach_limit;
        this.coaches = coaches;
    }
    Object.defineProperty(SkaterCoachedEventCategory.prototype, "coach_limit_met", {
        get: function () {
            return this.coaches.length >= this.coach_limit;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SkaterCoachedEventCategory.prototype, "members", {
        get: function () {
            return this.coaches;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SkaterCoachedEventCategory.prototype, "member_limit", {
        get: function () {
            return this.coach_limit;
        },
        enumerable: true,
        configurable: true
    });
    return SkaterCoachedEventCategory;
}());



/***/ }),

/***/ "./src/js/models/SkaterSkatingEventSegment.ts":
/*!****************************************************!*\
  !*** ./src/js/models/SkaterSkatingEventSegment.ts ***!
  \****************************************************/
/*! exports provided: SkaterSkatingEventSegment */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SkaterSkatingEventSegment", function() { return SkaterSkatingEventSegment; });
/* harmony import */ var _helpers_time__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../helpers/time */ "./src/js/helpers/time.ts");

var SkaterSkatingEventSegment = /** @class */ (function () {
    function SkaterSkatingEventSegment(parameters) {
        this.ppc_last_modified_date = null;
        this.ppc_last_modified = null;
        this.music_last_modified_date = null;
        this.music_last_modified = null;
        this._ppc_last_modified_timestamp = null;
        this._music_last_modified_timestamp = null;
        // @downstream-sync 2020-07-02 - import rhythm/theme feature
        var event_name = parameters.event_name, segment_name = parameters.segment_name, event_id = parameters.event_id, segment_id = parameters.segment_id, ppc_required = parameters.ppc_required, music_required = parameters.music_required, rhythm_required = parameters.rhythm_required, theme_required = parameters.theme_required, is_ppc_complete = parameters.is_ppc_complete, is_music_complete = parameters.is_music_complete, is_rhythm_complete = parameters.is_rhythm_complete, is_theme_complete = parameters.is_theme_complete, ppc_last_modified_timestamp = parameters.ppc_last_modified_timestamp, music_last_modified_timestamp = parameters.music_last_modified_timestamp, competition_skated_event_id = parameters.competition_skated_event_id, rhythms = parameters.rhythms, theme = parameters.theme;
        this.event_name = event_name;
        this.segment_name = segment_name;
        this.event_id = event_id;
        this.segment_id = segment_id;
        this.ppc_required = ppc_required;
        this.music_required = music_required;
        this.rhythm_required = rhythm_required; // @downstream-sync 2020-07-02 - import rhythm/theme feature
        this.theme_required = theme_required; // @downstream-sync 2020-07-02 - import rhythm/theme feature
        this.is_ppc_complete = is_ppc_complete;
        this.is_music_complete = is_music_complete;
        this.is_rhythm_complete = is_rhythm_complete; // @downstream-sync 2020-07-02 - import rhythm/theme feature
        this.is_theme_complete = is_theme_complete; // @downstream-sync 2020-07-02 - import rhythm/theme feature
        this.competition_skated_event_id = competition_skated_event_id;
        this.ppc_last_modified_timestamp = ppc_last_modified_timestamp;
        this.music_last_modified_timestamp = music_last_modified_timestamp;
        this.rhythms = rhythms; // @downstream-sync 2020-07-02 - import rhythm/theme feature
        this.theme = theme; // @downstream-sync 2020-07-02 - import rhythm/theme feature
    }
    Object.defineProperty(SkaterSkatingEventSegment.prototype, "music_last_modified_timestamp", {
        set: function (value) {
            this._music_last_modified_timestamp = value;
            this.music_last_modified_date = value ? new Date(value) : null;
            this.music_last_modified = SkaterSkatingEventSegment.formatModifiedDate(this.music_last_modified_date);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SkaterSkatingEventSegment.prototype, "ppc_last_modified_timestamp", {
        set: function (value) {
            this._ppc_last_modified_timestamp = value;
            this.ppc_last_modified_date = value ? new Date(value) : null;
            this.ppc_last_modified = SkaterSkatingEventSegment.formatModifiedDate(this.ppc_last_modified_date);
        },
        enumerable: true,
        configurable: true
    });
    SkaterSkatingEventSegment.formatModifiedDate = function (date) {
        if (!date) {
            return null;
        }
        return Object(_helpers_time__WEBPACK_IMPORTED_MODULE_0__["DateFormatAbridgedYear"])(date);
    };
    SkaterSkatingEventSegment.prototype.handlePPCUpdate = function (save_response) {
        this.is_ppc_complete = save_response.is_complete;
        this.ppc_last_modified_timestamp = save_response.last_modified;
    };
    SkaterSkatingEventSegment.prototype.handleMusicUpdate = function (save_response) {
        this.is_music_complete = save_response.is_complete;
        this.music_last_modified_timestamp = save_response.last_modified;
    };
    // @downstream-sync 2020-07-02 - import rhythm/theme feature
    SkaterSkatingEventSegment.prototype.handleRhythmUpdate = function (save_response) {
        this.is_rhythm_complete = save_response.is_complete;
        this.rhythms = save_response.rhythms;
    };
    // @downstream-sync 2020-07-02 - import rhythm/theme feature
    SkaterSkatingEventSegment.prototype.handleThemeUpdate = function (save_response) {
        this.is_theme_complete = save_response.is_complete;
        this.theme = save_response.theme;
    };
    return SkaterSkatingEventSegment;
}());



/***/ }),

/***/ "./src/js/models/SkatingEvent.ts":
/*!***************************************!*\
  !*** ./src/js/models/SkatingEvent.ts ***!
  \***************************************/
/*! exports provided: CreditRule, CreditRules, SkatingEvent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CreditRule", function() { return CreditRule; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CreditRules", function() { return CreditRules; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SkatingEvent", function() { return SkatingEvent; });
var CreditRule = /** @class */ (function () {
    function CreditRule(key, cost, limit) {
        this.key = key;
        this.cost = cost ? cost : 0;
        this.limit = limit ? limit : 0;
        this.name = key.toUpperCase();
    }
    return CreditRule;
}());

var CreditRules = /** @class */ (function () {
    function CreditRules(opi, upi, wu) {
        this.opi = opi;
        this.upi = upi;
        this.wu = wu;
    }
    return CreditRules;
}());

var SkatingEvent = /** @class */ (function () {
    function SkatingEvent(id, name, competition_id, credit_rules, credit_packages) {
        /**
         * Credit rules that have a limit above 0
         */
        this._available_credit_types = [];
        this.credit_packages = [];
        this.id = id;
        this.name = name;
        this.competition_id = competition_id;
        this.credit_rules = credit_rules;
        if (credit_rules) {
            for (var i in credit_rules) {
                var credit_rule = credit_rules[i];
                if (credit_rule.limit > 0) {
                    this._available_credit_types.push(credit_rule);
                }
            }
        }
        if (credit_packages) {
            this.credit_packages = credit_packages;
        }
    }
    Object.defineProperty(SkatingEvent.prototype, "available_credit_types", {
        get: function () {
            return this._available_credit_types;
        },
        enumerable: true,
        configurable: true
    });
    SkatingEvent.prototype.getTypeLimit = function (type) {
        if (!this.credit_rules) {
            return 0;
        }
        return this.credit_rules[type].limit;
    };
    SkatingEvent.prototype.getTypeCost = function (type) {
        if (!this.credit_rules) {
            return 0;
        }
        return this.credit_rules[type].cost;
    };
    SkatingEvent.prototype.getCreditRules = function (limit_types) {
        if (!limit_types) {
            limit_types = ['opi', 'upi', 'wu'];
        }
        var result = [];
        if (this.credit_rules) {
            for (var type_key in this.credit_rules) {
                if (limit_types.indexOf(type_key) !== -1) {
                    result.push(this.credit_rules[type_key]);
                }
            }
        }
        return result;
    };
    /**
     * Get the event-configured session type limits
     */
    SkatingEvent.prototype.getCreditLimits = function () {
        var result = {
            opi: 0,
            upi: 0,
            wu: 0
        };
        for (var credit_type in result) {
            result[credit_type] = this.getTypeLimit(credit_type);
        }
        return result;
    };
    return SkatingEvent;
}());



/***/ }),

/***/ "./src/js/models/User.ts":
/*!*******************************!*\
  !*** ./src/js/models/User.ts ***!
  \*******************************/
/*! exports provided: User */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "User", function() { return User; });
var User = /** @class */ (function () {
    function User(params) {
        this._member_number = 123456;
        this._email = "test@test.com";
        this._roles = params.roles;
        this._upload_file_capability = params.upload_file_capability;
        this._email = params.email;
        this._member_number = params.member_number;
    }
    Object.defineProperty(User.prototype, "email", {
        get: function () {
            return this._email;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(User.prototype, "member_number", {
        get: function () {
            return this._member_number;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(User.prototype, "upload_file_capability", {
        get: function () {
            return this._upload_file_capability;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(User.prototype, "roles", {
        get: function () {
            return this._roles;
        },
        enumerable: true,
        configurable: true
    });
    User.blank = function () {
        return new User({
            roles: ["skater"],
            upload_file_capability: {
                can_upload: true,
                error_message: ''
            },
            member_number: -1,
            email: ""
        });
    };
    return User;
}());



/***/ }),

/***/ "./src/js/models/ValidationFunctions.ts":
/*!**********************************************!*\
  !*** ./src/js/models/ValidationFunctions.ts ***!
  \**********************************************/
/*! exports provided: validateRequired, validateMaxLength, validateMinLength, validateEmail, validateNullableEmail, validateUSAZipCode, validateCanadaPostalCode, validateDateFormatted, validateDateNotFuture, validateZipCode, validateCVC, validateCreditCardNumber, validateExpiration, validateInteger, validateMax, validateEqual, validateConfirmed */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "validateRequired", function() { return validateRequired; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "validateMaxLength", function() { return validateMaxLength; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "validateMinLength", function() { return validateMinLength; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "validateEmail", function() { return validateEmail; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "validateNullableEmail", function() { return validateNullableEmail; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "validateUSAZipCode", function() { return validateUSAZipCode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "validateCanadaPostalCode", function() { return validateCanadaPostalCode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "validateDateFormatted", function() { return validateDateFormatted; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "validateDateNotFuture", function() { return validateDateNotFuture; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "validateZipCode", function() { return validateZipCode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "validateCVC", function() { return validateCVC; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "validateCreditCardNumber", function() { return validateCreditCardNumber; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "validateExpiration", function() { return validateExpiration; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "validateInteger", function() { return validateInteger; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "validateMax", function() { return validateMax; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "validateEqual", function() { return validateEqual; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "validateConfirmed", function() { return validateConfirmed; });
/* harmony import */ var card_validator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! card-validator */ "./node_modules/card-validator/index.js");
/* harmony import */ var card_validator__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(card_validator__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _config_AppConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../config/AppConfig */ "./src/js/config/AppConfig.ts");


/**
 * VALIDATION HELPERS
 */
function validateRequired(field, invalidateZero) {
    if (field === undefined || field === null) {
        return false;
    }
    if (field === "0" && invalidateZero) {
        return false;
    }
    return !!String(field).trim().length;
}
function validateMaxLength(field, length) {
    if (field === undefined || field === null) {
        return false;
    }
    return !!(String(field).trim().length <= length);
}
function validateMinLength(field, length) {
    if (field === undefined || field === null) {
        return false;
    }
    return !!(String(field).trim().length >= length);
}
/**
 * Rudimentary email validation
 * Match [anything] @ [anything] . [anything]
 */
function validateEmail(field) {
    if (field === undefined || field === null) {
        return false;
    }
    return !!String(field).match(/.+@.+\..+/i);
}
/**
 * Validate an email's format if it exists.
 * falsy field values pass validation
 */
function validateNullableEmail(field) {
    if (field === undefined || field === null || field === "") {
        return true;
    }
    return validateEmail(field);
}
/**
 * Check that the value, if present, matches one of USA postal code formats (where X is numeric):
 *
 * XXXXX
 * XXXXX-XXXX
 */
function validateUSAZipCode(field) {
    // empty fields pass validation
    if (field === undefined || field === null) {
        return true;
    }
    var regex = new RegExp(/(^\d{5}$)|(^\d{5}-\d{4}$)/);
    return regex.test(field);
}
/**
 * Check that the value, if present, matches CAN postal code formats (where X is alpha-numeric):
 *
 * XXXXXX
 * XXX XXX
 */
function validateCanadaPostalCode(field) {
    // empty fields pass validation
    if (field === undefined || field === null) {
        return true;
    }
    var regex = new RegExp(/(^[A-Za-z0-9]{6}$)|(^[A-Za-z0-9]{3}\s[A-Za-z0-9]{3}$)/);
    return regex.test(field);
}
/**
 * Validate a date is formatted in MM/DD/YYYY format
 */
function validateDateFormatted(field) {
    if (field === undefined || field === null || field === '') {
        return true;
    }
    var regex_string = "[0-9]{2}\\" + _config_AppConfig__WEBPACK_IMPORTED_MODULE_1__["DATE_INPUT_GAP_SEPARATOR"] + "[0-9]{2}\\" + _config_AppConfig__WEBPACK_IMPORTED_MODULE_1__["DATE_INPUT_GAP_SEPARATOR"] + "[0-9]{4}";
    var regex = new RegExp(regex_string);
    if (!regex.test(field)) {
        return false;
    }
    var split = field.split(_config_AppConfig__WEBPACK_IMPORTED_MODULE_1__["DATE_INPUT_GAP_SEPARATOR"]);
    var month = parseInt(split[0]);
    var day = parseInt(split[1]);
    var month_max_config = {
        1: 31,
        2: 29,
        3: 31,
        4: 30,
        5: 31,
        6: 30,
        7: 31,
        8: 31,
        9: 30,
        10: 31,
        11: 30,
        12: 31,
    };
    if (month < 1 || month > 12) {
        return false;
    }
    if (day < 1) {
        return false;
    }
    if (month_max_config[month] < day) {
        return false;
    }
    return true;
}
/**
 * Validate a date is not in the future.  If date is not in the proper format, it will pass here
 */
function validateDateNotFuture(field) {
    if (field === undefined || field === null || !validateDateFormatted(field)) {
        return true;
    }
    var split = field.split(_config_AppConfig__WEBPACK_IMPORTED_MODULE_1__["DATE_INPUT_GAP_SEPARATOR"]);
    var month = parseInt(split[0]);
    var day = parseInt(split[1]);
    var year = parseInt(split[2]);
    var current_year = new Date().getFullYear();
    var current_month = new Date().getMonth() + 1;
    var current_day = new Date().getDate();
    if (year > current_year) {
        return false;
    }
    if (year == current_year && month > current_month) {
        return false;
    }
    return !(year == current_year && month == current_month && day > current_day);
}
/**
 * Validate a zip code
 * Check against a regexp for formatting, then min and max lengths
 * regexp: check for 1+ numerics, followed by optional spaces, dashes and numerics
 */
function validateZipCode(field) {
    if (field === undefined || field === null) {
        return false;
    }
    var zip_regexp = /^[0-9]+(?:[-\s]*)?(?:[0-9]*)?$/;
    if (zip_regexp.test(field) !== true) {
        return false;
    }
    return validateMinLength(field, 5) && validateMaxLength(field, 10);
}
/**
 * Verify the value is numeric and 3-4 characters long
 */
function validateCVC(field) {
    if (field === undefined || field === null) {
        return false;
    }
    var cvc_regexp = /^[0-9]{3,4}?$/;
    if (cvc_regexp.test(field) === true) {
        return true;
    }
    return false;
}
function validateCreditCardNumber(field) {
    if (field === undefined || field === null) {
        return false;
    }
    var validation_result = card_validator__WEBPACK_IMPORTED_MODULE_0__["number"](field);
    return validation_result.isValid;
}
function validateExpiration(expiration_month, expiration_year) {
    var current_year = new Date().getFullYear();
    if (expiration_year > current_year) {
        return true;
    }
    var current_month = new Date().getMonth() + 1;
    return current_month <= expiration_month;
}
/**
 * Validate a field value is a number.  Null field values pass
 *
 * Fail if input can't be parsed into an integer
 *
 * Fail if input contains characters other than number characters
 */
function validateInteger(field_value) {
    if (field_value === undefined || field_value === null || field_value === "") {
        return true;
    }
    if (isNaN(parseInt(field_value))) {
        return false;
    }
    var regex = new RegExp('^[0-9]+$');
    return regex.test(field_value);
}
/**
 * Validate that input number is less than a max.
 *
 * If the value is undefined or not capable of being parsed into an integer
 * pass validation
 */
function validateMax(field_value, max) {
    if (field_value === undefined || field_value === null) {
        return true;
    }
    var int = parseInt(field_value);
    if (isNaN(int)) {
        return true;
    }
    return int <= max;
}
/**
 * Ensure two fields are equal.  If corresponding value is absent, valid
 */
function validateEqual(field_value, corresponding_value) {
    if (corresponding_value === null || typeof corresponding_value === "undefined") {
        return true;
    }
    return field_value === corresponding_value;
}
/**
 * Verify a field has been confirmed
 */
function validateConfirmed(field) {
    if (field === undefined || field === null) {
        return false;
    }
    return field !== false;
}


/***/ }),

/***/ "./src/js/pages/CompetitionRegistration/CompetitionRegistrationCoachInformation.vue":
/*!******************************************************************************************!*\
  !*** ./src/js/pages/CompetitionRegistration/CompetitionRegistrationCoachInformation.vue ***!
  \******************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _CompetitionRegistrationCoachInformation_vue_vue_type_script_lang_ts___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CompetitionRegistrationCoachInformation.vue?vue&type=script&lang=ts& */ "./src/js/pages/CompetitionRegistration/CompetitionRegistrationCoachInformation.vue?vue&type=script&lang=ts&");
/* empty/unused harmony star reexport *//* harmony import */ var _node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js */ "./node_modules/vue-loader/lib/runtime/componentNormalizer.js");
var render, staticRenderFns




/* normalize component */

var component = Object(_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_1__["default"])(
  _CompetitionRegistrationCoachInformation_vue_vue_type_script_lang_ts___WEBPACK_IMPORTED_MODULE_0__["default"],
  render,
  staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var api; }
component.options.__file = "src/js/pages/CompetitionRegistration/CompetitionRegistrationCoachInformation.vue"
/* harmony default export */ __webpack_exports__["default"] = (component.exports);

/***/ }),

/***/ "./src/js/pages/CompetitionRegistration/CompetitionRegistrationCoachInformation.vue?vue&type=script&lang=ts&":
/*!*******************************************************************************************************************!*\
  !*** ./src/js/pages/CompetitionRegistration/CompetitionRegistrationCoachInformation.vue?vue&type=script&lang=ts& ***!
  \*******************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_ts_loader_index_js_ref_5_node_modules_vue_loader_lib_index_js_vue_loader_options_CompetitionRegistrationCoachInformation_vue_vue_type_script_lang_ts___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../node_modules/ts-loader??ref--5!../../../../node_modules/vue-loader/lib??vue-loader-options!./CompetitionRegistrationCoachInformation.vue?vue&type=script&lang=ts& */ "./node_modules/ts-loader/index.js?!./node_modules/vue-loader/lib/index.js?!./src/js/pages/CompetitionRegistration/CompetitionRegistrationCoachInformation.vue?vue&type=script&lang=ts&");
/* empty/unused harmony star reexport */ /* harmony default export */ __webpack_exports__["default"] = (_node_modules_ts_loader_index_js_ref_5_node_modules_vue_loader_lib_index_js_vue_loader_options_CompetitionRegistrationCoachInformation_vue_vue_type_script_lang_ts___WEBPACK_IMPORTED_MODULE_0__["default"]); 

/***/ }),

/***/ "./src/js/pages/CompetitionRegistration/CompetitionRegistrationEventSelection.vue":
/*!****************************************************************************************!*\
  !*** ./src/js/pages/CompetitionRegistration/CompetitionRegistrationEventSelection.vue ***!
  \****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _CompetitionRegistrationEventSelection_vue_vue_type_script_lang_ts___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CompetitionRegistrationEventSelection.vue?vue&type=script&lang=ts& */ "./src/js/pages/CompetitionRegistration/CompetitionRegistrationEventSelection.vue?vue&type=script&lang=ts&");
/* empty/unused harmony star reexport *//* harmony import */ var _node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js */ "./node_modules/vue-loader/lib/runtime/componentNormalizer.js");
var render, staticRenderFns




/* normalize component */

var component = Object(_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_1__["default"])(
  _CompetitionRegistrationEventSelection_vue_vue_type_script_lang_ts___WEBPACK_IMPORTED_MODULE_0__["default"],
  render,
  staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var api; }
component.options.__file = "src/js/pages/CompetitionRegistration/CompetitionRegistrationEventSelection.vue"
/* harmony default export */ __webpack_exports__["default"] = (component.exports);

/***/ }),

/***/ "./src/js/pages/CompetitionRegistration/CompetitionRegistrationEventSelection.vue?vue&type=script&lang=ts&":
/*!*****************************************************************************************************************!*\
  !*** ./src/js/pages/CompetitionRegistration/CompetitionRegistrationEventSelection.vue?vue&type=script&lang=ts& ***!
  \*****************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_ts_loader_index_js_ref_5_node_modules_vue_loader_lib_index_js_vue_loader_options_CompetitionRegistrationEventSelection_vue_vue_type_script_lang_ts___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../node_modules/ts-loader??ref--5!../../../../node_modules/vue-loader/lib??vue-loader-options!./CompetitionRegistrationEventSelection.vue?vue&type=script&lang=ts& */ "./node_modules/ts-loader/index.js?!./node_modules/vue-loader/lib/index.js?!./src/js/pages/CompetitionRegistration/CompetitionRegistrationEventSelection.vue?vue&type=script&lang=ts&");
/* empty/unused harmony star reexport */ /* harmony default export */ __webpack_exports__["default"] = (_node_modules_ts_loader_index_js_ref_5_node_modules_vue_loader_lib_index_js_vue_loader_options_CompetitionRegistrationEventSelection_vue_vue_type_script_lang_ts___WEBPACK_IMPORTED_MODULE_0__["default"]); 

/***/ }),

/***/ "./src/js/pages/CompetitionRegistration/CompetitionRegistrationIndex.vue":
/*!*******************************************************************************!*\
  !*** ./src/js/pages/CompetitionRegistration/CompetitionRegistrationIndex.vue ***!
  \*******************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _CompetitionRegistrationIndex_vue_vue_type_script_lang_ts___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CompetitionRegistrationIndex.vue?vue&type=script&lang=ts& */ "./src/js/pages/CompetitionRegistration/CompetitionRegistrationIndex.vue?vue&type=script&lang=ts&");
/* empty/unused harmony star reexport *//* harmony import */ var _node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js */ "./node_modules/vue-loader/lib/runtime/componentNormalizer.js");
var render, staticRenderFns




/* normalize component */

var component = Object(_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_1__["default"])(
  _CompetitionRegistrationIndex_vue_vue_type_script_lang_ts___WEBPACK_IMPORTED_MODULE_0__["default"],
  render,
  staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var api; }
component.options.__file = "src/js/pages/CompetitionRegistration/CompetitionRegistrationIndex.vue"
/* harmony default export */ __webpack_exports__["default"] = (component.exports);

/***/ }),

/***/ "./src/js/pages/CompetitionRegistration/CompetitionRegistrationIndex.vue?vue&type=script&lang=ts&":
/*!********************************************************************************************************!*\
  !*** ./src/js/pages/CompetitionRegistration/CompetitionRegistrationIndex.vue?vue&type=script&lang=ts& ***!
  \********************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_ts_loader_index_js_ref_5_node_modules_vue_loader_lib_index_js_vue_loader_options_CompetitionRegistrationIndex_vue_vue_type_script_lang_ts___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../node_modules/ts-loader??ref--5!../../../../node_modules/vue-loader/lib??vue-loader-options!./CompetitionRegistrationIndex.vue?vue&type=script&lang=ts& */ "./node_modules/ts-loader/index.js?!./node_modules/vue-loader/lib/index.js?!./src/js/pages/CompetitionRegistration/CompetitionRegistrationIndex.vue?vue&type=script&lang=ts&");
/* empty/unused harmony star reexport */ /* harmony default export */ __webpack_exports__["default"] = (_node_modules_ts_loader_index_js_ref_5_node_modules_vue_loader_lib_index_js_vue_loader_options_CompetitionRegistrationIndex_vue_vue_type_script_lang_ts___WEBPACK_IMPORTED_MODULE_0__["default"]); 

/***/ }),

/***/ "./src/js/pages/CompetitionRegistration/CompetitionRegistrationOverview.vue":
/*!**********************************************************************************!*\
  !*** ./src/js/pages/CompetitionRegistration/CompetitionRegistrationOverview.vue ***!
  \**********************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _CompetitionRegistrationOverview_vue_vue_type_script_lang_ts___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CompetitionRegistrationOverview.vue?vue&type=script&lang=ts& */ "./src/js/pages/CompetitionRegistration/CompetitionRegistrationOverview.vue?vue&type=script&lang=ts&");
/* empty/unused harmony star reexport *//* harmony import */ var _node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js */ "./node_modules/vue-loader/lib/runtime/componentNormalizer.js");
var render, staticRenderFns




/* normalize component */

var component = Object(_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_1__["default"])(
  _CompetitionRegistrationOverview_vue_vue_type_script_lang_ts___WEBPACK_IMPORTED_MODULE_0__["default"],
  render,
  staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var api; }
component.options.__file = "src/js/pages/CompetitionRegistration/CompetitionRegistrationOverview.vue"
/* harmony default export */ __webpack_exports__["default"] = (component.exports);

/***/ }),

/***/ "./src/js/pages/CompetitionRegistration/CompetitionRegistrationOverview.vue?vue&type=script&lang=ts&":
/*!***********************************************************************************************************!*\
  !*** ./src/js/pages/CompetitionRegistration/CompetitionRegistrationOverview.vue?vue&type=script&lang=ts& ***!
  \***********************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_ts_loader_index_js_ref_5_node_modules_vue_loader_lib_index_js_vue_loader_options_CompetitionRegistrationOverview_vue_vue_type_script_lang_ts___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../node_modules/ts-loader??ref--5!../../../../node_modules/vue-loader/lib??vue-loader-options!./CompetitionRegistrationOverview.vue?vue&type=script&lang=ts& */ "./node_modules/ts-loader/index.js?!./node_modules/vue-loader/lib/index.js?!./src/js/pages/CompetitionRegistration/CompetitionRegistrationOverview.vue?vue&type=script&lang=ts&");
/* empty/unused harmony star reexport */ /* harmony default export */ __webpack_exports__["default"] = (_node_modules_ts_loader_index_js_ref_5_node_modules_vue_loader_lib_index_js_vue_loader_options_CompetitionRegistrationOverview_vue_vue_type_script_lang_ts___WEBPACK_IMPORTED_MODULE_0__["default"]); 

/***/ }),

/***/ "./src/js/pages/CompetitionRegistration/CompetitionRegistrationPartnerEvents.vue":
/*!***************************************************************************************!*\
  !*** ./src/js/pages/CompetitionRegistration/CompetitionRegistrationPartnerEvents.vue ***!
  \***************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _CompetitionRegistrationPartnerEvents_vue_vue_type_script_lang_ts___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CompetitionRegistrationPartnerEvents.vue?vue&type=script&lang=ts& */ "./src/js/pages/CompetitionRegistration/CompetitionRegistrationPartnerEvents.vue?vue&type=script&lang=ts&");
/* empty/unused harmony star reexport *//* harmony import */ var _node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js */ "./node_modules/vue-loader/lib/runtime/componentNormalizer.js");
var render, staticRenderFns




/* normalize component */

var component = Object(_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_1__["default"])(
  _CompetitionRegistrationPartnerEvents_vue_vue_type_script_lang_ts___WEBPACK_IMPORTED_MODULE_0__["default"],
  render,
  staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var api; }
component.options.__file = "src/js/pages/CompetitionRegistration/CompetitionRegistrationPartnerEvents.vue"
/* harmony default export */ __webpack_exports__["default"] = (component.exports);

/***/ }),

/***/ "./src/js/pages/CompetitionRegistration/CompetitionRegistrationPartnerEvents.vue?vue&type=script&lang=ts&":
/*!****************************************************************************************************************!*\
  !*** ./src/js/pages/CompetitionRegistration/CompetitionRegistrationPartnerEvents.vue?vue&type=script&lang=ts& ***!
  \****************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_ts_loader_index_js_ref_5_node_modules_vue_loader_lib_index_js_vue_loader_options_CompetitionRegistrationPartnerEvents_vue_vue_type_script_lang_ts___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../node_modules/ts-loader??ref--5!../../../../node_modules/vue-loader/lib??vue-loader-options!./CompetitionRegistrationPartnerEvents.vue?vue&type=script&lang=ts& */ "./node_modules/ts-loader/index.js?!./node_modules/vue-loader/lib/index.js?!./src/js/pages/CompetitionRegistration/CompetitionRegistrationPartnerEvents.vue?vue&type=script&lang=ts&");
/* empty/unused harmony star reexport */ /* harmony default export */ __webpack_exports__["default"] = (_node_modules_ts_loader_index_js_ref_5_node_modules_vue_loader_lib_index_js_vue_loader_options_CompetitionRegistrationPartnerEvents_vue_vue_type_script_lang_ts___WEBPACK_IMPORTED_MODULE_0__["default"]); 

/***/ }),

/***/ "./src/js/pages/CompetitionRegistration/CompetitionRegistrationPartnerIdentification.vue":
/*!***********************************************************************************************!*\
  !*** ./src/js/pages/CompetitionRegistration/CompetitionRegistrationPartnerIdentification.vue ***!
  \***********************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _CompetitionRegistrationPartnerIdentification_vue_vue_type_script_lang_ts___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CompetitionRegistrationPartnerIdentification.vue?vue&type=script&lang=ts& */ "./src/js/pages/CompetitionRegistration/CompetitionRegistrationPartnerIdentification.vue?vue&type=script&lang=ts&");
/* empty/unused harmony star reexport *//* harmony import */ var _node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js */ "./node_modules/vue-loader/lib/runtime/componentNormalizer.js");
var render, staticRenderFns




/* normalize component */

var component = Object(_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_1__["default"])(
  _CompetitionRegistrationPartnerIdentification_vue_vue_type_script_lang_ts___WEBPACK_IMPORTED_MODULE_0__["default"],
  render,
  staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var api; }
component.options.__file = "src/js/pages/CompetitionRegistration/CompetitionRegistrationPartnerIdentification.vue"
/* harmony default export */ __webpack_exports__["default"] = (component.exports);

/***/ }),

/***/ "./src/js/pages/CompetitionRegistration/CompetitionRegistrationPartnerIdentification.vue?vue&type=script&lang=ts&":
/*!************************************************************************************************************************!*\
  !*** ./src/js/pages/CompetitionRegistration/CompetitionRegistrationPartnerIdentification.vue?vue&type=script&lang=ts& ***!
  \************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_ts_loader_index_js_ref_5_node_modules_vue_loader_lib_index_js_vue_loader_options_CompetitionRegistrationPartnerIdentification_vue_vue_type_script_lang_ts___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../node_modules/ts-loader??ref--5!../../../../node_modules/vue-loader/lib??vue-loader-options!./CompetitionRegistrationPartnerIdentification.vue?vue&type=script&lang=ts& */ "./node_modules/ts-loader/index.js?!./node_modules/vue-loader/lib/index.js?!./src/js/pages/CompetitionRegistration/CompetitionRegistrationPartnerIdentification.vue?vue&type=script&lang=ts&");
/* empty/unused harmony star reexport */ /* harmony default export */ __webpack_exports__["default"] = (_node_modules_ts_loader_index_js_ref_5_node_modules_vue_loader_lib_index_js_vue_loader_options_CompetitionRegistrationPartnerIdentification_vue_vue_type_script_lang_ts___WEBPACK_IMPORTED_MODULE_0__["default"]); 

/***/ }),

/***/ "./src/js/pages/CompetitionRegistration/CompetitionRegistrationSkateTests.vue":
/*!************************************************************************************!*\
  !*** ./src/js/pages/CompetitionRegistration/CompetitionRegistrationSkateTests.vue ***!
  \************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _CompetitionRegistrationSkateTests_vue_vue_type_script_lang_ts___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CompetitionRegistrationSkateTests.vue?vue&type=script&lang=ts& */ "./src/js/pages/CompetitionRegistration/CompetitionRegistrationSkateTests.vue?vue&type=script&lang=ts&");
/* empty/unused harmony star reexport *//* harmony import */ var _node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js */ "./node_modules/vue-loader/lib/runtime/componentNormalizer.js");
var render, staticRenderFns




/* normalize component */

var component = Object(_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_1__["default"])(
  _CompetitionRegistrationSkateTests_vue_vue_type_script_lang_ts___WEBPACK_IMPORTED_MODULE_0__["default"],
  render,
  staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var api; }
component.options.__file = "src/js/pages/CompetitionRegistration/CompetitionRegistrationSkateTests.vue"
/* harmony default export */ __webpack_exports__["default"] = (component.exports);

/***/ }),

/***/ "./src/js/pages/CompetitionRegistration/CompetitionRegistrationSkateTests.vue?vue&type=script&lang=ts&":
/*!*************************************************************************************************************!*\
  !*** ./src/js/pages/CompetitionRegistration/CompetitionRegistrationSkateTests.vue?vue&type=script&lang=ts& ***!
  \*************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_ts_loader_index_js_ref_5_node_modules_vue_loader_lib_index_js_vue_loader_options_CompetitionRegistrationSkateTests_vue_vue_type_script_lang_ts___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../node_modules/ts-loader??ref--5!../../../../node_modules/vue-loader/lib??vue-loader-options!./CompetitionRegistrationSkateTests.vue?vue&type=script&lang=ts& */ "./node_modules/ts-loader/index.js?!./node_modules/vue-loader/lib/index.js?!./src/js/pages/CompetitionRegistration/CompetitionRegistrationSkateTests.vue?vue&type=script&lang=ts&");
/* empty/unused harmony star reexport */ /* harmony default export */ __webpack_exports__["default"] = (_node_modules_ts_loader_index_js_ref_5_node_modules_vue_loader_lib_index_js_vue_loader_options_CompetitionRegistrationSkateTests_vue_vue_type_script_lang_ts___WEBPACK_IMPORTED_MODULE_0__["default"]); 

/***/ }),

/***/ "./src/js/pages/CompetitionRegistration/CompetitionRegistrationSkaterProfile.vue":
/*!***************************************************************************************!*\
  !*** ./src/js/pages/CompetitionRegistration/CompetitionRegistrationSkaterProfile.vue ***!
  \***************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _CompetitionRegistrationSkaterProfile_vue_vue_type_script_lang_ts___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CompetitionRegistrationSkaterProfile.vue?vue&type=script&lang=ts& */ "./src/js/pages/CompetitionRegistration/CompetitionRegistrationSkaterProfile.vue?vue&type=script&lang=ts&");
/* empty/unused harmony star reexport *//* harmony import */ var _node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js */ "./node_modules/vue-loader/lib/runtime/componentNormalizer.js");
var render, staticRenderFns




/* normalize component */

var component = Object(_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_1__["default"])(
  _CompetitionRegistrationSkaterProfile_vue_vue_type_script_lang_ts___WEBPACK_IMPORTED_MODULE_0__["default"],
  render,
  staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var api; }
component.options.__file = "src/js/pages/CompetitionRegistration/CompetitionRegistrationSkaterProfile.vue"
/* harmony default export */ __webpack_exports__["default"] = (component.exports);

/***/ }),

/***/ "./src/js/pages/CompetitionRegistration/CompetitionRegistrationSkaterProfile.vue?vue&type=script&lang=ts&":
/*!****************************************************************************************************************!*\
  !*** ./src/js/pages/CompetitionRegistration/CompetitionRegistrationSkaterProfile.vue?vue&type=script&lang=ts& ***!
  \****************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_ts_loader_index_js_ref_5_node_modules_vue_loader_lib_index_js_vue_loader_options_CompetitionRegistrationSkaterProfile_vue_vue_type_script_lang_ts___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../node_modules/ts-loader??ref--5!../../../../node_modules/vue-loader/lib??vue-loader-options!./CompetitionRegistrationSkaterProfile.vue?vue&type=script&lang=ts& */ "./node_modules/ts-loader/index.js?!./node_modules/vue-loader/lib/index.js?!./src/js/pages/CompetitionRegistration/CompetitionRegistrationSkaterProfile.vue?vue&type=script&lang=ts&");
/* empty/unused harmony star reexport */ /* harmony default export */ __webpack_exports__["default"] = (_node_modules_ts_loader_index_js_ref_5_node_modules_vue_loader_lib_index_js_vue_loader_options_CompetitionRegistrationSkaterProfile_vue_vue_type_script_lang_ts___WEBPACK_IMPORTED_MODULE_0__["default"]); 

/***/ }),

/***/ "./src/js/pages/CompetitionRegistration/CompetitionRegistrationWaivers.vue":
/*!*********************************************************************************!*\
  !*** ./src/js/pages/CompetitionRegistration/CompetitionRegistrationWaivers.vue ***!
  \*********************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _CompetitionRegistrationWaivers_vue_vue_type_script_lang_ts___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CompetitionRegistrationWaivers.vue?vue&type=script&lang=ts& */ "./src/js/pages/CompetitionRegistration/CompetitionRegistrationWaivers.vue?vue&type=script&lang=ts&");
/* empty/unused harmony star reexport *//* harmony import */ var _node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js */ "./node_modules/vue-loader/lib/runtime/componentNormalizer.js");
var render, staticRenderFns




/* normalize component */

var component = Object(_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_1__["default"])(
  _CompetitionRegistrationWaivers_vue_vue_type_script_lang_ts___WEBPACK_IMPORTED_MODULE_0__["default"],
  render,
  staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var api; }
component.options.__file = "src/js/pages/CompetitionRegistration/CompetitionRegistrationWaivers.vue"
/* harmony default export */ __webpack_exports__["default"] = (component.exports);

/***/ }),

/***/ "./src/js/pages/CompetitionRegistration/CompetitionRegistrationWaivers.vue?vue&type=script&lang=ts&":
/*!**********************************************************************************************************!*\
  !*** ./src/js/pages/CompetitionRegistration/CompetitionRegistrationWaivers.vue?vue&type=script&lang=ts& ***!
  \**********************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_ts_loader_index_js_ref_5_node_modules_vue_loader_lib_index_js_vue_loader_options_CompetitionRegistrationWaivers_vue_vue_type_script_lang_ts___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../node_modules/ts-loader??ref--5!../../../../node_modules/vue-loader/lib??vue-loader-options!./CompetitionRegistrationWaivers.vue?vue&type=script&lang=ts& */ "./node_modules/ts-loader/index.js?!./node_modules/vue-loader/lib/index.js?!./src/js/pages/CompetitionRegistration/CompetitionRegistrationWaivers.vue?vue&type=script&lang=ts&");
/* empty/unused harmony star reexport */ /* harmony default export */ __webpack_exports__["default"] = (_node_modules_ts_loader_index_js_ref_5_node_modules_vue_loader_lib_index_js_vue_loader_options_CompetitionRegistrationWaivers_vue_vue_type_script_lang_ts___WEBPACK_IMPORTED_MODULE_0__["default"]); 

/***/ }),

/***/ "./src/js/pages/SearchCompetitions/SearchCompetitionsTransformer.ts":
/*!**************************************************************************!*\
  !*** ./src/js/pages/SearchCompetitions/SearchCompetitionsTransformer.ts ***!
  \**************************************************************************/
/*! exports provided: SearchCompetitionsTransformer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SearchCompetitionsTransformer", function() { return SearchCompetitionsTransformer; });
/* harmony import */ var _helpers_time__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../helpers/time */ "./src/js/helpers/time.ts");
/* eslint-disable new-cap, jsdoc/require-jsdoc */

var SearchCompetitionsTransformer = /** @class */ (function () {
    function SearchCompetitionsTransformer() {
    }
    SearchCompetitionsTransformer.transformFetchSearchCompetitionList = function (data) {
        return data.competitions.map(function (competition_data) {
            var converted_end_date = competition_data.end_date_ts * 1000;
            var converted_start_date = competition_data.start_date_ts * 1000;
            var core = {
                city: competition_data.city,
                club: competition_data.club,
                end_date: Object(_helpers_time__WEBPACK_IMPORTED_MODULE_0__["UTCDateFormatNoYear"])(new Date(converted_end_date)),
                end_date_ts: converted_end_date,
                has_registration_deadline_warning: competition_data.has_registration_deadline_warning,
                icon: competition_data.icon,
                id: competition_data.id,
                name: competition_data.name,
                series: competition_data.series,
                start_date: Object(_helpers_time__WEBPACK_IMPORTED_MODULE_0__["UTCDateFormatNoYear"])(new Date(converted_start_date)),
                start_date_ts: converted_start_date,
                state: competition_data.state,
                user_registration_status: competition_data.user_registration_status,
                view_competition_link: competition_data.view_competition_link
            };
            if (competition_data.registration_deadline) {
                core.registration_deadline = competition_data.registration_deadline;
            }
            return core;
        });
    };
    return SearchCompetitionsTransformer;
}());



/***/ }),

/***/ "./src/js/pages/ViewCompetition/ViewCompetitionCompetition.ts":
/*!********************************************************************!*\
  !*** ./src/js/pages/ViewCompetition/ViewCompetitionCompetition.ts ***!
  \********************************************************************/
/*! exports provided: ViewCompetitionCompetition */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ViewCompetitionCompetition", function() { return ViewCompetitionCompetition; });
var ViewCompetitionCompetition = /** @class */ (function () {
    /**
     * Create new ViewCompetitionCompetition instance
     */
    function ViewCompetitionCompetition(parameters) {
        var announcement_url = parameters.announcement_url, directions = parameters.directions, end_date_pretty = parameters.end_date_pretty, icon = parameters.icon, id = parameters.id, is_ems = parameters.is_ems, name = parameters.name, registration_cta_configuration = parameters.registration_cta_configuration, start_date_pretty = parameters.start_date_pretty, user_navigation = parameters.user_navigation, website_url = parameters.website_url, volunteer_cta_configuration = parameters.volunteer_cta_configuration, team_registration_cta_configuration = parameters.team_registration_cta_configuration, links = parameters.links;
        this.announcement_url = announcement_url;
        this.directions = directions;
        this.end_date_pretty = end_date_pretty;
        this.icon = icon;
        this.id = id;
        this.is_ems = is_ems;
        this.name = name;
        this.start_date_pretty = start_date_pretty;
        this.user_navigation = user_navigation;
        this.website_url = website_url;
        if (registration_cta_configuration) {
            this.registration_cta_configuration = registration_cta_configuration;
        }
        if (volunteer_cta_configuration) {
            this.volunteer_cta_configuration = volunteer_cta_configuration;
        }
        if (team_registration_cta_configuration) {
            this.team_registration_cta_configuration = team_registration_cta_configuration;
        }
        this.links = links;
    }
    return ViewCompetitionCompetition;
}());



/***/ }),

/***/ "./src/js/pages/ViewCompetition/ViewCompetitionTransformer.ts":
/*!********************************************************************!*\
  !*** ./src/js/pages/ViewCompetition/ViewCompetitionTransformer.ts ***!
  \********************************************************************/
/*! exports provided: ViewCompetitionTransformer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ViewCompetitionTransformer", function() { return ViewCompetitionTransformer; });
/* harmony import */ var _ViewCompetitionCompetition__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ViewCompetitionCompetition */ "./src/js/pages/ViewCompetition/ViewCompetitionCompetition.ts");
/* harmony import */ var _CompetitionPortal_transformers_DataNavigationLinkTransformer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../CompetitionPortal/_transformers/DataNavigationLinkTransformer */ "./src/js/CompetitionPortal/_transformers/DataNavigationLinkTransformer.ts");
var __assign = (undefined && undefined.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
/* eslint-disable jsdoc/require-jsdoc */


var ViewCompetitionTransformer = /** @class */ (function () {
    function ViewCompetitionTransformer() {
    }
    ViewCompetitionTransformer.transformFetchViewCompetitionCompetition = function (response_data) {
        var parameters = {
            announcement_url: response_data.announcement_url || null,
            directions: response_data.directions || [],
            website_url: response_data.website_url || null,
            end_date_pretty: response_data.end_date_pretty,
            icon: response_data.icon,
            id: response_data.id,
            is_ems: response_data.is_ems,
            name: response_data.name,
            start_date_pretty: response_data.start_date_pretty,
            user_navigation: response_data.user_navigation.map(function (data) {
                return _CompetitionPortal_transformers_DataNavigationLinkTransformer__WEBPACK_IMPORTED_MODULE_1__["DataNavigationLinkTransformer"].transformDataNavigationLink(data);
            }),
            links: __assign({}, response_data.links)
        };
        if (response_data.registration_cta_configuration) {
            parameters.registration_cta_configuration = response_data.registration_cta_configuration;
        }
        if (response_data.volunteer_cta_configuration) {
            parameters.volunteer_cta_configuration = response_data.volunteer_cta_configuration;
        }
        if (response_data.team_registration_cta_configuration) {
            parameters.team_registration_cta_configuration = response_data.team_registration_cta_configuration;
        }
        return new _ViewCompetitionCompetition__WEBPACK_IMPORTED_MODULE_0__["ViewCompetitionCompetition"](parameters);
    };
    return ViewCompetitionTransformer;
}());



/***/ }),

/***/ "./src/js/services/AbstractAPIService.ts":
/*!***********************************************!*\
  !*** ./src/js/services/AbstractAPIService.ts ***!
  \***********************************************/
/*! exports provided: AbstractAPIService */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AbstractAPIService", function() { return AbstractAPIService; });
/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! axios */ "./node_modules/axios/index.js");
/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(axios__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _adaptors_MemberSearchAdaptor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../adaptors/MemberSearchAdaptor */ "./src/js/adaptors/MemberSearchAdaptor.ts");


var AbstractAPIService = /** @class */ (function () {
    function AbstractAPIService() {
    }
    /**
     * Fetch information from the API and transform the response
     */
    AbstractAPIService.fetchAndTransformResponse = function (parameters) {
        var url = parameters.url, validateResponse = parameters.validateResponse, transformResponse = parameters.transformResponse;
        return new Promise(function (resolve, reject) {
            axios__WEBPACK_IMPORTED_MODULE_0___default.a.get(url)
                .then(function (response) {
                if (typeof validateResponse === 'undefined' || validateResponse(response.data)) {
                    resolve(transformResponse(response.data));
                    return;
                }
                reject();
            })
                .catch(function () {
                reject();
            });
        });
    };
    /**
     * Submit an API request and handle the expected APISubmissionResponse response
     */
    AbstractAPIService.submitForAPISubmissionResponse = function (parameters) {
        var url = parameters.url, payload = parameters.payload;
        var error_message = parameters.error_message;
        var method = parameters.method || 'post';
        return new Promise(function (resolve, reject) {
            axios__WEBPACK_IMPORTED_MODULE_0___default.a.request({
                data: payload,
                url: url,
                method: method
            })
                .then(function (response) {
                if (response.data && response.data.success) {
                    resolve();
                    return;
                }
                if (response.data.error) {
                    error_message = response.data.error;
                }
                reject(error_message);
            })
                .catch(function () {
                reject(error_message);
            });
        });
    };
    /**
     * Submit a member search
     */
    AbstractAPIService.submitMemberSearch = function (parameters) {
        var error_message = parameters.error_message || 'Search error. Please try again';
        var payload = parameters.payload, url = parameters.url;
        var transform = parameters.transformPayload || (function (data) {
            return _adaptors_MemberSearchAdaptor__WEBPACK_IMPORTED_MODULE_1__["MemberSearchAdaptor"].adaptMemberSearchParametersToMemberSearchAPIParameters(data);
        });
        var api_payload = transform(payload);
        var validateResponse = parameters.validateResponse || (function (response_data) {
            return !!response_data && !!response_data.results;
        });
        var transformResponse = parameters.transformResponse || (function (response_data) {
            return _adaptors_MemberSearchAdaptor__WEBPACK_IMPORTED_MODULE_1__["MemberSearchAdaptor"].adaptResultArray(response_data.results);
        });
        return new Promise(function (resolve, reject) {
            axios__WEBPACK_IMPORTED_MODULE_0___default.a.post(url, api_payload)
                .then(function (response) {
                if (validateResponse(response.data)) {
                    resolve(transformResponse(response.data));
                    return;
                }
                reject(error_message);
            })
                .catch(function () {
                reject(error_message);
            });
        });
    };
    /**
     * Submit an API request with an expected response payload. Validate then transform the response payload
     *
     * R represents the API response
     * O represents the transformed outcome
     */
    AbstractAPIService.submitWithTransformedResponse = function (parameters) {
        var url = parameters.url, payload = parameters.payload, transformResponse = parameters.transformResponse;
        var method = parameters.method || 'post';
        var validateResponse = parameters.validateResponse || (function (response_data) {
            return !!response_data && !!response_data.success;
        });
        var error_message = parameters.error_message;
        return new Promise(function (resolve, reject) {
            axios__WEBPACK_IMPORTED_MODULE_0___default.a.request({
                data: payload,
                url: url,
                method: method
            })
                .then(function (response) {
                if (validateResponse(response.data)) {
                    resolve(transformResponse(response.data));
                    return;
                }
                if (response.data.error) {
                    error_message = response.data.error;
                }
                reject(error_message);
            })
                .catch(function () {
                reject(error_message);
            });
        });
    };
    /**
     * Get a value from a cookie using the cookie name
     */
    AbstractAPIService.getValueFromCookie = function (cookie_name, cookie_descriptor, suppress_warnings) {
        if (cookie_descriptor === void 0) { cookie_descriptor = ''; }
        var cookie_value = '';
        if (cookie_name) {
            var pattern = "(?:(?:^|.*;\\s*)" + cookie_name + "\\s*\\=\\s*([^;]*).*$)|^.*$";
            var cookieValue = document.cookie.replace(new RegExp(pattern), '$1');
            cookie_value = cookieValue.trim();
            if (cookie_value !== '') {
                return cookie_value;
            }
        }
        if (!suppress_warnings) {
            console.warn("Unable to retrieve " + cookie_descriptor + " cookie value");
        }
        throw "Unable to retrieve " + cookie_descriptor + " cookie value";
    };
    return AbstractAPIService;
}());



/***/ }),

/***/ "./src/js/services/AppService.ts":
/*!***************************************!*\
  !*** ./src/js/services/AppService.ts ***!
  \***************************************/
/*! exports provided: AppService */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AppService", function() { return AppService; });
/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! axios */ "./node_modules/axios/index.js");
/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(axios__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _adaptors_PPCDataAdaptor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../adaptors/PPCDataAdaptor */ "./src/js/adaptors/PPCDataAdaptor.ts");
/* harmony import */ var _adaptors_MusicDataAdaptor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../adaptors/MusicDataAdaptor */ "./src/js/adaptors/MusicDataAdaptor.ts");
/* harmony import */ var _adaptors_PracticeIceSchedulesDataAdaptor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../adaptors/PracticeIceSchedulesDataAdaptor */ "./src/js/adaptors/PracticeIceSchedulesDataAdaptor.ts");
/* harmony import */ var _adaptors_APIAdaptors_AppAPIAdaptor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../adaptors/APIAdaptors/AppAPIAdaptor */ "./src/js/adaptors/APIAdaptors/AppAPIAdaptor.ts");
/* harmony import */ var _CompetitionPortal_services__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../CompetitionPortal/_services */ "./src/js/CompetitionPortal/_services/index.ts");






var AppService = /** @class */ (function () {
    function AppService() {
    }
    /**
     * Fetch the PPC form options
     */
    AppService.getPPCFormOptions = function (fetch_params) {
        return new Promise(function (resolve, reject) {
            axios__WEBPACK_IMPORTED_MODULE_0___default.a.post(_CompetitionPortal_services__WEBPACK_IMPORTED_MODULE_5__["CompetitionPortalApiService"].transformMusicPpcUrl('ppc-element-options'), fetch_params).then(function (response) {
                try {
                    var adapted = _adaptors_PPCDataAdaptor__WEBPACK_IMPORTED_MODULE_1__["PPCDataAdaptor"].adapt_PPCOptionsData_To_PPCFormOptions(response.data);
                    resolve(adapted);
                }
                catch (e) {
                    reject();
                }
            }).catch(function () {
                reject();
            });
        });
    };
    /**
     * Upload a file.
     *
     * Run progress_function on upload progress
     *
     * Resolve on success
     * Reject with error message on failure
     */
    AppService.uploadMusicFile = function (file, progress_function, cancel_token) {
        return new Promise(function (resolve) {
            var formData = new FormData();
            formData.append('file', file);
            axios__WEBPACK_IMPORTED_MODULE_0___default.a.request({
                method: "post",
                url: '/api/upload-music',
                data: formData,
                cancelToken: cancel_token,
                onUploadProgress: function (progressEvent) {
                    progress_function(progressEvent);
                },
            }).then(function (response) {
                resolve(_adaptors_MusicDataAdaptor__WEBPACK_IMPORTED_MODULE_2__["MusicDataAdaptor"].adaptMusicFileUploadResponse(response.data));
            }).catch(function () {
                var response_params = {
                    success: false,
                    error: true,
                    message: "Error uploading file."
                };
                resolve(response_params);
            });
        });
    };
    /**
     * Delete a file uploaded for a music item
     */
    AppService.deleteUploadedMusicFile = function (file_id) {
        return new Promise(function (resolve, reject) {
            axios__WEBPACK_IMPORTED_MODULE_0___default.a.post('/api/delete-uploaded-music-file', {
                music_file_id: file_id
            }).then(function () {
                resolve();
            }).catch(function () {
                reject();
            });
        });
    };
    /**
     * Delete a music item from the library
     */
    AppService.deleteMusicFromLibrary = function (song) {
        return new Promise(function (resolve, reject) {
            axios__WEBPACK_IMPORTED_MODULE_0___default.a.post('/api/music-library/remove', {
                music_item_id: song.id
            }).then(function (response) {
                if (response.data.success) {
                    resolve();
                    return;
                }
                reject();
            }).catch(function () {
                reject();
            });
        });
    };
    /**
     * Fetch dynamic input options for EMS Support Form
     */
    AppService.fetchEMSSupportFormOptions = function () {
        return new Promise(function (resolve, reject) {
            axios__WEBPACK_IMPORTED_MODULE_0___default.a.get('/api/ems-support/issue-types').then(function (response) {
                if (response.data.issue_types) {
                    resolve(response.data.issue_types);
                    return;
                }
                reject();
            }).catch(function () {
                reject();
            });
        });
    };
    /**
     * Submit the EMS Support Form
     */
    AppService.submitEMSSupport = function (form_data) {
        return new Promise(function (resolve, reject) {
            axios__WEBPACK_IMPORTED_MODULE_0___default.a.post('/api/ems-support/submit', form_data).then(function (response) {
                var result = response.data.success ? response.data.success : false;
                var error = "";
                if (!result) {
                    error = response.data.error ? response.data.error : "Error submitting form.";
                }
                resolve({
                    success: result,
                    error: error
                });
            }).catch(function () {
                reject();
            });
        });
    };
    /**
     * Get PracticeIceSchedulesStateArgs for a given competition
     *
     * This is composed of all the parsed data structures for Skater and Competition Schedules for Practice Ice
     */
    AppService.getPracticeIceSchedules = function (competition_id) {
        return new Promise(function (resolve, reject) {
            axios__WEBPACK_IMPORTED_MODULE_0___default.a.get('/api/competitions/' + competition_id + "/practice-ice-schedules").then(function (response) {
                var adapted_result = _adaptors_PracticeIceSchedulesDataAdaptor__WEBPACK_IMPORTED_MODULE_3__["PracticeIceSchedulesDataAdaptor"].adapt(response.data);
                resolve(adapted_result);
            }).catch(function () {
                reject();
            });
        });
    };
    /**
     * Fetch categorized support documents for Support Documents (Help & Resources) page
     */
    AppService.fetchCategorizedSupportDocuments = function () {
        return new Promise(function (resolve, reject) {
            axios__WEBPACK_IMPORTED_MODULE_0___default.a.get('/api/support-documents').then(function (response) {
                if (response.data && response.data.categorized_support_documents) {
                    resolve(_adaptors_APIAdaptors_AppAPIAdaptor__WEBPACK_IMPORTED_MODULE_4__["AppAPIAdaptor"].adaptSupportDocumentCategoryDataArrayToSupportDocumentCategoryArray(response.data.categorized_support_documents));
                }
                reject();
            }).catch(function () {
                reject();
            });
        });
    };
    return AppService;
}());



/***/ }),

/***/ "./src/js/services/CartService.ts":
/*!****************************************!*\
  !*** ./src/js/services/CartService.ts ***!
  \****************************************/
/*! exports provided: CartService */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CartService", function() { return CartService; });
/* harmony import */ var _adaptors_CartDataAdaptor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../adaptors/CartDataAdaptor */ "./src/js/adaptors/CartDataAdaptor.ts");
/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! axios */ "./node_modules/axios/index.js");
/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(axios__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _adaptors_APIAdaptors_CartAPIAdaptor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../adaptors/APIAdaptors/CartAPIAdaptor */ "./src/js/adaptors/APIAdaptors/CartAPIAdaptor.ts");
/* harmony import */ var _CompetitionPortal_services__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../CompetitionPortal/_services */ "./src/js/CompetitionPortal/_services/index.ts");




var CartService = /** @class */ (function () {
    function CartService() {
    }
    /**
     * Remove a session from the cart
     */
    CartService.removeSession = function (session) {
        return new Promise(function (resolve, reject) {
            axios__WEBPACK_IMPORTED_MODULE_1___default.a.post('/api/skater-cart/remove-session', _adaptors_APIAdaptors_CartAPIAdaptor__WEBPACK_IMPORTED_MODULE_2__["CartAPIAdaptor"].adaptRemoveSession(session)).then(function (response) {
                if (response.data.success == true && response.data.cart) {
                    resolve(_adaptors_CartDataAdaptor__WEBPACK_IMPORTED_MODULE_0__["CartDataAdaptor"].adaptCostProperties(response.data.cart));
                }
                reject();
            }).catch(function () {
                reject();
            });
        });
    };
    /**
     * Retrieve and adapt the skater's cart data
     */
    CartService.fetchCart = function () {
        return new Promise(function (resolve, reject) {
            axios__WEBPACK_IMPORTED_MODULE_1___default.a.get('/api/skater-cart').then(function (response) {
                if (response.data) {
                    resolve(_adaptors_CartDataAdaptor__WEBPACK_IMPORTED_MODULE_0__["CartDataAdaptor"].adapt(response.data));
                }
                reject();
            }).catch(function () {
                reject();
            });
        });
    };
    /**
     * Add a session to the skater's cart
     */
    CartService.addSession = function (scheduled_session, cost) {
        return new Promise(function (resolve, reject) {
            axios__WEBPACK_IMPORTED_MODULE_1___default.a.post('/api/skater-cart/add-session', _adaptors_APIAdaptors_CartAPIAdaptor__WEBPACK_IMPORTED_MODULE_2__["CartAPIAdaptor"].adaptAddSession(scheduled_session, cost)).then(function (response) {
                if (response.data.success) {
                    resolve();
                }
                reject();
            }).catch(function () {
                reject();
            });
        });
    };
    /**
     * [2020-07-14] - Add credits to team cart
     */
    CartService.addTeamCredits = function (credit_payload) {
        var team_id = _CompetitionPortal_services__WEBPACK_IMPORTED_MODULE_3__["CompetitionPortalAppService"].getActiveCompetitionPortalTeamId();
        return new Promise(function (resolve, reject) {
            axios__WEBPACK_IMPORTED_MODULE_1___default.a.post("/api/cart/teams/" + team_id + "/credits", {
                credits: _adaptors_APIAdaptors_CartAPIAdaptor__WEBPACK_IMPORTED_MODULE_2__["CartAPIAdaptor"].adaptAddCredits(credit_payload.credits),
                packages: _adaptors_APIAdaptors_CartAPIAdaptor__WEBPACK_IMPORTED_MODULE_2__["CartAPIAdaptor"].adaptAddPackages(credit_payload.packages)
            }).then(function (response) {
                if (response.data.success) {
                    resolve();
                }
                reject();
            }).catch(function () {
                reject();
            });
        });
    };
    /**
     * Add a set of credits to the cart
     */
    CartService.addCredits = function (credit_payload) {
        return new Promise(function (resolve, reject) {
            axios__WEBPACK_IMPORTED_MODULE_1___default.a.post('/api/skater-cart/add-credits', {
                credits: _adaptors_APIAdaptors_CartAPIAdaptor__WEBPACK_IMPORTED_MODULE_2__["CartAPIAdaptor"].adaptAddCredits(credit_payload.credits),
                packages: _adaptors_APIAdaptors_CartAPIAdaptor__WEBPACK_IMPORTED_MODULE_2__["CartAPIAdaptor"].adaptAddPackages(credit_payload.packages)
            }).then(function (response) {
                if (response.data.success) {
                    resolve();
                }
                reject();
            }).catch(function () {
                reject();
            });
        });
    };
    /**
     * Remove a credit from the cart
     */
    CartService.removeCredit = function (credit) {
        return new Promise(function (resolve, reject) {
            axios__WEBPACK_IMPORTED_MODULE_1___default.a.post('/api/skater-cart/remove-credits', _adaptors_APIAdaptors_CartAPIAdaptor__WEBPACK_IMPORTED_MODULE_2__["CartAPIAdaptor"].adaptRemoveCredit(credit)).then(function (response) {
                if (response.data.success == true && response.data.cart) {
                    resolve(_adaptors_CartDataAdaptor__WEBPACK_IMPORTED_MODULE_0__["CartDataAdaptor"].adaptCostProperties(response.data.cart));
                }
                reject();
            }).catch(function () {
                reject();
            });
        });
    };
    /**
     * Post data to server to complete checkout process
     *
     * checkout_data - Object containing BillingAddress, CreditCard and Cart objects
     */
    CartService.completeOrder = function (checkout_data) {
        return new Promise(function (resolve, reject) {
            axios__WEBPACK_IMPORTED_MODULE_1___default.a.post('/api/complete-order', _adaptors_APIAdaptors_CartAPIAdaptor__WEBPACK_IMPORTED_MODULE_2__["CartAPIAdaptor"].adaptCompleteOrder(checkout_data)).then(function (response) {
                if (response.data.success === true) {
                    resolve({
                        success: true,
                        message: "Order Complete",
                        invoice_id: response.data.invoice_id
                    });
                    return;
                }
                resolve({
                    success: false,
                    message: response.data.message
                });
            }).catch(function () {
                reject();
            });
        });
    };
    /**
     * Remove a credit package from the cart.
     */
    CartService.removeCreditPackage = function (credit_package) {
        return new Promise(function (resolve, reject) {
            axios__WEBPACK_IMPORTED_MODULE_1___default.a.post('/api/skater-cart/remove-credit-package', _adaptors_APIAdaptors_CartAPIAdaptor__WEBPACK_IMPORTED_MODULE_2__["CartAPIAdaptor"].adaptRemoveCreditPackage(credit_package)).then(function (response) {
                if (response.data.success == true && response.data.cart) {
                    resolve(_adaptors_CartDataAdaptor__WEBPACK_IMPORTED_MODULE_0__["CartDataAdaptor"].adaptCostProperties(response.data.cart));
                }
                reject();
            }).catch(function () {
                reject();
            });
        });
    };
    CartService.removeRegistrationItem = function (item) {
        return new Promise(function (resolve, reject) {
            axios__WEBPACK_IMPORTED_MODULE_1___default.a.post('/api/skater-cart/remove-registration', _adaptors_APIAdaptors_CartAPIAdaptor__WEBPACK_IMPORTED_MODULE_2__["CartAPIAdaptor"].adaptRemoveRegistrationItem(item)).then(function (response) {
                if (response.data.success && response.data.cart) {
                    resolve(_adaptors_CartDataAdaptor__WEBPACK_IMPORTED_MODULE_0__["CartDataAdaptor"].adapt(response.data.cart));
                }
                reject();
            }).catch(function () {
                reject();
            });
        });
    };
    return CartService;
}());



/***/ }),

/***/ "./src/js/services/CoachService.ts":
/*!*****************************************!*\
  !*** ./src/js/services/CoachService.ts ***!
  \*****************************************/
/*! exports provided: CoachService */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CoachService", function() { return CoachService; });
/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! axios */ "./node_modules/axios/index.js");
/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(axios__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _adaptors_CoachSkatersAdaptor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../adaptors/CoachSkatersAdaptor */ "./src/js/adaptors/CoachSkatersAdaptor.ts");
/* harmony import */ var _adaptors_CoachAdaptor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../adaptors/CoachAdaptor */ "./src/js/adaptors/CoachAdaptor.ts");
/* harmony import */ var _adaptors_CoachSkaterScheduleAdaptor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../adaptors/CoachSkaterScheduleAdaptor */ "./src/js/adaptors/CoachSkaterScheduleAdaptor.ts");




var CoachService = /** @class */ (function () {
    function CoachService() {
    }
    /**
     * @deprecated 2020-07-28
     */
    CoachService.fetchCompetitionSkaters = function (competition_id) {
        return new Promise(function (resolve, reject) {
            axios__WEBPACK_IMPORTED_MODULE_0___default.a.get('/api/competitions/' + competition_id + '/coach-skaters').then(function (response) {
                if (response.data.skaters) {
                    var result = _adaptors_CoachSkatersAdaptor__WEBPACK_IMPORTED_MODULE_1__["CoachSkatersAdaptor"].adaptArray(response.data.skaters);
                    resolve(result);
                }
                reject();
            }).catch(function () {
                reject();
            });
        });
    };
    /**
     * Search for coaches
     */
    CoachService.coachSearch = function (search_params) {
        return new Promise(function (resolve, reject) {
            axios__WEBPACK_IMPORTED_MODULE_0___default.a.post('/api/coaches/search', search_params).then(function (response) {
                if (response.data.coaches) {
                    resolve(_adaptors_CoachAdaptor__WEBPACK_IMPORTED_MODULE_2__["CoachAdaptor"].adaptCoachResultArray(response.data.coaches));
                }
                reject();
            }).catch(function () {
                reject();
            });
        });
    };
    CoachService.fetchStateOptions = function () {
        return new Promise(function (resolve, reject) {
            axios__WEBPACK_IMPORTED_MODULE_0___default.a.get('/api/coach-state-options').then(function (response) {
                if (response.data.state_options) {
                    resolve(response.data.state_options);
                    return;
                }
                reject();
            }).catch(function () {
                reject();
            });
        });
    };
    /**
     * Fetch the CoachSkatersSchedule for the competition
     *
     * @deprecated 2020-07-29
     */
    CoachService.fetchCompetitionSkaterSchedule = function (competition_id) {
        return new Promise(function (resolve, reject) {
            axios__WEBPACK_IMPORTED_MODULE_0___default.a.get('/api/competitions/' + competition_id + '/coached-skater-schedule').then(function (response) {
                if (response.data.sessions && response.data.skater_session_map) {
                    resolve(_adaptors_CoachSkaterScheduleAdaptor__WEBPACK_IMPORTED_MODULE_3__["CoachSkaterScheduleAdaptor"].adapt(response.data.sessions, response.data.skater_session_map));
                    return;
                }
                reject();
            }).catch(function () {
                reject();
            });
        });
    };
    return CoachService;
}());



/***/ }),

/***/ "./src/js/services/CompetitionRegistrationService.ts":
/*!***********************************************************!*\
  !*** ./src/js/services/CompetitionRegistrationService.ts ***!
  \***********************************************************/
/*! exports provided: CompetitionRegistrationService */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CompetitionRegistrationService", function() { return CompetitionRegistrationService; });
/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! axios */ "./node_modules/axios/index.js");
/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(axios__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _adaptors_APIAdaptors_CompetitionRegistrationAPIAdapter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../adaptors/APIAdaptors/CompetitionRegistrationAPIAdapter */ "./src/js/adaptors/APIAdaptors/CompetitionRegistrationAPIAdapter.ts");
/* harmony import */ var _adaptors_APIAdaptors_SkateTestHistoryAPIAdaptor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../adaptors/APIAdaptors/SkateTestHistoryAPIAdaptor */ "./src/js/adaptors/APIAdaptors/SkateTestHistoryAPIAdaptor.ts");
/* harmony import */ var _adaptors_MemberSearchAdaptor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../adaptors/MemberSearchAdaptor */ "./src/js/adaptors/MemberSearchAdaptor.ts");
/* harmony import */ var _adaptors_APIAdaptors_UserAPIAdaptor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../adaptors/APIAdaptors/UserAPIAdaptor */ "./src/js/adaptors/APIAdaptors/UserAPIAdaptor.ts");
var __assign = (undefined && undefined.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};





var CompetitionRegistrationService = /** @class */ (function () {
    function CompetitionRegistrationService() {
    }
    /**
     * Fetch the competitions for the index list
     */
    CompetitionRegistrationService.fetchRegistrationCompetitions = function () {
        return new Promise(function (resolve, reject) {
            axios__WEBPACK_IMPORTED_MODULE_0___default.a.get('/api/competition-registration/competition-list').then(function (response) {
                if (response.data && response.data.competitions) {
                    resolve(_adaptors_APIAdaptors_CompetitionRegistrationAPIAdapter__WEBPACK_IMPORTED_MODULE_1__["CompetitionRegistrationAPIAdapter"].adaptCompetitionList(response.data.competitions));
                }
                reject();
            }).catch(function () {
                reject();
            });
        });
    };
    /**
     * Fetch screen data for competition overview
     */
    CompetitionRegistrationService.fetchCompetitionOverviewScreenData = function () {
        return new Promise(function (resolve, reject) {
            axios__WEBPACK_IMPORTED_MODULE_0___default.a.get('/api/competition-registration/screen/competition-overview').then(function (response) {
                if (response.data && response.data.competition && response.data.prices) {
                    resolve({
                        competition: _adaptors_APIAdaptors_CompetitionRegistrationAPIAdapter__WEBPACK_IMPORTED_MODULE_1__["CompetitionRegistrationAPIAdapter"].adaptActiveCompetitionInformation(response.data.competition),
                        prices: _adaptors_APIAdaptors_CompetitionRegistrationAPIAdapter__WEBPACK_IMPORTED_MODULE_1__["CompetitionRegistrationAPIAdapter"].adaptActiveCompetitionPrices(response.data.prices)
                    });
                }
                reject();
            }).catch(function () {
                reject();
            });
        });
    };
    /**
     * Fetch screen data for profile page
     */
    CompetitionRegistrationService.fetchProfileScreenData = function () {
        return new Promise(function (resolve, reject) {
            axios__WEBPACK_IMPORTED_MODULE_0___default.a.get('/api/competition-registration/screen/profile').then(function (response) {
                if (response.data && response.data.competition && response.data.user_profile) {
                    resolve({
                        competition: _adaptors_APIAdaptors_CompetitionRegistrationAPIAdapter__WEBPACK_IMPORTED_MODULE_1__["CompetitionRegistrationAPIAdapter"].adaptActiveCompetitionInformation(response.data.competition),
                        user_profile: _adaptors_APIAdaptors_UserAPIAdaptor__WEBPACK_IMPORTED_MODULE_4__["UserAPIAdaptor"].adaptUserProfileDataToUserProfile(response.data.user_profile),
                        representation_selection_required: response.data.representation_selection_required,
                        selected_representation: response.data.selected_representation ? _adaptors_APIAdaptors_CompetitionRegistrationAPIAdapter__WEBPACK_IMPORTED_MODULE_1__["CompetitionRegistrationAPIAdapter"].adaptSelectedRepresentationDataToRepresentationSelection(response.data.selected_representation) : null
                    });
                }
                reject();
            }).catch(function () {
                reject();
            });
        });
    };
    /**
     * Fetch screen data for skate tests page
     */
    CompetitionRegistrationService.fetchSkateTestsScreenData = function () {
        return new Promise(function (resolve, reject) {
            axios__WEBPACK_IMPORTED_MODULE_0___default.a.get('/api/competition-registration/screen/skate-tests').then(function (response) {
                if (response.data && response.data.competition && response.data.skate_test_history) {
                    resolve({
                        competition: _adaptors_APIAdaptors_CompetitionRegistrationAPIAdapter__WEBPACK_IMPORTED_MODULE_1__["CompetitionRegistrationAPIAdapter"].adaptActiveCompetitionInformation(response.data.competition),
                        skate_test_history: _adaptors_APIAdaptors_SkateTestHistoryAPIAdaptor__WEBPACK_IMPORTED_MODULE_2__["SkateTestHistoryAPIAdaptor"].adaptUserSkateTestHistoryDataToUserSkateTestHistory(response.data.skate_test_history)
                    });
                }
                reject();
            }).catch(function () {
                reject();
            });
        });
    };
    /**
     * Fetch the data for partner events screen
     */
    CompetitionRegistrationService.fetchPartnerEventsScreenData = function () {
        return new Promise(function (resolve, reject) {
            axios__WEBPACK_IMPORTED_MODULE_0___default.a.get('/api/competition-registration/screen/partner-events').then(function (response) {
                if (response.data && response.data.competition && response.data.selected_events) {
                    resolve({
                        competition: _adaptors_APIAdaptors_CompetitionRegistrationAPIAdapter__WEBPACK_IMPORTED_MODULE_1__["CompetitionRegistrationAPIAdapter"].adaptActiveCompetitionInformation(response.data.competition),
                        selected_events: response.data.selected_events ? response.data.selected_events : [],
                    });
                }
                reject();
            }).catch(function () {
                reject();
            });
        });
    };
    /**
     * Fetch data for partner identification page
     */
    CompetitionRegistrationService.fetchPartnerIdentificationScreenData = function () {
        return new Promise(function (resolve, reject) {
            axios__WEBPACK_IMPORTED_MODULE_0___default.a.get('/api/competition-registration/screen/partner-identification').then(function (response) {
                if (response.data.partner_categories && response.data.state_options && response.data.user_profile && response.data.competition) {
                    resolve({
                        competition: _adaptors_APIAdaptors_CompetitionRegistrationAPIAdapter__WEBPACK_IMPORTED_MODULE_1__["CompetitionRegistrationAPIAdapter"].adaptActiveCompetitionInformation(response.data.competition),
                        partner_categories: _adaptors_APIAdaptors_CompetitionRegistrationAPIAdapter__WEBPACK_IMPORTED_MODULE_1__["CompetitionRegistrationAPIAdapter"].adaptPartnerIdentificationCategoryDataArrayToPartnerIdentificationCategoryArray(response.data.partner_categories),
                        state_form_options: response.data.state_options,
                        user_profile: _adaptors_APIAdaptors_UserAPIAdaptor__WEBPACK_IMPORTED_MODULE_4__["UserAPIAdaptor"].adaptUserProfileDataToUserProfile(response.data.user_profile)
                    });
                }
                reject();
            }).catch(function () {
                reject();
            });
        });
    };
    /**
     * Fetch data for event selection page
     */
    CompetitionRegistrationService.fetchEventSelectionScreenData = function () {
        return new Promise(function (resolve, reject) {
            axios__WEBPACK_IMPORTED_MODULE_0___default.a.get('/api/competition-registration/screen/event-selection').then(function (response) {
                if (response.data.available_events && response.data.partner_skate_test_summary && response.data.competition) {
                    resolve(__assign({}, _adaptors_APIAdaptors_CompetitionRegistrationAPIAdapter__WEBPACK_IMPORTED_MODULE_1__["CompetitionRegistrationAPIAdapter"].adaptEventSelectionDataToEventSelectionResponse({
                        available_events: response.data.available_events,
                        partner_skate_test_summary: response.data.partner_skate_test_summary,
                    }), { competition: _adaptors_APIAdaptors_CompetitionRegistrationAPIAdapter__WEBPACK_IMPORTED_MODULE_1__["CompetitionRegistrationAPIAdapter"].adaptActiveCompetitionInformation(response.data.competition), selected_partner_events: response.data.selected_partner_events || [] }));
                }
                reject();
            }).catch(function () {
                reject();
            });
        });
    };
    /**
     * Fetch data for coach identification page
     */
    CompetitionRegistrationService.fetchCoachIdentificationScreenData = function () {
        return new Promise(function (resolve, reject) {
            axios__WEBPACK_IMPORTED_MODULE_0___default.a.get('/api/competition-registration/screen/coach-identification').then(function (response) {
                if (response.data.event_categories && response.data.state_options) {
                    resolve({
                        competition: _adaptors_APIAdaptors_CompetitionRegistrationAPIAdapter__WEBPACK_IMPORTED_MODULE_1__["CompetitionRegistrationAPIAdapter"].adaptActiveCompetitionInformation(response.data.competition),
                        event_categories: _adaptors_APIAdaptors_CompetitionRegistrationAPIAdapter__WEBPACK_IMPORTED_MODULE_1__["CompetitionRegistrationAPIAdapter"].adaptSkaterCoachedEventCategoryDataArrayToSkaterCoachedEventCategoryArray(response.data.event_categories),
                        state_form_options: response.data.state_options
                    });
                }
                reject();
            }).catch(function () {
                reject();
            });
        });
    };
    /**
     * Fetch data for waivers page
     */
    CompetitionRegistrationService.fetchWaiversScreenData = function () {
        return new Promise(function (resolve, reject) {
            axios__WEBPACK_IMPORTED_MODULE_0___default.a.get('/api/competition-registration/screen/waivers').then(function (response) {
                if (response.data.form_options && response.data.form_options.relationships && response.data.user_waivers) {
                    resolve({
                        competition: _adaptors_APIAdaptors_CompetitionRegistrationAPIAdapter__WEBPACK_IMPORTED_MODULE_1__["CompetitionRegistrationAPIAdapter"].adaptActiveCompetitionInformation(response.data.competition),
                        relationships: response.data.form_options.relationships,
                        user_waivers: response.data.user_waivers.map(function (waiver_data) {
                            return _adaptors_APIAdaptors_UserAPIAdaptor__WEBPACK_IMPORTED_MODULE_4__["UserAPIAdaptor"].adaptUserWaiverDataToUserWaiver(waiver_data);
                        })
                    });
                    return;
                }
                reject();
            }).catch(function () {
                reject();
            });
        });
    };
    /**
     * Fetch information about the active competition
     */
    CompetitionRegistrationService.fetchActiveCompetition = function () {
        return new Promise(function (resolve, reject) {
            axios__WEBPACK_IMPORTED_MODULE_0___default.a.get('/api/competition-registration/active-competition').then(function (response) {
                if (response.data) {
                    resolve(_adaptors_APIAdaptors_CompetitionRegistrationAPIAdapter__WEBPACK_IMPORTED_MODULE_1__["CompetitionRegistrationAPIAdapter"].adaptActiveCompetitionInformation(response.data));
                }
                reject();
            }).catch(function () {
                reject();
            });
        });
    };
    /**
     * Save the representation selection made by the user
     */
    CompetitionRegistrationService.postRepresentation = function (representation) {
        var error_message = "Error saving representation.";
        return new Promise(function (resolve, reject) {
            axios__WEBPACK_IMPORTED_MODULE_0___default.a.post('/api/competition-registration/representation', {
                representation: _adaptors_APIAdaptors_CompetitionRegistrationAPIAdapter__WEBPACK_IMPORTED_MODULE_1__["CompetitionRegistrationAPIAdapter"].adaptRepresentationSelectionToRepresentationSelectionData(representation)
            }).then(function (response) {
                if (response.data.success) {
                    resolve();
                    return;
                }
                if (response.data.error) {
                    error_message = response.data.error;
                }
                reject(error_message);
            }).catch(function (error) {
                if (error.response.data && error.response.data.error) {
                    error_message = error.response.data.error;
                }
                reject(error_message);
            });
        });
    };
    /**
     * Save user selection for which partner events they want to do
     */
    CompetitionRegistrationService.selectPartnerEvents = function (partner_event_selections) {
        var error_message = "Error saving selections.";
        return new Promise(function (resolve, reject) {
            axios__WEBPACK_IMPORTED_MODULE_0___default.a.post('/api/competition-registration/partner-events', {
                events: partner_event_selections
            }).then(function (response) {
                if (response.data.success) {
                    resolve();
                    return;
                }
                if (response.data.error) {
                    error_message = response.data.error;
                }
                reject(error_message);
            }).catch(function (error) {
                if (error.response.data && error.response.data.error) {
                    error_message = error.response.data.error;
                }
                reject(error_message);
            });
        });
    };
    /**
     * Add a selected event
     */
    CompetitionRegistrationService.addEvent = function (event) {
        var error_message = "Error adding event.";
        return new Promise(function (resolve, reject) {
            axios__WEBPACK_IMPORTED_MODULE_0___default.a.post('/api/competition-registration/event-selection/add', _adaptors_APIAdaptors_CompetitionRegistrationAPIAdapter__WEBPACK_IMPORTED_MODULE_1__["CompetitionRegistrationAPIAdapter"].adaptAddEventToEventSelectionAddAPIPayload(event)).then(function (response) {
                if (response.data && response.data.success) {
                    resolve(_adaptors_APIAdaptors_CompetitionRegistrationAPIAdapter__WEBPACK_IMPORTED_MODULE_1__["CompetitionRegistrationAPIAdapter"].adaptEventSelectionDataToEventSelectionResponse(response.data));
                }
                if (response.data.error) {
                    error_message = response.data.error;
                }
                reject(error_message);
            }).catch(function (error) {
                if (error.response.data && error.response.data.error) {
                    error_message = error.response.data.error;
                }
                reject(error_message);
            });
        });
    };
    /**
     * Remove a selected event
     */
    CompetitionRegistrationService.removeEvent = function (event) {
        var error_message = "Error removing event.";
        return new Promise(function (resolve, reject) {
            axios__WEBPACK_IMPORTED_MODULE_0___default.a.post('/api/competition-registration/event-selection/remove', _adaptors_APIAdaptors_CompetitionRegistrationAPIAdapter__WEBPACK_IMPORTED_MODULE_1__["CompetitionRegistrationAPIAdapter"].adaptAddEventToEventSelectionRemoveAPIPayload(event)).then(function (response) {
                if (response.data && response.data.success && response.data.available_events && response.data.partner_skate_test_summary) {
                    resolve(_adaptors_APIAdaptors_CompetitionRegistrationAPIAdapter__WEBPACK_IMPORTED_MODULE_1__["CompetitionRegistrationAPIAdapter"].adaptEventSelectionDataToEventSelectionResponse(response.data));
                }
                if (response.data.error) {
                    error_message = response.data.error;
                }
                reject(error_message);
            }).catch(function (error) {
                if (error.response.data && error.response.data.error) {
                    error_message = error.response.data.error;
                }
                reject(error_message);
            });
        });
    };
    /**
     * Add a partner skate test
     */
    CompetitionRegistrationService.addPartnerSkateTest = function (payload) {
        var error_message = "Error saving skate test.";
        return new Promise(function (resolve, reject) {
            axios__WEBPACK_IMPORTED_MODULE_0___default.a.post('/api/competition-registration/partner-skate-test/add', _adaptors_APIAdaptors_SkateTestHistoryAPIAdaptor__WEBPACK_IMPORTED_MODULE_2__["SkateTestHistoryAPIAdaptor"].adaptPartnerSkateTestAddAppPayloadToPartnerSkateTestAddAPIPayload(payload)).then(function (response) {
                if (response.data && response.data.success && response.data.skate_test_history && response.data.partner_skate_test_summary) {
                    resolve(_adaptors_APIAdaptors_CompetitionRegistrationAPIAdapter__WEBPACK_IMPORTED_MODULE_1__["CompetitionRegistrationAPIAdapter"].adaptPartnerSkateTestAddAPIResponseToPartnerSkateTestAddResult(response.data));
                }
                if (response.data.error) {
                    error_message = response.data.error;
                }
                reject(error_message);
            }).catch(function (error) {
                if (error.response.data && error.response.data.error) {
                    error_message = error.response.data.error;
                }
                reject(error_message);
            });
        });
    };
    /**
     * Remove a partner skate test
     */
    CompetitionRegistrationService.removePartnerSkateTest = function (remove_data) {
        var error_message = "Error removing skate test.";
        return new Promise(function (resolve, reject) {
            axios__WEBPACK_IMPORTED_MODULE_0___default.a.post('/api/competition-registration/partner-skate-test/remove', _adaptors_APIAdaptors_SkateTestHistoryAPIAdaptor__WEBPACK_IMPORTED_MODULE_2__["SkateTestHistoryAPIAdaptor"].adaptPartnerSkateTestRemoveAppPayloadToPartnerSkateTestRemoveAPIPayload(remove_data)).then(function (response) {
                if (response.data && response.data.success && response.data.skate_test_history && response.data.partner_skate_test_summary) {
                    resolve(_adaptors_APIAdaptors_CompetitionRegistrationAPIAdapter__WEBPACK_IMPORTED_MODULE_1__["CompetitionRegistrationAPIAdapter"].adaptPartnerSkateTestRemoveAPIResponseToPartnerSkateTestRemoveResult(response.data));
                }
                if (response.data.error) {
                    error_message = response.data.error;
                }
                reject(error_message);
            }).catch(function (error) {
                if (error.response.data && error.response.data.error) {
                    error_message = error.response.data.error;
                }
                reject(error_message);
            });
        });
    };
    /**
     * Search for a partner
     */
    CompetitionRegistrationService.partnerSearch = function (search_params) {
        return new Promise(function (resolve, reject) {
            axios__WEBPACK_IMPORTED_MODULE_0___default.a.post('/api/competition-registration/partner-search', _adaptors_MemberSearchAdaptor__WEBPACK_IMPORTED_MODULE_3__["MemberSearchAdaptor"].adaptMemberSearchParametersToMemberSearchAPIParameters(search_params)).then(function (response) {
                if (response.data.results) {
                    resolve(_adaptors_MemberSearchAdaptor__WEBPACK_IMPORTED_MODULE_3__["MemberSearchAdaptor"].adaptGenderedResultArray(response.data.results));
                }
                reject();
            }).catch(function () {
                reject();
            });
        });
    };
    /**
     * Add a partner to a category
     */
    CompetitionRegistrationService.addCategoryPartner = function (payload) {
        var error_message = "Error adding partner.";
        return new Promise(function (resolve, reject) {
            axios__WEBPACK_IMPORTED_MODULE_0___default.a.post('/api/competition-registration/partner-identification/category-partner/add', _adaptors_APIAdaptors_CompetitionRegistrationAPIAdapter__WEBPACK_IMPORTED_MODULE_1__["CompetitionRegistrationAPIAdapter"].adaptAddPartnerPayloadToAddPartnerAPIPayload(payload)).then(function (response) {
                if (response.data.success && response.data.partner_categories) {
                    resolve(_adaptors_APIAdaptors_CompetitionRegistrationAPIAdapter__WEBPACK_IMPORTED_MODULE_1__["CompetitionRegistrationAPIAdapter"].adaptPartnerIdentificationCategoryDataArrayToPartnerIdentificationCategoryArray(response.data.partner_categories));
                }
                if (response.data.error) {
                    error_message = response.data.error;
                }
                reject(error_message);
            }).catch(function (error) {
                if (error.response.data && error.response.data.error) {
                    error_message = error.response.data.error;
                }
                reject(error_message);
            });
        });
    };
    /**
     * Remove a partner from a category
     */
    CompetitionRegistrationService.removeCategoryPartner = function (payload) {
        var error_message = "Error removing partner.";
        return new Promise(function (resolve, reject) {
            axios__WEBPACK_IMPORTED_MODULE_0___default.a.post('/api/competition-registration/partner-identification/category-partner/remove', _adaptors_APIAdaptors_CompetitionRegistrationAPIAdapter__WEBPACK_IMPORTED_MODULE_1__["CompetitionRegistrationAPIAdapter"].adaptRemovePartnerPayloadToRemovePartnerAPIPayload(payload)).then(function (response) {
                if (response.data.success && response.data.partner_categories) {
                    resolve(_adaptors_APIAdaptors_CompetitionRegistrationAPIAdapter__WEBPACK_IMPORTED_MODULE_1__["CompetitionRegistrationAPIAdapter"].adaptPartnerIdentificationCategoryDataArrayToPartnerIdentificationCategoryArray(response.data.partner_categories));
                }
                if (response.data.error) {
                    error_message = response.data.error;
                }
                reject(error_message);
            }).catch(function (error) {
                if (error.response.data && error.response.data.error) {
                    error_message = error.response.data.error;
                }
                reject(error_message);
            });
        });
    };
    /**
     * Search for a coach
     */
    CompetitionRegistrationService.coachSearch = function (search_params) {
        return new Promise(function (resolve, reject) {
            axios__WEBPACK_IMPORTED_MODULE_0___default.a.post('/api/competition-registration/coach-search', _adaptors_MemberSearchAdaptor__WEBPACK_IMPORTED_MODULE_3__["MemberSearchAdaptor"].adaptMemberSearchParametersToMemberSearchAPIParameters(search_params)).then(function (response) {
                if (response.data.results) {
                    resolve(_adaptors_MemberSearchAdaptor__WEBPACK_IMPORTED_MODULE_3__["MemberSearchAdaptor"].adaptResultArray(response.data.results));
                }
                reject();
            }).catch(function () {
                reject();
            });
        });
    };
    /**
     * Add a coach to a category
     */
    CompetitionRegistrationService.addCategoryCoach = function (payload) {
        var error_message = "Error adding coach.";
        return new Promise(function (resolve, reject) {
            axios__WEBPACK_IMPORTED_MODULE_0___default.a.post('/api/competition-registration/coach-identification/category-coach/add', _adaptors_APIAdaptors_CompetitionRegistrationAPIAdapter__WEBPACK_IMPORTED_MODULE_1__["CompetitionRegistrationAPIAdapter"].adaptCompRegAddCoachPayloadToCompRegAddCoachAPIPayload(payload)).then(function (response) {
                if (response.data.success && response.data.event_categories) {
                    resolve(_adaptors_APIAdaptors_CompetitionRegistrationAPIAdapter__WEBPACK_IMPORTED_MODULE_1__["CompetitionRegistrationAPIAdapter"].adaptSkaterCoachedEventCategoryDataArrayToSkaterCoachedEventCategoryArray(response.data.event_categories));
                }
                if (response.data.error) {
                    error_message = response.data.error;
                }
                reject(error_message);
            }).catch(function (error) {
                if (error.response.data && error.response.data.error) {
                    error_message = error.response.data.error;
                }
                reject(error_message);
            });
        });
    };
    /**
     * Remove a coach from a category
     */
    CompetitionRegistrationService.removeCategoryCoach = function (payload) {
        var error_message = "Error removing coach.";
        return new Promise(function (resolve, reject) {
            axios__WEBPACK_IMPORTED_MODULE_0___default.a.post('/api/competition-registration/coach-identification/category-coach/remove', _adaptors_APIAdaptors_CompetitionRegistrationAPIAdapter__WEBPACK_IMPORTED_MODULE_1__["CompetitionRegistrationAPIAdapter"].adaptCompRegRemoveCoachPayloadToCompRegRemoveCoachAPIPayload(payload)).then(function (response) {
                if (response.data.success && response.data.event_categories) {
                    resolve(_adaptors_APIAdaptors_CompetitionRegistrationAPIAdapter__WEBPACK_IMPORTED_MODULE_1__["CompetitionRegistrationAPIAdapter"].adaptSkaterCoachedEventCategoryDataArrayToSkaterCoachedEventCategoryArray(response.data.event_categories));
                }
                if (response.data.error) {
                    error_message = response.data.error;
                }
                reject(error_message);
            }).catch(function (error) {
                if (error.response.data && error.response.data.error) {
                    error_message = error.response.data.error;
                }
                reject(error_message);
            });
        });
    };
    /**
     * Replace a coach for a category
     */
    CompetitionRegistrationService.replaceCategoryCoach = function (payload) {
        var error_message = "Error changing coach.";
        return new Promise(function (resolve, reject) {
            axios__WEBPACK_IMPORTED_MODULE_0___default.a.post('/api/competition-registration/coach-identification/category-coach/change', _adaptors_APIAdaptors_CompetitionRegistrationAPIAdapter__WEBPACK_IMPORTED_MODULE_1__["CompetitionRegistrationAPIAdapter"].adaptCompRegReplaceCoachPayloadToCompRegReplaceCoachAPIPayload(payload)).then(function (response) {
                if (response.data.success && response.data.event_categories) {
                    resolve(_adaptors_APIAdaptors_CompetitionRegistrationAPIAdapter__WEBPACK_IMPORTED_MODULE_1__["CompetitionRegistrationAPIAdapter"].adaptSkaterCoachedEventCategoryDataArrayToSkaterCoachedEventCategoryArray(response.data.event_categories));
                }
                if (response.data.error) {
                    error_message = response.data.error;
                }
                reject(error_message);
            }).catch(function (error) {
                if (error.response.data && error.response.data.error) {
                    error_message = error.response.data.error;
                }
                reject(error_message);
            });
        });
    };
    return CompetitionRegistrationService;
}());



/***/ }),

/***/ "./src/js/services/CompetitionService.ts":
/*!***********************************************!*\
  !*** ./src/js/services/CompetitionService.ts ***!
  \***********************************************/
/*! exports provided: CompetitionService, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CompetitionService", function() { return CompetitionService; });
/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! axios */ "./node_modules/axios/index.js");
/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(axios__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _adaptors_APIAdaptors_VolunteerOpportunitiesAPIAdaptor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../adaptors/APIAdaptors/VolunteerOpportunitiesAPIAdaptor */ "./src/js/adaptors/APIAdaptors/VolunteerOpportunitiesAPIAdaptor.ts");
/* harmony import */ var _adaptors_CompetitionContactDataAdaptor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../adaptors/CompetitionContactDataAdaptor */ "./src/js/adaptors/CompetitionContactDataAdaptor.ts");
/* harmony import */ var _adaptors_CompetitionDataAdaptor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../adaptors/CompetitionDataAdaptor */ "./src/js/adaptors/CompetitionDataAdaptor.ts");
/* harmony import */ var _adaptors_CompetitionInformationDataAdaptor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../adaptors/CompetitionInformationDataAdaptor */ "./src/js/adaptors/CompetitionInformationDataAdaptor.ts");
/* harmony import */ var _adaptors_CompetitionScheduleDataAdaptor__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../adaptors/CompetitionScheduleDataAdaptor */ "./src/js/adaptors/CompetitionScheduleDataAdaptor.ts");
/* harmony import */ var _config_AppConfig__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../config/AppConfig */ "./src/js/config/AppConfig.ts");
/* harmony import */ var _pages_SearchCompetitions_SearchCompetitionsTransformer__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../pages/SearchCompetitions/SearchCompetitionsTransformer */ "./src/js/pages/SearchCompetitions/SearchCompetitionsTransformer.ts");
/* harmony import */ var _pages_ViewCompetition_ViewCompetitionTransformer__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../pages/ViewCompetition/ViewCompetitionTransformer */ "./src/js/pages/ViewCompetition/ViewCompetitionTransformer.ts");
/* harmony import */ var _AbstractAPIService__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./AbstractAPIService */ "./src/js/services/AbstractAPIService.ts");
/* harmony import */ var _CompetitionPortal_transformers_DataNavigationLinkTransformer__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../CompetitionPortal/_transformers/DataNavigationLinkTransformer */ "./src/js/CompetitionPortal/_transformers/DataNavigationLinkTransformer.ts");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (undefined && undefined.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};











/**
 * COMPETITION SERVICE
 *
 * Service class for managing data related to Competitions
 */
var CompetitionService = /** @class */ (function (_super) {
    __extends(CompetitionService, _super);
    function CompetitionService() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Fetch the competition heading data for a competition
     */
    CompetitionService.fetchCompetitionPageHeading = function (competition_id) {
        return _AbstractAPIService__WEBPACK_IMPORTED_MODULE_9__["AbstractAPIService"].fetchAndTransformResponse({
            url: "/api/competitions/" + competition_id + "/page-heading",
            /**
             * Validate that the response is present and is an object
             */
            validateResponse: function (response_data) {
                return !!response_data && typeof response_data === 'object';
            },
            /**
             * Transform API data to App data
             */
            transformResponse: function (response_data) {
                return __assign({}, response_data, { directions: response_data.directions || [], announcement_url: response_data.announcement_url || null, website_url: response_data.website_url || null, id: competition_id });
            }
        });
    };
    /**
     * Fetch and construct competition list
     */
    CompetitionService.getCompetitionList = function () {
        return new Promise(function (resolve, reject) {
            axios__WEBPACK_IMPORTED_MODULE_0___default.a.get(_config_AppConfig__WEBPACK_IMPORTED_MODULE_6__["URL_CONFIG"].getCompetitionList)
                .then(function (response) {
                if (response.data) {
                    resolve(_adaptors_CompetitionDataAdaptor__WEBPACK_IMPORTED_MODULE_3__["CompetitionDataAdaptor"].adaptArray(response.data));
                }
                reject();
            })
                .catch(function () {
                reject();
            });
        });
    };
    /**
     * Fetch and construct competition list
     */
    CompetitionService.getCompetitionListSearch = function () {
        return _AbstractAPIService__WEBPACK_IMPORTED_MODULE_9__["AbstractAPIService"].fetchAndTransformResponse({
            url: '/api/search-competitions',
            /**
             * Validate that the response is an array
             */
            validateResponse: function (response_data) {
                return !!response_data && typeof response_data.competitions === 'object';
            },
            /**
             * Transform API data to App data
             */
            transformResponse: function (response_data) {
                return _pages_SearchCompetitions_SearchCompetitionsTransformer__WEBPACK_IMPORTED_MODULE_7__["SearchCompetitionsTransformer"].transformFetchSearchCompetitionList(response_data);
            }
        });
    };
    /**
     * Get the competition information for a competition
     *
     * @deprecated 2020-07-29
     */
    CompetitionService.getCompetitionInformation = function (competition_id) {
        return new Promise(function (resolve, reject) {
            axios__WEBPACK_IMPORTED_MODULE_0___default.a.get('/api/competitions/' + competition_id + '/information')
                .then(function (response) {
                if (response.data) {
                    resolve(_adaptors_CompetitionInformationDataAdaptor__WEBPACK_IMPORTED_MODULE_4__["CompetitionInformationDataAdaptor"].adapt(response.data));
                }
                reject();
            })
                .catch(function () {
                reject();
            });
        });
    };
    /**
     * Get the schedule for a competition
     *
     * @deprecated 2020-07-29
     */
    CompetitionService.getCompetitionSchedule = function (competition_id) {
        return _AbstractAPIService__WEBPACK_IMPORTED_MODULE_9__["AbstractAPIService"].fetchAndTransformResponse({
            url: "/api/competitions/" + competition_id + "/schedule",
            /**
             * Validate that the response contains the proper structures
             */
            validateResponse: function (response_data) {
                if (!response_data || typeof response_data !== 'object') {
                    return false;
                }
                // Verify schedule data is provided if unavailable flag is not set
                if (!response_data.schedule_unavailable) {
                    var required_keys = [
                        'facilities',
                        'rinks',
                        'sessions'
                    ];
                    for (var i = 0; i < required_keys.length; i++) {
                        var requiredKey = required_keys[i];
                        if (!(requiredKey in response_data)) {
                            console.warn("Required key \"" + requiredKey + "\" missing from available competition schedule data.");
                            return false;
                        }
                    }
                }
                return true;
            },
            /**
             * Transform API data to App data
             */
            transformResponse: function (response_data) {
                if (response_data.schedule_unavailable) {
                    return {
                        schedule_available: false
                    };
                }
                return {
                    schedule_available: true,
                    schedule: _adaptors_CompetitionScheduleDataAdaptor__WEBPACK_IMPORTED_MODULE_5__["CompetitionScheduleDataAdaptor"].adapt(response_data)
                };
            }
        });
    };
    /**
     * Get the list of contacts for a competition
     *
     * @deprecated 2020-07-01; see:CompetitionPortalApiService.fetchCompetitionContacts
     */
    CompetitionService.getCompetitionContacts = function (competition_id) {
        return _AbstractAPIService__WEBPACK_IMPORTED_MODULE_9__["AbstractAPIService"].fetchAndTransformResponse({
            url: "/api/competitions/" + competition_id + "/contacts",
            /**
             * Validate that the response contains the proper structures
             */
            validateResponse: function (response_data) {
                return !!response_data && typeof response_data.contacts === 'object';
            },
            /**
             * Transform API data to App data
             */
            transformResponse: function (response_data) {
                return {
                    contacts: _adaptors_CompetitionContactDataAdaptor__WEBPACK_IMPORTED_MODULE_2__["CompetitionContactDataAdaptor"].adaptArray(response_data.contacts)
                };
            }
        });
    };
    /**
     * Fetch the ViewCompetitionCompetition for a competition ID
     *
     * @deprecated 2020-06-24
     */
    CompetitionService.fetchViewCompetitionCompetition = function (competition_id) {
        return _AbstractAPIService__WEBPACK_IMPORTED_MODULE_9__["AbstractAPIService"].fetchAndTransformResponse({
            url: "/api/view-competition/" + competition_id,
            /**
             * Validate that the response is present and is an object
             */
            validateResponse: function (response_data) {
                return !!response_data && typeof response_data === 'object';
            },
            /**
             * Transform API data to App data
             */
            transformResponse: function (response_data) {
                return _pages_ViewCompetition_ViewCompetitionTransformer__WEBPACK_IMPORTED_MODULE_8__["ViewCompetitionTransformer"].transformFetchViewCompetitionCompetition(response_data);
            }
        });
    };
    /**
     * Submit a volunteer request for a competition (from view competition page)
     */
    CompetitionService.submitCompetitionVolunteerRequest = function (competition_id, form_data) {
        return _AbstractAPIService__WEBPACK_IMPORTED_MODULE_9__["AbstractAPIService"].submitWithTransformedResponse({
            error_message: 'Error submitting request.',
            url: "/api/competitions/" + competition_id + "/volunteer-request",
            payload: _adaptors_APIAdaptors_VolunteerOpportunitiesAPIAdaptor__WEBPACK_IMPORTED_MODULE_1__["VolunteerOpportunitiesAPIAdaptor"].adaptVolunteerRequestExperienceFormDataToSubmitVolunteerRequestAPIPayload(form_data),
            /**
             * Validate the server response
             */
            validateResponse: function (response_data) {
                return !!response_data
                    && !!response_data.success
                    && typeof response_data.confirmation_message !== 'undefined'
                    && typeof response_data.volunteer_cta_configuration === 'object';
            },
            /**
             * Transform the server response
             */
            transformResponse: function (response_data) {
                var response = {
                    volunteer_cta_configuration: response_data.volunteer_cta_configuration,
                    confirmation_message: response_data.confirmation_message
                };
                if (response_data.competition_user_navigation) {
                    response.user_navigation = response_data.competition_user_navigation.map(function (data) {
                        return _CompetitionPortal_transformers_DataNavigationLinkTransformer__WEBPACK_IMPORTED_MODULE_10__["DataNavigationLinkTransformer"].transformDataNavigationLink(data);
                    });
                }
                return response;
            }
        });
    };
    /**
     * Update the completion status on a competition document
     */
    CompetitionService.updateCompetitionDocumentCompletionStatus = function (document, competition_id) {
        var payload = {
            competition_id: competition_id,
            document_id: document.id,
            is_complete: !document.is_complete
        };
        return _AbstractAPIService__WEBPACK_IMPORTED_MODULE_9__["AbstractAPIService"].submitForAPISubmissionResponse({
            error_message: 'Error updating document status',
            method: 'put',
            payload: payload,
            url: "/api/competitions/" + competition_id + "/documents/" + document.id
        });
    };
    return CompetitionService;
}(_AbstractAPIService__WEBPACK_IMPORTED_MODULE_9__["AbstractAPIService"]));

/* harmony default export */ __webpack_exports__["default"] = (CompetitionService);


/***/ }),

/***/ "./src/js/services/DataDisplayService.ts":
/*!***********************************************!*\
  !*** ./src/js/services/DataDisplayService.ts ***!
  \***********************************************/
/*! exports provided: DataDisplayService */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DataDisplayService", function() { return DataDisplayService; });
var __assign = (undefined && undefined.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
var DataDisplayService = /** @class */ (function () {
    function DataDisplayService() {
    }
    /**
     * Capitalize the first letter in a string
     */
    DataDisplayService.capitalize = function (value) {
        return value.toLowerCase().replace(/^[a-z]/, function (letter) {
            return letter.toUpperCase();
        });
    };
    /**
     * Get a display value on an object from a KeyPath.
     * If the key path results in a non-falsy string value on the object, return it.
     *
     * ex:
     * displayFieldFromObject("club.name", {club: {name: "Temp", id: 2}}) => "Temp"
     */
    DataDisplayService.displayFieldFromObject = function (key_path, source_object) {
        var field_path = key_path.split('.');
        var current_value = __assign({}, source_object);
        while (field_path.length) {
            var key = field_path.shift();
            if (!key || !current_value[key]) {
                return null;
            }
            current_value = current_value[key];
        }
        if (typeof current_value !== "string") {
            return null;
        }
        return current_value;
    };
    return DataDisplayService;
}());



/***/ }),

/***/ "./src/js/services/FormOptionService.ts":
/*!**********************************************!*\
  !*** ./src/js/services/FormOptionService.ts ***!
  \**********************************************/
/*! exports provided: FormOptionService */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FormOptionService", function() { return FormOptionService; });
/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! axios */ "./node_modules/axios/index.js");
/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(axios__WEBPACK_IMPORTED_MODULE_0__);

/**
 * Service class for interacting with API in relation to FormOptions
 */
var FormOptionService = /** @class */ (function () {
    function FormOptionService() {
    }
    /**
     * Get all form options and configurations needed for Create Account
     * @note: adapter layer is not currently in place and will need to be added if necessary
     */
    FormOptionService.GetCreateAccountOptions = function () {
        return new Promise(function (resolve, reject) {
            axios__WEBPACK_IMPORTED_MODULE_0___default.a.get('/api/form-options/component/create-account').then(function (response) {
                if (response.data.options) {
                    resolve(response.data.options);
                    return;
                }
                reject();
            }).catch(function () {
                reject();
            });
        });
    };
    FormOptionService.GetEditProfileOptions = function () {
        return new Promise(function (resolve, reject) {
            axios__WEBPACK_IMPORTED_MODULE_0___default.a.get('/api/form-options/component/edit-profile').then(function (response) {
                if (response.data.options) {
                    resolve({
                        user_prefixes: response.data.options.user_prefixes,
                        user_suffixes: response.data.options.user_suffixes,
                        mobile_carriers: response.data.options.mobile_carriers,
                    });
                    return;
                }
                reject();
            }).catch(function () {
                reject();
            });
        });
    };
    FormOptionService.getClubOptions = function () {
        return new Promise(function (resolve, reject) {
            axios__WEBPACK_IMPORTED_MODULE_0___default.a.get('/api/form-options/clubs').then(function (response) {
                if (response.data.options) {
                    resolve(response.data.options);
                    return;
                }
                reject();
            }).catch(function () {
                reject();
            });
        });
    };
    FormOptionService.getBillingAddressOptions = function () {
        return new Promise(function (resolve, reject) {
            axios__WEBPACK_IMPORTED_MODULE_0___default.a.get('/api/form-options/component/billing-address').then(function (response) {
                if (response.data.options) {
                    resolve(response.data.options);
                    return;
                }
                reject();
            }).catch(function () {
                reject();
            });
        });
    };
    return FormOptionService;
}());



/***/ }),

/***/ "./src/js/services/PaginationService.ts":
/*!**********************************************!*\
  !*** ./src/js/services/PaginationService.ts ***!
  \**********************************************/
/*! exports provided: PaginationService */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PaginationService", function() { return PaginationService; });
/* harmony import */ var _helpers_SearchResultHelpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../helpers/SearchResultHelpers */ "./src/js/helpers/SearchResultHelpers.ts");

/**
 * New service class to wrap previously-existing functions
 */
var PaginationService = /** @class */ (function () {
    function PaginationService() {
    }
    /**
     * Paginate an array of items
     */
    PaginationService.paginate = function (items, per_page) {
        if (items.length === 0) {
            return [[]];
        }
        var result = [];
        return items.reduce(function (accumulator, item, index) {
            var result_index = 0;
            if (typeof per_page === "number") {
                result_index = Math.floor(index / per_page);
            }
            if (!accumulator[result_index]) {
                accumulator[result_index] = [];
            }
            accumulator[result_index].push(item);
            return accumulator;
        }, result);
    };
    /**
     * Get the options to display in pagination
     */
    PaginationService.paginationOptions = function (paginated_data, active_page_index) {
        return _helpers_SearchResultHelpers__WEBPACK_IMPORTED_MODULE_0__["default"].getPaginationOptions(paginated_data, active_page_index);
    };
    return PaginationService;
}());



/***/ }),

/***/ "./src/js/services/SkaterService.ts":
/*!******************************************!*\
  !*** ./src/js/services/SkaterService.ts ***!
  \******************************************/
/*! exports provided: SkaterService */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SkaterService", function() { return SkaterService; });
/* harmony import */ var _adaptors_SkaterCreditDataAdaptor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../adaptors/SkaterCreditDataAdaptor */ "./src/js/adaptors/SkaterCreditDataAdaptor.ts");
/* harmony import */ var _adaptors_SkaterEventDataAdaptor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../adaptors/SkaterEventDataAdaptor */ "./src/js/adaptors/SkaterEventDataAdaptor.ts");
/* harmony import */ var _adaptors_SessionDataAdaptor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../adaptors/SessionDataAdaptor */ "./src/js/adaptors/SessionDataAdaptor.ts");
/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! axios */ "./node_modules/axios/index.js");
/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(axios__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _adaptors_BillingAddressDataAdaptor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../adaptors/BillingAddressDataAdaptor */ "./src/js/adaptors/BillingAddressDataAdaptor.ts");
/* harmony import */ var _adaptors_APIAdaptors_SkaterAPIAdaptor__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../adaptors/APIAdaptors/SkaterAPIAdaptor */ "./src/js/adaptors/APIAdaptors/SkaterAPIAdaptor.ts");
/* harmony import */ var _adaptors_SkaterInfoDataAdaptor__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../adaptors/SkaterInfoDataAdaptor */ "./src/js/adaptors/SkaterInfoDataAdaptor.ts");
/* harmony import */ var _models_Collections_SkaterCoachedEventCollection__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../models/Collections/SkaterCoachedEventCollection */ "./src/js/models/Collections/SkaterCoachedEventCollection.ts");
/* harmony import */ var _adaptors_SkaterSkatingEventSegmentAdaptor__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../adaptors/SkaterSkatingEventSegmentAdaptor */ "./src/js/adaptors/SkaterSkatingEventSegmentAdaptor.ts");
/* harmony import */ var _adaptors_PPCDataAdaptor__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../adaptors/PPCDataAdaptor */ "./src/js/adaptors/PPCDataAdaptor.ts");
/* harmony import */ var _adaptors_MusicDataAdaptor__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../adaptors/MusicDataAdaptor */ "./src/js/adaptors/MusicDataAdaptor.ts");
/* harmony import */ var _CompetitionPortal_services__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../CompetitionPortal/_services */ "./src/js/CompetitionPortal/_services/index.ts");












var SkaterService = /** @class */ (function () {
    function SkaterService() {
    }
    /**
     * Retrieve the active skater's schedule
     *
     * @deprecated 2020-08-04
     */
    SkaterService.getCompetitionSchedule = function (competition_id) {
        return new Promise(function (resolve, reject) {
            axios__WEBPACK_IMPORTED_MODULE_3___default.a.get('/api/competitions/' + competition_id + "/skater-schedule").then(function (response) {
                if (response.data && response.data.sessions && response.data.events) {
                    var result = {
                        sessions: _adaptors_SessionDataAdaptor__WEBPACK_IMPORTED_MODULE_2__["SessionDataAdaptor"].adaptScheduledArray(response.data.sessions),
                        events: _adaptors_SkaterEventDataAdaptor__WEBPACK_IMPORTED_MODULE_1__["SkaterEventDataAdaptor"].adaptArray(response.data.events)
                    };
                    resolve(result);
                }
                reject();
            }).catch(function () {
                reject();
            });
        });
    };
    /**
     * Retrieve the active skater's credits for the active competition
     */
    SkaterService.getCompetitionCredits = function (competition_id) {
        return new Promise(function (resolve, reject) {
            axios__WEBPACK_IMPORTED_MODULE_3___default.a.get('/api/competitions/' + competition_id + "/skater-credits").then(function (response) {
                if (response.data) {
                    resolve(_adaptors_SkaterCreditDataAdaptor__WEBPACK_IMPORTED_MODULE_0__["SkaterCreditDataAdaptor"].adaptCompetitionCredits(response.data));
                }
                reject();
            }).catch(function () {
                reject();
            });
        });
    };
    /**
     * Add a session to skater's schedule.
     */
    SkaterService.addSessionToSchedule = function (scheduled_session) {
        return new Promise(function (resolve, reject) {
            axios__WEBPACK_IMPORTED_MODULE_3___default.a.post('/api/skater/schedule/add-session', _adaptors_APIAdaptors_SkaterAPIAdaptor__WEBPACK_IMPORTED_MODULE_5__["SkaterAPIAdaptor"].adaptAddSession(scheduled_session)).then(function (response) {
                if (response.data.success) {
                    resolve();
                }
                reject();
            }).catch(function () {
                reject();
            });
        });
    };
    /**
     * Remove a session from a skater's schedule. Increment credit.
     */
    SkaterService.removeSessionFromSchedule = function (scheduled_session) {
        return new Promise(function (resolve, reject) {
            axios__WEBPACK_IMPORTED_MODULE_3___default.a.post('/api/skater/schedule/remove-session', _adaptors_APIAdaptors_SkaterAPIAdaptor__WEBPACK_IMPORTED_MODULE_5__["SkaterAPIAdaptor"].adaptRemoveSession(scheduled_session)).then(function (response) {
                if (response.data.success) {
                    resolve();
                }
                reject();
            }).catch(function () {
                reject();
            });
        });
    };
    /**
     * Retrieve the skater-registered event ids for a competition
     */
    SkaterService.getCompetitionRegisteredEventIDs = function (competition_id) {
        return new Promise(function (resolve, reject) {
            axios__WEBPACK_IMPORTED_MODULE_3___default.a.get('/api/competitions/' + competition_id + "/skater-event-ids").then(function (response) {
                if (response.data && typeof response.data === 'object') {
                    resolve((response.data));
                }
                reject();
            }).catch(function () {
                reject();
            });
        });
    };
    /**
     * Get all billing addresses for a skater
     *
     * Resolves with array of adapted BillingAddresses
     */
    SkaterService.getBillingAddresses = function () {
        return new Promise(function (resolve, reject) {
            axios__WEBPACK_IMPORTED_MODULE_3___default.a.get('/api/skater-addresses').then(function (response) {
                resolve(_adaptors_BillingAddressDataAdaptor__WEBPACK_IMPORTED_MODULE_4__["BillingAddressDataAdaptor"].adaptArray(response.data));
            }).catch(function () {
                reject();
            });
        });
    };
    /**
     * Save edits to a billing address.
     *
     * Void resolution
     */
    SkaterService.updateBillingAddress = function (edit_opts) {
        var source = edit_opts.source;
        var error_message = "Error saving address.";
        return new Promise(function (resolve, reject) {
            axios__WEBPACK_IMPORTED_MODULE_3___default.a.post('/api/skater-addresses/' + source.id + '/update', _adaptors_APIAdaptors_SkaterAPIAdaptor__WEBPACK_IMPORTED_MODULE_5__["SkaterAPIAdaptor"].adaptUpdateAddress(edit_opts)).then(function (response) {
                if (response.data.success && response.data.address) {
                    resolve(_adaptors_BillingAddressDataAdaptor__WEBPACK_IMPORTED_MODULE_4__["BillingAddressDataAdaptor"].adapt(response.data.address));
                    return;
                }
                if (response.data.error) {
                    error_message = response.data.error;
                }
                reject(error_message);
            }).catch(function (error) {
                if (error.response.data && error.response.data.error) {
                    error_message = error.response.data.error;
                }
                reject(error_message);
            });
        });
    };
    /**
     * Create a new billing address.
     *
     * Expected server response - the ID of the created address
     *
     * Resolves with an adapted BillingAddress object
     */
    SkaterService.createBillingAddress = function (create_opts) {
        var data = create_opts.data;
        var error_message = "Error saving address.";
        return new Promise(function (resolve, reject) {
            axios__WEBPACK_IMPORTED_MODULE_3___default.a.post('/api/skater-addresses/create', _adaptors_APIAdaptors_SkaterAPIAdaptor__WEBPACK_IMPORTED_MODULE_5__["SkaterAPIAdaptor"].adaptCreateAddress(data)).then(function (response) {
                if (response.data.success && response.data.address) {
                    resolve(_adaptors_BillingAddressDataAdaptor__WEBPACK_IMPORTED_MODULE_4__["BillingAddressDataAdaptor"].adapt(response.data.address));
                    return;
                }
                if (response.data.error) {
                    error_message = response.data.error;
                }
                reject(error_message);
            }).catch(function (error) {
                if (error.response.data && error.response.data.error) {
                    error_message = error.response.data.error;
                }
                reject(error_message);
            });
        });
    };
    /**
     * Get the skater's info
     * @deprecated 5/27/19 - this returned basic name and address info and has been superseded by User Profile info
     */
    SkaterService.getSkaterInfo = function () {
        return new Promise(function (resolve, reject) {
            axios__WEBPACK_IMPORTED_MODULE_3___default.a.get('/api/skater/info').then(function (response) {
                resolve(_adaptors_SkaterInfoDataAdaptor__WEBPACK_IMPORTED_MODULE_6__["SkaterInfoDataAdaptor"].adapt(response.data));
            }).catch(function () {
                reject();
            });
        });
    };
    /**
     * Get the events a skater is registered for along with linked coaches for a given competition
     *
     * @deprecated 2020-07-28
     */
    SkaterService.getCompetitionEventCoaches = function (competition_id) {
        return new Promise(function (resolve, reject) {
            axios__WEBPACK_IMPORTED_MODULE_3___default.a.get('/api/competitions/' + competition_id + '/my-coaches').then(function (response) {
                if (response.data.event_categories) {
                    resolve(new _models_Collections_SkaterCoachedEventCollection__WEBPACK_IMPORTED_MODULE_7__["SkaterCoachedEventCategoryCollection"](_adaptors_SkaterEventDataAdaptor__WEBPACK_IMPORTED_MODULE_1__["SkaterEventDataAdaptor"].adaptCoachedEventArray(response.data.event_categories)));
                }
                reject();
            }).catch(function () {
                reject();
            });
        });
    };
    /**
     * Remove a coach from a skater's competition event category
     */
    SkaterService.removeCoach = function (payload) {
        var competition_id = payload.competition_id;
        return new Promise(function (resolve, reject) {
            axios__WEBPACK_IMPORTED_MODULE_3___default.a.post('/api/competitions/' + competition_id + '/my-coaches/remove', _adaptors_APIAdaptors_SkaterAPIAdaptor__WEBPACK_IMPORTED_MODULE_5__["SkaterAPIAdaptor"].adaptRemoveCoach(payload)).then(function (response) {
                if (response.data.success) {
                    resolve();
                }
                reject();
            }).catch(function () {
                reject();
            });
        });
    };
    /**
     * Add a coach for an event category within a competition
     */
    SkaterService.addCoach = function (payload) {
        var competition_id = payload.competition_id;
        return new Promise(function (resolve, reject) {
            axios__WEBPACK_IMPORTED_MODULE_3___default.a.post('/api/competitions/' + competition_id + '/my-coaches/add', _adaptors_APIAdaptors_SkaterAPIAdaptor__WEBPACK_IMPORTED_MODULE_5__["SkaterAPIAdaptor"].adaptAddCoach(payload)).then(function (response) {
                if (response.data.success) {
                    resolve();
                }
                reject();
            }).catch(function () {
                reject();
            });
        });
    };
    /**
     * Replace a coach for an event category within a competition
     */
    SkaterService.replaceCoach = function (payload) {
        var competition_id = payload.competition_id;
        return new Promise(function (resolve, reject) {
            axios__WEBPACK_IMPORTED_MODULE_3___default.a.post('/api/competitions/' + competition_id + '/my-coaches/replace', _adaptors_APIAdaptors_SkaterAPIAdaptor__WEBPACK_IMPORTED_MODULE_5__["SkaterAPIAdaptor"].adaptReplaceCoach(payload)).then(function (response) {
                if (response.data.success) {
                    resolve();
                }
                reject();
            }).catch(function () {
                reject();
            });
        });
    };
    SkaterService.savePPC = function (payload) {
        var competition_id = payload.competition_id;
        return new Promise(function (resolve, reject) {
            axios__WEBPACK_IMPORTED_MODULE_3___default.a.post(_CompetitionPortal_services__WEBPACK_IMPORTED_MODULE_11__["CompetitionPortalApiService"].transformMusicPpcUrl('ppc/save'), _adaptors_APIAdaptors_SkaterAPIAdaptor__WEBPACK_IMPORTED_MODULE_5__["SkaterAPIAdaptor"].adaptSavePPC(payload)).then(function (response) {
                if (response.data.success) {
                    resolve(_adaptors_APIAdaptors_SkaterAPIAdaptor__WEBPACK_IMPORTED_MODULE_5__["SkaterAPIAdaptor"].adaptSavePPCResponse(response.data));
                }
                reject();
            }).catch(function () {
                reject();
            });
        });
    };
    SkaterService.getPPC = function (fetch_args) {
        var event_id = fetch_args.event_id, event_segment_id = fetch_args.event_segment_id, competition_id = fetch_args.competition_id;
        return new Promise(function (resolve, reject) {
            axios__WEBPACK_IMPORTED_MODULE_3___default.a.get(_CompetitionPortal_services__WEBPACK_IMPORTED_MODULE_11__["CompetitionPortalApiService"].transformMusicPpcUrl('ppc'), {
                params: fetch_args
            }).then(function (response) {
                if (response.data.ppc) {
                    var ppc = _adaptors_PPCDataAdaptor__WEBPACK_IMPORTED_MODULE_9__["PPCDataAdaptor"].adapt_PPCData_To_PPC(response.data.ppc);
                    resolve(ppc);
                }
                reject();
            }).catch(function () {
                reject();
            });
        });
    };
    SkaterService.getSkatingEventSegments = function (competition_id) {
        return new Promise(function (resolve, reject) {
            axios__WEBPACK_IMPORTED_MODULE_3___default.a.get('/api/competitions/' + competition_id + "/skater-event-segments").then(function (response) {
                try {
                    resolve(_adaptors_SkaterSkatingEventSegmentAdaptor__WEBPACK_IMPORTED_MODULE_8__["SkaterSkatingEventSegmentAdaptor"].adaptEventSegmentsData(response.data));
                }
                catch (e) {
                    reject();
                }
                reject();
            }).catch(function () {
                reject();
            });
        });
    };
    SkaterService.getEventSegmentMusic = function (fetch_args) {
        var competition_id = fetch_args.competition_id;
        return new Promise(function (resolve, reject) {
            axios__WEBPACK_IMPORTED_MODULE_3___default.a.get(_CompetitionPortal_services__WEBPACK_IMPORTED_MODULE_11__["CompetitionPortalApiService"].transformMusicPpcUrl('music'), {
                params: fetch_args
            }).then(function (response) {
                try {
                    resolve(_adaptors_MusicDataAdaptor__WEBPACK_IMPORTED_MODULE_10__["MusicDataAdaptor"].adaptEventSegmentMusicDataToEventSegmentMusic(response.data));
                }
                catch (e) {
                    reject();
                }
            }).catch(function () {
                reject();
            });
        });
    };
    SkaterService.saveEventSegmentMusic = function (save_payload) {
        return new Promise(function (resolve, reject) {
            axios__WEBPACK_IMPORTED_MODULE_3___default.a.post(_CompetitionPortal_services__WEBPACK_IMPORTED_MODULE_11__["CompetitionPortalApiService"].transformMusicPpcUrl('music/save'), _adaptors_APIAdaptors_SkaterAPIAdaptor__WEBPACK_IMPORTED_MODULE_5__["SkaterAPIAdaptor"].adaptSaveMusic(save_payload)).then(function (response) {
                if (response.data.success) {
                    resolve(_adaptors_APIAdaptors_SkaterAPIAdaptor__WEBPACK_IMPORTED_MODULE_5__["SkaterAPIAdaptor"].adaptSaveMusicResponse(response.data, save_payload));
                    return;
                }
                reject();
            }).catch(function () {
                reject();
            });
        });
    };
    SkaterService.fetchMusicLibrary = function () {
        return new Promise(function (resolve, reject) {
            axios__WEBPACK_IMPORTED_MODULE_3___default.a.get('/api/music-library').then(function (response) {
                if (response.data.library) {
                    resolve(_adaptors_MusicDataAdaptor__WEBPACK_IMPORTED_MODULE_10__["MusicDataAdaptor"].adaptMusicLibrary(response.data.library));
                }
                resolve();
            }).catch(function () {
                reject();
            });
        });
    };
    // @downstream-sync 2020-07-02 - import rhythm/theme feature
    SkaterService.fetchRhythms = function (fetch_args) {
        var competition_id = fetch_args.competition_id; // @downstream-sync 2020-07-02 - it looks like there was a bug here.  Added ".competition_id"
        return new Promise(function (resolve, reject) {
            axios__WEBPACK_IMPORTED_MODULE_3___default.a.get(_CompetitionPortal_services__WEBPACK_IMPORTED_MODULE_11__["CompetitionPortalApiService"].transformMusicPpcUrl('rhythms'), { params: fetch_args }).then(function (response) {
                if (response.data.rhythms) {
                    resolve(response.data.rhythms);
                }
                reject();
            }).catch(function () {
                reject();
            });
        });
    };
    // @downstream-sync 2020-07-02 - import rhythm/theme feature
    SkaterService.saveRhythms = function (payload) {
        var competition_id = payload.competition_id;
        return new Promise(function (resolve, reject) {
            axios__WEBPACK_IMPORTED_MODULE_3___default.a.post(_CompetitionPortal_services__WEBPACK_IMPORTED_MODULE_11__["CompetitionPortalApiService"].transformMusicPpcUrl('rhythms/save'), payload).then(function (response) {
                if (response.data.success) {
                    resolve(response.data);
                }
                reject();
            }).catch(function () {
                reject();
            });
        });
    };
    // @downstream-sync 2020-07-02 - import rhythm/theme feature
    SkaterService.fetchTheme = function (fetch_args) {
        var competition_id = fetch_args.competition_id;
        return new Promise(function (resolve, reject) {
            axios__WEBPACK_IMPORTED_MODULE_3___default.a.get(_CompetitionPortal_services__WEBPACK_IMPORTED_MODULE_11__["CompetitionPortalApiService"].transformMusicPpcUrl('theme'), { params: fetch_args }).then(function (response) {
                if (response.data.theme !== null && response.data.theme !== undefined) {
                    resolve(response.data.theme);
                }
                reject();
            }).catch(function () {
                reject();
            });
        });
    };
    // @downstream-sync 2020-07-02 - import rhythm/theme feature
    SkaterService.saveTheme = function (payload) {
        var competition_id = payload.competition_id;
        return new Promise(function (resolve, reject) {
            axios__WEBPACK_IMPORTED_MODULE_3___default.a.post(_CompetitionPortal_services__WEBPACK_IMPORTED_MODULE_11__["CompetitionPortalApiService"].transformMusicPpcUrl('theme/save'), payload).then(function (response) {
                if (response.data.success) {
                    resolve(response.data);
                }
                reject();
            }).catch(function () {
                reject();
            });
        });
    };
    return SkaterService;
}());



/***/ }),

/***/ "./src/js/services/UserService.ts":
/*!****************************************!*\
  !*** ./src/js/services/UserService.ts ***!
  \****************************************/
/*! exports provided: UserService */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UserService", function() { return UserService; });
/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! axios */ "./node_modules/axios/index.js");
/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(axios__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _adaptors_UserDataAdaptor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../adaptors/UserDataAdaptor */ "./src/js/adaptors/UserDataAdaptor.ts");
/* harmony import */ var _adaptors_APIAdaptors_UserAPIAdaptor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../adaptors/APIAdaptors/UserAPIAdaptor */ "./src/js/adaptors/APIAdaptors/UserAPIAdaptor.ts");
/* harmony import */ var _adaptors_APIAdaptors_SkateTestHistoryAPIAdaptor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../adaptors/APIAdaptors/SkateTestHistoryAPIAdaptor */ "./src/js/adaptors/APIAdaptors/SkateTestHistoryAPIAdaptor.ts");




var UserService = /** @class */ (function () {
    function UserService() {
    }
    /**
     * Get general information about the logged in user
     */
    UserService.getUserInfo = function (competition_id) {
        return new Promise(function (resolve, reject) {
            axios__WEBPACK_IMPORTED_MODULE_0___default.a.post('/api/user/info', {
                competition_id: competition_id
            }).then(function (response) {
                if (response.data.user) {
                    resolve(_adaptors_UserDataAdaptor__WEBPACK_IMPORTED_MODULE_1__["UserAdaptor"].adaptUser(response.data.user));
                }
                reject();
            }).catch(function () {
                reject();
            });
        });
    };
    UserService.saveProfile = function (profile_data) {
        var error_message = "Error saving profile.";
        return new Promise(function (resolve, reject) {
            axios__WEBPACK_IMPORTED_MODULE_0___default.a.post('/api/user/profile', {
                profile_data: _adaptors_APIAdaptors_UserAPIAdaptor__WEBPACK_IMPORTED_MODULE_2__["UserAPIAdaptor"].adaptEditProfileFormStateToUserProfileData(profile_data)
            }).then(function (response) {
                if (response.data.success && response.data.profile) {
                    resolve(_adaptors_APIAdaptors_UserAPIAdaptor__WEBPACK_IMPORTED_MODULE_2__["UserAPIAdaptor"].adaptUserProfileDataToUserProfile(response.data.profile));
                    return;
                }
                if (response.data.error) {
                    error_message = response.data.error;
                }
                reject(error_message);
            }).catch(function (error) {
                if (error.response.data && error.response.data.error) {
                    error_message = error.response.data.error;
                }
                reject(error_message);
            });
        });
    };
    UserService.getProfile = function () {
        return new Promise(function (resolve, reject) {
            axios__WEBPACK_IMPORTED_MODULE_0___default.a.get('/api/user/profile').then(function (response) {
                if (response.data.profile) {
                    resolve(_adaptors_APIAdaptors_UserAPIAdaptor__WEBPACK_IMPORTED_MODULE_2__["UserAPIAdaptor"].adaptUserProfileDataToUserProfile(response.data.profile));
                    return;
                }
                reject();
            }).catch(function () {
                reject();
            });
        });
    };
    UserService.saveWaivers = function (waiver_data) {
        var error_message = "Error saving waiver information.";
        return new Promise(function (resolve, reject) {
            axios__WEBPACK_IMPORTED_MODULE_0___default.a.post('/api/user/waivers', {
                waivers_data: waiver_data.map(function (user_waiver) {
                    return _adaptors_APIAdaptors_UserAPIAdaptor__WEBPACK_IMPORTED_MODULE_2__["UserAPIAdaptor"].adaptUserWaiversToUserWaiverSaveData(user_waiver);
                })
            }).then(function (response) {
                if (response.data.success) {
                    resolve();
                    return;
                }
                if (response.data.error) {
                    error_message = response.data.error;
                }
                reject(error_message);
            }).catch(function (error) {
                if (error.response.data && error.response.data.error) {
                    error_message = error.response.data.error;
                }
                reject(error_message);
            });
        });
    };
    UserService.getSkateTestHistory = function (partner_id) {
        return new Promise(function (resolve, reject) {
            var post_data = partner_id ? { partner_id: partner_id } : null;
            axios__WEBPACK_IMPORTED_MODULE_0___default.a.post('/api/user/skate-test-history', post_data).then(function (response) {
                if (response.data.skate_test_history) {
                    var userSkateTestHistory = _adaptors_APIAdaptors_SkateTestHistoryAPIAdaptor__WEBPACK_IMPORTED_MODULE_3__["SkateTestHistoryAPIAdaptor"].adaptUserSkateTestHistoryDataToUserSkateTestHistory(response.data.skate_test_history);
                    resolve(userSkateTestHistory);
                    return;
                }
                reject();
            }).catch(function () {
                reject();
            });
        });
    };
    UserService.addSkateTest = function (test_data, discipline_key) {
        var error_message = "Error saving skate test.";
        return new Promise(function (resolve, reject) {
            axios__WEBPACK_IMPORTED_MODULE_0___default.a.post('/api/user/skate-test-history/add', {
                test_data: _adaptors_APIAdaptors_SkateTestHistoryAPIAdaptor__WEBPACK_IMPORTED_MODULE_3__["SkateTestHistoryAPIAdaptor"].adaptSkateTestFormDataToIndividualSkateTestData(test_data),
                discipline_key: discipline_key
            }).then(function (response) {
                if (response.data.success && response.data.skate_test_history) {
                    var userSkateTestHistory = _adaptors_APIAdaptors_SkateTestHistoryAPIAdaptor__WEBPACK_IMPORTED_MODULE_3__["SkateTestHistoryAPIAdaptor"].adaptUserSkateTestHistoryDataToUserSkateTestHistory(response.data.skate_test_history);
                    resolve(userSkateTestHistory);
                    return;
                }
                if (response.data.error) {
                    error_message = response.data.error;
                }
                reject(error_message);
            }).catch(function (error) {
                if (error.response.data && error.response.data.error) {
                    error_message = error.response.data.error;
                }
                reject(error_message);
            });
        });
    };
    UserService.removeSkateTest = function (remove_data) {
        var error_message = "Error removing skate test.";
        return new Promise(function (resolve, reject) {
            axios__WEBPACK_IMPORTED_MODULE_0___default.a.post('/api/user/skate-test-history/remove', _adaptors_APIAdaptors_SkateTestHistoryAPIAdaptor__WEBPACK_IMPORTED_MODULE_3__["SkateTestHistoryAPIAdaptor"].adaptSkateTestRemoveAppPayloadToSkateTestRemoveAPIPayload(remove_data)).then(function (response) {
                if (response.data.success && response.data.skate_test_history) {
                    var userSkateTestHistory = _adaptors_APIAdaptors_SkateTestHistoryAPIAdaptor__WEBPACK_IMPORTED_MODULE_3__["SkateTestHistoryAPIAdaptor"].adaptUserSkateTestHistoryDataToUserSkateTestHistory(response.data.skate_test_history);
                    resolve(userSkateTestHistory);
                    return;
                }
                if (response.data.error) {
                    error_message = response.data.error;
                }
                reject(error_message);
            }).catch(function (error) {
                if (error.response.data && error.response.data.error) {
                    error_message = error.response.data.error;
                }
                reject(error_message);
            });
        });
    };
    return UserService;
}());



/***/ }),

/***/ "./src/js/store/CompetitionRegistration/CompetitionRegistrationState.ts":
/*!******************************************************************************!*\
  !*** ./src/js/store/CompetitionRegistration/CompetitionRegistrationState.ts ***!
  \******************************************************************************/
/*! exports provided: State, CompetitionRegistrationState */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "State", function() { return State; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CompetitionRegistrationState", function() { return CompetitionRegistrationState; });
/* harmony import */ var _services_CompetitionRegistrationService__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../services/CompetitionRegistrationService */ "./src/js/services/CompetitionRegistrationService.ts");

var State = /** @class */ (function () {
    function State() {
        /**
         * The list of available competitions for registration
         */
        this.available_competitions = [];
        /**
         * The currently active competition being registered for
         */
        this.active_competition = null;
        /**
         * The prices for the competition being registered for
         */
        this.active_competition_prices = null;
        /**
         * The partner event categories identified by the user as event types they'd like to register for
         */
        this.selected_partner_events = [];
        /**
         * The selection for user representation for the competition
         */
        this.representation_selection = null;
        /**
         * The list of events to display on event selection page
         */
        this.event_selection_events = [];
        /**
         * Based on selected events and partners, summary list of partner assignment including skate test requirement status
         */
        this.partner_skate_test_summary = [];
        /**
         * List of categories (and assigned partners) for partner identification
         */
        this.partner_identification = [];
        /**
         * List of categories (and assigned partners) for coach identification
         */
        this.coach_identification = [];
        /**
         * Whether the active user needs to select their representation for the active competition registration
         */
        this.representation_selection_required = true;
    }
    return State;
}());

var actions = {
    /**
     * Fetch data needed to power the Competition Overview page
     */
    fetchCompetitionOverviewScreenData: function (context) {
        return new Promise(function (resolve, reject) {
            _services_CompetitionRegistrationService__WEBPACK_IMPORTED_MODULE_0__["CompetitionRegistrationService"].fetchCompetitionOverviewScreenData().then(function (response) {
                context.commit('setActiveCompetition', response.competition);
                context.commit('setActiveCompetitionPrices', response.prices);
                resolve();
                return;
            }).catch(function () {
                reject();
            });
        });
    },
    /**
     * Fetch data needed to power the Profile page
     */
    fetchProfileScreenData: function (context) {
        return new Promise(function (resolve, reject) {
            _services_CompetitionRegistrationService__WEBPACK_IMPORTED_MODULE_0__["CompetitionRegistrationService"].fetchProfileScreenData().then(function (response) {
                context.commit('setActiveCompetition', response.competition);
                context.commit('user/setUserProfile', response.user_profile, { root: true });
                context.commit('setRepresentationSelectionRequired', response.representation_selection_required);
                context.commit('setActiveRegistrationRepresentation', response.selected_representation);
                resolve();
                return;
            }).catch(function () {
                reject();
            });
        });
    },
    /**
     * Fetch data needed to power the Skate Tests page
     */
    fetchSkateTestsScreenData: function (context) {
        return new Promise(function (resolve, reject) {
            _services_CompetitionRegistrationService__WEBPACK_IMPORTED_MODULE_0__["CompetitionRegistrationService"].fetchSkateTestsScreenData().then(function (response) {
                context.commit('setActiveCompetition', response.competition);
                context.commit('skate_test_history/setActiveSkateTestHistory', response.skate_test_history, { root: true });
                resolve();
                return;
            }).catch(function () {
                reject();
            });
        });
    },
    /**
     * Fetch data needed to power the Partner Events page
     */
    fetchPartnerEventsScreenData: function (context) {
        return new Promise(function (resolve, reject) {
            _services_CompetitionRegistrationService__WEBPACK_IMPORTED_MODULE_0__["CompetitionRegistrationService"].fetchPartnerEventsScreenData().then(function (response) {
                context.commit('setActiveCompetition', response.competition);
                context.commit('setPartnerEvents', response.selected_events);
                resolve();
            }).catch(function () {
                reject();
            });
        });
    },
    /**
     * Fetch data needed to power the Partner Identification page
     */
    fetchPartnerIdentificationScreenData: function (context) {
        return new Promise(function (resolve, reject) {
            _services_CompetitionRegistrationService__WEBPACK_IMPORTED_MODULE_0__["CompetitionRegistrationService"].fetchPartnerIdentificationScreenData().then(function (response) {
                context.commit('setActiveCompetition', response.competition);
                context.commit('setPartnerIdentification', response.partner_categories);
                context.commit('member_search/setStateOptions', response.state_form_options, { root: true });
                context.commit('user/setUserProfile', response.user_profile, { root: true });
                resolve();
                return;
            }).catch(function () {
                reject();
            });
        });
    },
    /**
     * Fetch data needed to power the Event Selection page
     */
    fetchEventSelectionScreenData: function (context) {
        return new Promise(function (resolve, reject) {
            _services_CompetitionRegistrationService__WEBPACK_IMPORTED_MODULE_0__["CompetitionRegistrationService"].fetchEventSelectionScreenData().then(function (response) {
                var available_events = response.available_events, partner_skate_test_summary = response.partner_skate_test_summary, selected_partner_events = response.selected_partner_events;
                context.commit('setActiveCompetition', response.competition);
                context.commit('setEventSelectionEvents', available_events);
                context.commit('setPartnerSkateTestSummary', partner_skate_test_summary);
                context.commit('setPartnerEvents', selected_partner_events);
                resolve();
                return;
            }).catch(function () {
                reject();
            });
        });
    },
    /**
     * Fetch data needed to power the Coach Identification page
     */
    fetchCoachIdentificationScreenData: function (context) {
        return new Promise(function (resolve, reject) {
            _services_CompetitionRegistrationService__WEBPACK_IMPORTED_MODULE_0__["CompetitionRegistrationService"].fetchCoachIdentificationScreenData().then(function (response) {
                context.commit('setActiveCompetition', response.competition);
                context.commit('setCoachIdentification', response.event_categories);
                context.commit('member_search/setStateOptions', response.state_form_options, { root: true });
                resolve();
                return;
            }).catch(function () {
                reject();
            });
        });
    },
    /**
     * Fetch data needed to power the Waivers page
     */
    fetchWaiversScreenData: function (context) {
        return new Promise(function (resolve, reject) {
            _services_CompetitionRegistrationService__WEBPACK_IMPORTED_MODULE_0__["CompetitionRegistrationService"].fetchWaiversScreenData().then(function (response) {
                context.commit('setActiveCompetition', response.competition);
                context.commit('form_options/setWaiverRelationships', response.relationships, { root: true });
                context.commit('user/setUserWaivers', response.user_waivers, { root: true });
                resolve();
            }).catch(function () {
                reject();
            });
        });
    },
    /**
     * Fetch the list of available competitions for registration
     */
    fetchCompetitions: function (context) {
        return new Promise(function (resolve, reject) {
            _services_CompetitionRegistrationService__WEBPACK_IMPORTED_MODULE_0__["CompetitionRegistrationService"].fetchRegistrationCompetitions().then(function (competitions) {
                context.commit('setAvailableCompetitions', competitions);
                resolve();
            }).catch(function () {
                reject();
            });
        });
    },
    /**
     * @deprecated (unused, subsumed)
     */
    fetchActiveCompetition: function (context) {
        return new Promise(function (resolve, reject) {
            _services_CompetitionRegistrationService__WEBPACK_IMPORTED_MODULE_0__["CompetitionRegistrationService"].fetchActiveCompetition().then(function (competition) {
                context.commit('setActiveCompetition', competition);
                resolve();
            }).catch(function () {
                reject();
            });
        });
    },
    /**
     * Submit representation selection
     */
    selectRepresentation: function (context, representation) {
        return new Promise(function (resolve, reject) {
            _services_CompetitionRegistrationService__WEBPACK_IMPORTED_MODULE_0__["CompetitionRegistrationService"].postRepresentation(representation).then(function () {
                context.commit('setActiveRegistrationRepresentation', representation);
                resolve();
            }).catch(function (error_message) {
                reject(error_message);
            });
        });
    },
    /**
     * Submit partner events selection
     */
    selectPartnerEvents: function (context, partner_event_selections) {
        return new Promise(function (resolve, reject) {
            _services_CompetitionRegistrationService__WEBPACK_IMPORTED_MODULE_0__["CompetitionRegistrationService"].selectPartnerEvents(partner_event_selections).then(function () {
                context.commit('setPartnerEvents', partner_event_selections);
                resolve();
            }).catch(function (error_message) {
                reject(error_message);
            });
        });
    },
    /**
     * Add a partner for a category
     */
    addCategoryPartner: function (context, payload) {
        return new Promise(function (resolve, reject) {
            _services_CompetitionRegistrationService__WEBPACK_IMPORTED_MODULE_0__["CompetitionRegistrationService"].addCategoryPartner(payload).then(function (partner_categories) {
                context.commit('setPartnerIdentification', partner_categories);
                resolve();
            }).catch(function (error_message) {
                reject(error_message);
            });
        });
    },
    /**
     * Remove a partner from a category
     */
    removeCategoryPartner: function (context, payload) {
        return new Promise(function (resolve, reject) {
            _services_CompetitionRegistrationService__WEBPACK_IMPORTED_MODULE_0__["CompetitionRegistrationService"].removeCategoryPartner(payload).then(function (partner_categories) {
                context.commit('setPartnerIdentification', partner_categories);
                resolve();
            }).catch(function (error_message) {
                reject(error_message);
            });
        });
    },
    /**
     * Select an event for registration
     */
    addEvent: function (context, event) {
        return new Promise(function (resolve, reject) {
            _services_CompetitionRegistrationService__WEBPACK_IMPORTED_MODULE_0__["CompetitionRegistrationService"].addEvent(event).then(function (response) {
                var available_events = response.available_events, partner_skate_test_summary = response.partner_skate_test_summary;
                context.commit('setEventSelectionEvents', available_events);
                context.commit('setPartnerSkateTestSummary', partner_skate_test_summary);
                resolve();
            }).catch(function (error) {
                reject(error);
            });
        });
    },
    /**
     * Remove a selected event from registration
     */
    removeEvent: function (context, event) {
        return new Promise(function (resolve, reject) {
            _services_CompetitionRegistrationService__WEBPACK_IMPORTED_MODULE_0__["CompetitionRegistrationService"].removeEvent(event).then(function (response) {
                var available_events = response.available_events, partner_skate_test_summary = response.partner_skate_test_summary;
                context.commit('setEventSelectionEvents', available_events);
                context.commit('setPartnerSkateTestSummary', partner_skate_test_summary);
                resolve();
                return;
            }).catch(function (error) {
                reject(error);
            });
        });
    },
    /**
     * Remove a partner skate test
     */
    removePartnerSkateTest: function (context, payload) {
        return new Promise(function (resolve, reject) {
            _services_CompetitionRegistrationService__WEBPACK_IMPORTED_MODULE_0__["CompetitionRegistrationService"].removePartnerSkateTest(payload).then(function (result) {
                context.commit('skate_test_history/setActiveSkateTestHistory', result.skate_test_history, { root: true });
                context.commit('setPartnerSkateTestSummary', result.partner_skate_test_summary);
                resolve();
            }).catch(function (error_message) {
                reject(error_message);
            });
        });
    },
    /**
     * Add a partner skate test
     */
    addPartnerSkateTest: function (context, payload) {
        return new Promise(function (resolve, reject) {
            _services_CompetitionRegistrationService__WEBPACK_IMPORTED_MODULE_0__["CompetitionRegistrationService"].addPartnerSkateTest(payload).then(function (result) {
                context.commit('skate_test_history/setActiveSkateTestHistory', result.skate_test_history, { root: true });
                context.commit('setPartnerSkateTestSummary', result.partner_skate_test_summary);
                resolve();
            }).catch(function (error_message) {
                reject(error_message);
            });
        });
    },
    /**
     * Add a coach for a category
     */
    addCategoryCoach: function (context, payload) {
        return new Promise(function (resolve, reject) {
            _services_CompetitionRegistrationService__WEBPACK_IMPORTED_MODULE_0__["CompetitionRegistrationService"].addCategoryCoach(payload).then(function (event_categories) {
                context.commit('setCoachIdentification', event_categories);
                resolve();
            }).catch(function (error_message) {
                reject(error_message);
            });
        });
    },
    /**
     * Replace a coach for a category
     */
    replaceCategoryCoach: function (context, payload) {
        return new Promise(function (resolve, reject) {
            _services_CompetitionRegistrationService__WEBPACK_IMPORTED_MODULE_0__["CompetitionRegistrationService"].replaceCategoryCoach(payload).then(function (event_categories) {
                context.commit('setCoachIdentification', event_categories);
                resolve();
            }).catch(function (error_message) {
                reject(error_message);
            });
        });
    },
    /**
     * Remove a coach for a category
     */
    removeCategoryCoach: function (context, payload) {
        return new Promise(function (resolve, reject) {
            _services_CompetitionRegistrationService__WEBPACK_IMPORTED_MODULE_0__["CompetitionRegistrationService"].removeCategoryCoach(payload).then(function (event_categories) {
                context.commit('setCoachIdentification', event_categories);
                resolve();
            }).catch(function (error_message) {
                reject(error_message);
            });
        });
    },
};
var getters = {
    competition_list: function (state) {
        return state.available_competitions;
    },
    active_competition: function (state) {
        return state.active_competition;
    },
    active_prices: function (state) {
        return state.active_competition_prices;
    },
    selected_representation: function (state) {
        return state.representation_selection;
    },
    event_selection_events: function (state) {
        return state.event_selection_events;
    },
    partner_skate_test_summary: function (state) {
        return state.partner_skate_test_summary;
    },
    partner_identification: function (state) {
        return state.partner_identification;
    },
    coach_identification: function (state) {
        return state.coach_identification;
    },
    representation_selection_required: function (state) {
        return state.representation_selection_required;
    }
};
var mutations = {
    setAvailableCompetitions: function (state, competitions) {
        state.available_competitions = competitions;
    },
    setActiveCompetition: function (state, competition) {
        state.active_competition = competition;
    },
    setActiveCompetitionPrices: function (state, prices) {
        state.active_competition_prices = prices;
    },
    setActiveRegistrationRepresentation: function (state, representation) {
        state.representation_selection = representation;
    },
    setPartnerEvents: function (state, partner_events) {
        state.selected_partner_events = partner_events;
    },
    setPartnerIdentification: function (state, partner_identification) {
        state.partner_identification = partner_identification;
    },
    setEventSelectionEvents: function (state, events) {
        state.event_selection_events = events;
    },
    setPartnerSkateTestSummary: function (state, summary) {
        state.partner_skate_test_summary = summary;
    },
    setCoachIdentification: function (state, coach_identification) {
        state.coach_identification = coach_identification;
    },
    setRepresentationSelectionRequired: function (state, is_required) {
        state.representation_selection_required = is_required;
    }
};
var CompetitionRegistrationState = {
    namespaced: true,
    state: new State(),
    actions: actions,
    getters: getters,
    mutations: mutations
};


/***/ }),

/***/ "./src/js/store/Modules/AppState.ts":
/*!******************************************!*\
  !*** ./src/js/store/Modules/AppState.ts ***!
  \******************************************/
/*! exports provided: State, AppState */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "State", function() { return State; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AppState", function() { return AppState; });
/* harmony import */ var _services_AppService__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../services/AppService */ "./src/js/services/AppService.ts");
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");


/**
 * The reactive state of competitions
 */
var State = /** @class */ (function () {
    function State() {
        this.active_page_back_link = null;
        this.show_nav_border = true;
        this.show_cart_status = true;
        this.checkout_active = false;
        this.ems_support_issue_type_options = [];
        this.categorized_support_documents = [];
        this.confirm_action_overlay = null;
        this.notice = null;
    }
    return State;
}());

/**
 * Accessors for computed competition state properties
 */
var getters = {
    ems_support_issue_type_options: function (state) {
        return state.ems_support_issue_type_options;
    },
    categorized_support_documents: function (state) {
        return state.categorized_support_documents;
    }
};
/**
 * Perform (potentially async) actions with the state
 */
var actions = {
    /**
     * Retrieve the EMS Support Form input options
     */
    fetchEMSSupportFormOptions: function (context) {
        return new Promise(function (resolve, reject) {
            _services_AppService__WEBPACK_IMPORTED_MODULE_0__["AppService"].fetchEMSSupportFormOptions().then(function (form_options) {
                context.commit('setEMSSupportFormOptions', form_options);
                resolve();
            }).catch(function () {
                reject();
            });
        });
    },
    /**
     * Submit the EMS Support Form
     */
    submitEMSSupportForm: function (context, form_data) {
        return new Promise(function (resolve, reject) {
            _services_AppService__WEBPACK_IMPORTED_MODULE_0__["AppService"].submitEMSSupport(form_data).then(function (response) {
                resolve(response);
            }).catch(function () {
                reject();
            });
        });
    },
    /**
     * Get Support Documents Data
     */
    fetchSupportDocuments: function (context) {
        return new Promise(function (resolve, reject) {
            _services_AppService__WEBPACK_IMPORTED_MODULE_0__["AppService"].fetchCategorizedSupportDocuments().then(function (categorized_support_documents) {
                context.commit('setCategorizedSupportDocuments', categorized_support_documents);
                resolve();
            }).catch(function () {
                reject();
            });
        });
    },
    /**
     * Launch a confirm action
     */
    confirmAction: function (context, payload) {
        context.commit('setConfirmAction', payload);
    },
    /**
     * Cancel the confirmation action
     */
    cancelConfirmAction: function (context) {
        context.commit('setConfirmAction', null);
    },
    /**
     * Confirm the active confirm action
     */
    confirmConfirmAction: function (_a) {
        var commit = _a.commit, state = _a.state;
        return new Promise(function (resolve) {
            if (state.confirm_action_overlay && typeof state.confirm_action_overlay.action === 'function') {
                var action = state.confirm_action_overlay.action();
                if (state.confirm_action_overlay.is_promise) {
                    action
                        .then(function () {
                        commit('setConfirmAction', null);
                        resolve();
                    })
                        .catch(function () {
                        commit('setConfirmAction', null);
                        resolve();
                    });
                    return;
                }
            }
            commit('setConfirmAction', null);
            resolve();
        });
    },
    /**
     * Dismiss the current app notice
     */
    dismissNotice: function (context) {
        var state_notice = context.state.notice;
        if (state_notice
            && state_notice.dismiss_override
            && typeof state_notice.dismiss_override === 'function') {
            state_notice.dismiss_override();
            return;
        }
        context.commit('setNotice', null);
    }
};
/**
 * Change reactive data
 */
var mutations = {
    /**
     * Set the back link for the active page
     */
    setActivePageBackLink: function (state, payload) {
        state.active_page_back_link = payload;
    },
    /**
     * Remove the bottom border on the app navbar
     */
    removeNavBorder: function (state) {
        state.show_nav_border = false;
    },
    /**
     * Hide the cart status indicator
     */
    hideCartStatus: function (state) {
        state.show_cart_status = false;
    },
    /**
     * Set that checkout page is active
     * Used in logic to hide app nav menu
     */
    setCheckoutActive: function (state) {
        state.checkout_active = true;
    },
    /**
     * Set the EMS Support form options in state
     */
    setEMSSupportFormOptions: function (state, form_options) {
        state.ems_support_issue_type_options = form_options;
    },
    /**
     * Set the categorized Support Documents in state
     */
    setCategorizedSupportDocuments: function (state, categorized_support_documents) {
        state.categorized_support_documents = categorized_support_documents;
    },
    /**
     * Set the active confirm action overlay configuration
     */
    setConfirmAction: function (state, payload) {
        state.confirm_action_overlay = payload;
    },
    /**
     * Set the app level notice in state
     */
    setNotice: function (state, payload) {
        if (payload === null) {
            state.notice = payload;
            return;
        }
        var notice_content = '';
        if (payload && payload.notice instanceof vue__WEBPACK_IMPORTED_MODULE_1__["default"]) {
            var vue_payload = payload.notice;
            vue_payload.$mount();
            notice_content = vue_payload.$el.innerHTML;
            vue_payload.$destroy();
        }
        if (payload && typeof payload.notice === 'string') {
            notice_content = payload.notice;
        }
        state.notice = {
            notice: notice_content,
            dismiss_override: payload.dismiss_override,
            is_danger: payload.is_danger || false
        };
    }
};
/**
 * Export the state module
 */
var AppState = {
    namespaced: true,
    state: new State(),
    getters: getters,
    mutations: mutations,
    actions: actions
};


/***/ }),

/***/ "./src/js/store/Modules/CartState.ts":
/*!*******************************************!*\
  !*** ./src/js/store/Modules/CartState.ts ***!
  \*******************************************/
/*! exports provided: State, CartState */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "State", function() { return State; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CartState", function() { return CartState; });
/* harmony import */ var _models_Cart_Cart__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../models/Cart/Cart */ "./src/js/models/Cart/Cart.ts");
/* harmony import */ var _services_CartService__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../services/CartService */ "./src/js/services/CartService.ts");
/* harmony import */ var _models_Cart_CartAdaptor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../models/Cart/CartAdaptor */ "./src/js/models/Cart/CartAdaptor.ts");
var __assign = (undefined && undefined.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};



/**
 * The reactive state of competitions
 */
var State = /** @class */ (function () {
    function State() {
        this.cart = new _models_Cart_Cart__WEBPACK_IMPORTED_MODULE_0__["Cart"]([], 0);
        this.cart_loaded = false;
    }
    return State;
}());

/**
 * Accessors for computed competition state properties
 */
var getters = {
    contains_package: function (state) {
        return function (credit_package) {
            return state.cart.containsPackage(credit_package);
        };
    }
};
/**
 * Perform (potentially async) actions with the state
 */
var actions = {
    /**
     * Add a session to the cart
     */
    addSession: function (context, payload) {
        return new Promise(function (resolve, reject) {
            var competition = context.rootGetters['competitions/active_competition'];
            _services_CartService__WEBPACK_IMPORTED_MODULE_1__["CartService"].addSession(payload.session, payload.cost).then(function () {
                function addSessionToAppCart() {
                    context.commit('addSessionToCart', __assign({}, payload, { competition_name: 'name' in competition ? competition.name : "" }));
                }
                resolve(addSessionToAppCart);
            }).catch(function () {
                reject();
            });
        });
    },
    removeItem: function (context, item) {
        return new Promise(function (resolve, reject) {
            if (item.cart_item_type_key === 'fee') {
                reject();
                return;
            }
            if (['registration_fee', 'series_registration_fee', 'team_registration_fee'].indexOf(item.cart_item_type_key) !== -1) {
                context.dispatch('removeRegistrationFee', item).then(function (result) {
                    resolve(result);
                }).catch(function () {
                    reject();
                });
                return;
            }
            if (item.cart_item_type_key === 'session') {
                context.dispatch('removeSession', item).then(function (result) {
                    resolve(result);
                }).catch(function () {
                    reject();
                });
                return;
            }
            if (item.cart_item_type_key === 'credit') {
                context.dispatch('removeCredit', item).then(function (result) {
                    resolve(result);
                }).catch(function () {
                    reject();
                });
                return;
            }
            if (item.cart_item_type_key === 'credit_package') {
                context.dispatch('removeCreditPackage', item).then(function (result) {
                    resolve(result);
                }).catch(function () {
                    reject();
                });
                return;
            }
            reject();
        });
    },
    /**
     * Remove a session from the cart
     */
    removeRegistrationFee: function (context, item) {
        return new Promise(function (resolve, reject) {
            _services_CartService__WEBPACK_IMPORTED_MODULE_1__["CartService"].removeRegistrationItem(item).then(function (cart) {
                function replaceCart() {
                    context.commit('loadCart', cart);
                    context.commit('skater/setSkaterCart', cart, { root: true });
                }
                resolve(replaceCart);
            }).catch(function () {
                reject();
            });
        });
    },
    /**
     * Remove a session from the cart
     */
    removeSession: function (context, session) {
        return new Promise(function (resolve, reject) {
            _services_CartService__WEBPACK_IMPORTED_MODULE_1__["CartService"].removeSession(session).then(function (cost_properties) {
                function removeSessionFromAppCart() {
                    context.commit('removeSessionFromCart', session.session.id);
                    context.commit('setCartCostProperties', cost_properties);
                }
                resolve(removeSessionFromAppCart);
            }).catch(function () {
                reject();
            });
        });
    },
    /**
     * Retrieve the saved cart and all associated data within it
     */
    fetchCart: function (context) {
        context.state.cart_loaded = false;
        return new Promise(function (resolve, reject) {
            _services_CartService__WEBPACK_IMPORTED_MODULE_1__["CartService"].fetchCart().then(function (cart) {
                context.commit('loadCart', cart);
                context.commit('skater/setSkaterCart', cart, { root: true });
                resolve();
            }).catch(function () {
                reject();
            });
        });
    },
    /**
     * [2020-07-14] - Add credits to team cart
     */
    addTeamCredits: function (context, params) {
        return new Promise(function (resolve, reject) {
            _services_CartService__WEBPACK_IMPORTED_MODULE_1__["CartService"].addTeamCredits(params).then(function () {
                context.commit('addCreditsToCart', params.credits);
                context.commit('addCreditPackagesToCart', params.packages);
                resolve();
            }).catch(function () {
                reject();
            });
        });
    },
    /**
     * Add credits to the cart
     */
    addCredits: function (context, params) {
        return new Promise(function (resolve, reject) {
            _services_CartService__WEBPACK_IMPORTED_MODULE_1__["CartService"].addCredits(params).then(function () {
                context.commit('addCreditsToCart', params.credits);
                context.commit('addCreditPackagesToCart', params.packages);
                resolve();
            }).catch(function () {
                reject();
            });
        });
    },
    /**
     * Remove a credit from the cart
     */
    removeCredit: function (context, credit) {
        return new Promise(function (resolve, reject) {
            _services_CartService__WEBPACK_IMPORTED_MODULE_1__["CartService"].removeCredit(credit).then(function (cost_properties) {
                function resolution() {
                    context.commit('removeCreditFromCart', credit);
                    context.commit('setCartCostProperties', cost_properties);
                }
                resolve(resolution);
            }).catch(function () {
                reject();
            });
        });
    },
    removeCreditPackage: function (context, credit_package) {
        return new Promise(function (resolve, reject) {
            _services_CartService__WEBPACK_IMPORTED_MODULE_1__["CartService"].removeCreditPackage(credit_package).then(function (cost_properties) {
                function resolution() {
                    context.commit('removeCreditPackageFromCart', credit_package);
                    context.commit('setCartCostProperties', cost_properties);
                }
                resolve(resolution);
            }).catch(function () {
                reject();
            });
        });
    }
};
/**
 * Change reactive data
 */
var mutations = {
    addSessionToCart: function (state, payload) {
        state.cart.addSession(_models_Cart_CartAdaptor__WEBPACK_IMPORTED_MODULE_2__["CartAdaptor"].adaptCartSessionPayloadCartSession(payload));
    },
    loadCart: function (state, cart) {
        state.cart = cart;
        state.cart_loaded = true;
    },
    removeSessionFromCart: function (state, session_id) {
        state.cart.removeSession(session_id);
    },
    addCreditsToCart: function (state, credits) {
        state.cart.addCredits(credits);
    },
    addCreditPackagesToCart: function (state, packages) {
        state.cart.addPackages(packages);
    },
    removeCreditFromCart: function (state, credit) {
        state.cart.removeCredit(credit);
    },
    removeCreditPackageFromCart: function (state, credit_package) {
        state.cart.removeCreditPackage(credit_package);
    },
    setCartCostProperties: function (state, cost_properties) {
        state.cart.setCostProperties(cost_properties);
    }
};
/**
 * Export the state module
 */
var CartState = {
    namespaced: true,
    state: new State(),
    getters: getters,
    mutations: mutations,
    actions: actions
};


/***/ }),

/***/ "./src/js/store/Modules/CoachState.ts":
/*!********************************************!*\
  !*** ./src/js/store/Modules/CoachState.ts ***!
  \********************************************/
/*! exports provided: State, CoachState */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "State", function() { return State; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CoachState", function() { return CoachState; });
/* harmony import */ var _services_CoachService__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../services/CoachService */ "./src/js/services/CoachService.ts");
/* harmony import */ var _models_Schedule_CoachSkatersSchedule__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../models/Schedule/CoachSkatersSchedule */ "./src/js/models/Schedule/CoachSkatersSchedule.ts");


var State = /** @class */ (function () {
    function State() {
        this.active_competition_skaters = [];
        this.active_competition_skater_schedule = _models_Schedule_CoachSkatersSchedule__WEBPACK_IMPORTED_MODULE_1__["CoachSkatersSchedule"].blank();
    }
    return State;
}());

var actions = {
    /**
     * Fetch the list of coached skaters for the competition, along with their Music and PPC Status
     *
     * @deprecated 2020-07-28
     */
    fetchCompetitionSkaters: function (context, competition_id) {
        return new Promise(function (resolve, reject) {
            _services_CoachService__WEBPACK_IMPORTED_MODULE_0__["CoachService"].fetchCompetitionSkaters(competition_id).then(function (result) {
                context.commit('setCompetitionSkaters', result);
                resolve();
            }).catch(function () {
                reject();
            });
        });
    },
    /**
     * Fetch the CoachSkaterSchedule for a competition
     *
     * @deprecated 2020-07-29
     */
    fetchCompetitionSkatersSchedule: function (context, competition_id) {
        return new Promise(function (resolve, reject) {
            _services_CoachService__WEBPACK_IMPORTED_MODULE_0__["CoachService"].fetchCompetitionSkaterSchedule(competition_id).then(function (result) {
                context.commit('setCompetitionSkaterSchedule', result);
                resolve();
            }).catch(function () {
                reject();
            });
        });
    }
};
var getters = {
    active_competition_skater_sessions: function (state) {
        return state.active_competition_skater_schedule.sessions;
    },
    /**
     * Get the coached skaters for a given Session within the active schedule
     */
    session_skaters: function (state) {
        return function (session_id) {
            return state.active_competition_skater_schedule.getSessionSkaters(session_id);
        };
    }
};
var mutations = {
    setCompetitionSkaters: function (state, skaters) {
        state.active_competition_skaters = skaters;
    },
    setCompetitionSkaterSchedule: function (state, schedule) {
        state.active_competition_skater_schedule = schedule;
    }
};
var CoachState = {
    namespaced: true,
    state: new State(),
    actions: actions,
    getters: getters,
    mutations: mutations
};


/***/ }),

/***/ "./src/js/store/Modules/CompetitionsState.ts":
/*!***************************************************!*\
  !*** ./src/js/store/Modules/CompetitionsState.ts ***!
  \***************************************************/
/*! exports provided: State, CompetitionState */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "State", function() { return State; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CompetitionState", function() { return CompetitionState; });
/* harmony import */ var _models_Competition_CompetitionInformation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../models/Competition/CompetitionInformation */ "./src/js/models/Competition/CompetitionInformation.ts");
/* harmony import */ var _models_Competition_CompetitionSchedule__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../models/Competition/CompetitionSchedule */ "./src/js/models/Competition/CompetitionSchedule.ts");
/* harmony import */ var _services_CompetitionService__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../services/CompetitionService */ "./src/js/services/CompetitionService.ts");



/**
 * The reactive state of competitions
 */
var State = /** @class */ (function () {
    function State() {
        this.active_competition_id = -1;
        this.active_competition_page_heading = null;
        /**
         * Override to supersede whether active competition schedule is available.
         *
         * Used to determine schedule availability for competitions outside of competitions in user competition list
         */
        /* eslint-disable-next-line */
        this.active_competition_schedule_available_override = undefined;
        /**
         * 2020-07-29
         */
        /* eslint-disable-next-line */
        this.active_competition_my_schedule_available_override = undefined;
        this.competition_list = [];
        this.competition_list_search = [];
        this.competitions_loaded = false;
        this.schedule_loaded = false;
        this.active_schedule = new _models_Competition_CompetitionSchedule__WEBPACK_IMPORTED_MODULE_1__["CompetitionSchedule"]([], [], []);
        this.active_competition_events = [];
        this.competition_information = _models_Competition_CompetitionInformation__WEBPACK_IMPORTED_MODULE_0__["CompetitionInformation"].blank();
        /**
         * @deprecated 2020-07-01; see: CompetitionPortalState
         */
        this.competition_contacts = [];
        this.view_competition_competition = null;
    }
    return State;
}());

/**
 * Accessors for computed competition state properties
 */
var getters = {
    /**
     * Get the active competition
     */
    active_competition: function (state) {
        for (var i = 0; i < state.competition_list.length; i++) {
            var competition = state.competition_list[i];
            if (competition.id == state.active_competition_id) {
                return competition;
            }
        }
        return {};
    },
    /**
     * The active source for the competition page heading.
     *
     * Precedence order:
     *
     * 1. Active Competition in State
     * 2. Specifically Fetched Heading Data
     * 3. Null
     */
    active_competition_heading: function (state, getters) {
        var state_active_competition = getters.active_competition;
        if (state_active_competition && state_active_competition.id) {
            return state_active_competition;
        }
        if (state.active_competition_page_heading) {
            return state.active_competition_page_heading;
        }
        return null;
    },
    /**
     * The action documents for the active competition
     *
     * @deprecated - 2020-06-17
     */
    active_competition_action_documents: function (getters) {
        var competition_information = getters.competition_information;
        if (!competition_information) {
            return [];
        }
        return competition_information.competition_documents.action_documents;
    },
    /**
     * The reference documents for the active competition
     *
     * @deprecated - 2020-06-17
     */
    active_competition_reference_documents: function (getters) {
        var competition_information = getters.competition_information;
        if (!competition_information) {
            return [];
        }
        return competition_information.competition_documents.reference_documents;
    },
    /**
     * Whether the schedule for the active competition is available
     *
     * 1. If active competition in state, use its property
     * 2. If override set in state, use it.
     * 3. Default to true.
     */
    active_competition_schedule_available: function (state, getters) {
        var active_competition = getters.active_competition;
        if (typeof active_competition.schedule_available !== 'undefined') {
            return active_competition.schedule_available;
        }
        if (typeof state.active_competition_schedule_available_override !== 'undefined') {
            return state.active_competition_schedule_available_override;
        }
        return true;
    },
    /**
     * Get the active PI sales window
     */
    active_sales_window: function (state, getters, rootState) {
        if (rootState.competition_portal.practice_ice && rootState.competition_portal.practice_ice.active_sales_window) {
            return rootState.competition_portal.practice_ice.active_sales_window;
        }
        var active_competition = getters.active_competition;
        if (active_competition) {
            return active_competition._active_sales_window;
        }
        return 'none';
    },
    /**
     * Determine if a Competition is active based on its id
     */
    isActiveCompetition: function (state) {
        return function (id) {
            return state.active_competition_id == id;
        };
    },
    /**
     * Get the types of credits that can be purchased.
     */
    purchasable_credit_types: function (state, getters) {
        var active_sales_window = getters.active_sales_window;
        if (active_sales_window === 'pre_purchase') {
            return ['upi', 'opi', 'wu'];
        }
        return getters.non_selectable_session_types;
    },
    /**
     * Get the selectable session types for the current competition
     */
    selectable_session_types: function (state) {
        return state.competition_information.schedulable_session_types;
    },
    /**
     * Get the non-selectable session types for the current competition
     */
    non_selectable_session_types: function (state) {
        var all_types = ['wu', 'opi', 'upi'];
        var schedulable_types = state.competition_information.schedulable_session_types;
        return all_types.filter(function (type) {
            return schedulable_types.indexOf(type) === -1;
        });
    },
    /**
     * Get the competition information
     */
    competition_information: function (state) {
        return state.competition_information;
    },
    /**
     * Get music and PPC information
     */
    music_and_ppc_information: function (state) {
        return state.competition_information.music_and_ppc_information;
    }
};
/**
 * Perform (potentially async) actions with the state
 */
var actions = {
    /**
     * Get the competition list and store it in state
     */
    fetchCompetitionList: function (context) {
        return new Promise(function (resolve, reject) {
            _services_CompetitionService__WEBPACK_IMPORTED_MODULE_2__["default"].getCompetitionList()
                .then(function (result) {
                context.commit('setCompetitionList', result);
                resolve();
            })
                .catch(function () {
                reject();
            });
        });
    },
    /**
     * Get the competition list for competition search and store it in state
     */
    fetchCompetitionListSearch: function (context) {
        return new Promise(function (resolve, reject) {
            _services_CompetitionService__WEBPACK_IMPORTED_MODULE_2__["default"].getCompetitionListSearch()
                .then(function (result) {
                context.commit('setCompetitionListSearch', result);
                resolve();
            })
                .catch(function () {
                reject();
            });
        });
    },
    /**
     * Get competition information and store it in state
     *
     * @deprecated 2020-07-29
     */
    fetchCompetitionInformation: function (context, competition_id) {
        return new Promise(function (resolve, reject) {
            _services_CompetitionService__WEBPACK_IMPORTED_MODULE_2__["default"].getCompetitionInformation(competition_id)
                .then(function (result) {
                context.commit('setCompetitionInformation', {
                    result: result,
                    competition: context.getters.active_competition
                });
                resolve();
            })
                .catch(function () {
                reject();
            });
        });
    },
    /**
     * Get the page heading data for a competition
     */
    fetchCompetitionPageHeading: function (context, competition_id) {
        return new Promise(function (resolve, reject) {
            _services_CompetitionService__WEBPACK_IMPORTED_MODULE_2__["default"].fetchCompetitionPageHeading(competition_id)
                .then(function (response) {
                context.commit('setActiveCompetitionPageHeading', response);
                resolve();
            })
                .catch(function () {
                reject();
            });
        });
    },
    /**
     * Get a competition's schedule and store it in state
     *
     * @deprecated 2020-07-29
     */
    fetchCompetitionSchedule: function (context, competition_id) {
        context.state.schedule_loaded = false;
        return new Promise(function (resolve, reject) {
            _services_CompetitionService__WEBPACK_IMPORTED_MODULE_2__["default"].getCompetitionSchedule(competition_id)
                .then(function (response) {
                if (response.schedule) {
                    var state_args = {
                        result: response.schedule,
                        competition: context.getters.active_competition
                    };
                    context.commit('setCompetitionSchedule', state_args);
                }
                context.commit('setCompetitionScheduleAvailableOverride', response.schedule_available);
                resolve();
            })
                .catch(function () {
                reject();
            });
        });
    },
    /**
     * Retrieve a competition's contacts and store them in state
     *
     * If a competition heading is provided by the API, use it in the resolution body, but do not store in state
     *
     * @deprecated 2020-07-01; see: CompetitionPortalState.fetchCompetitionContacts
     */
    fetchCompetitionContacts: function (context, competition_id) {
        return new Promise(function (resolve, reject) {
            _services_CompetitionService__WEBPACK_IMPORTED_MODULE_2__["default"].getCompetitionContacts(competition_id)
                .then(function (result) {
                context.commit('setCompetitionContacts', result.contacts);
                resolve();
            })
                .catch(function () {
                reject();
            });
        });
    },
    /**
     * Fetch data for the view competition page for a competition id
     *
     * @deprecated  2020-06-24
     */
    fetchViewCompetitionCompetition: function (context, competition_id) {
        return new Promise(function (resolve, reject) {
            _services_CompetitionService__WEBPACK_IMPORTED_MODULE_2__["default"].fetchViewCompetitionCompetition(competition_id)
                .then(function (result) {
                context.commit('setViewCompetitionCompetition', result);
                resolve();
            })
                .catch(function () {
                reject();
            });
        });
    },
    /**
     * Toggle the completion state on a competition document
     *
     * @deprecated - 2020-06-17
     */
    toggleCompetitionDocumentCompletion: function (context, document) {
        return new Promise(function (resolve, reject) {
            _services_CompetitionService__WEBPACK_IMPORTED_MODULE_2__["default"].updateCompetitionDocumentCompletionStatus(document, context.state.active_competition_id)
                .then(function () {
                var action_documents_list = context.getters.active_competition_action_documents;
                for (var i = 0; i < action_documents_list.length; i++) {
                    var state_document = action_documents_list[i];
                    if (document.id === state_document.id) {
                        context.commit('updateDocumentCompletion', {
                            document: state_document,
                            is_complete: !document.is_complete
                        });
                        break;
                    }
                }
                resolve();
            })
                .catch(function (e) {
                reject(e);
            });
        });
    }
};
/**
 * Change reactive data
 */
var mutations = {
    /**
     * Set the active competition id
     */
    setActiveID: function (state, payload) {
        state.active_competition_id = parseInt(payload);
    },
    /**
     * Set active competition heading in state
     */
    setActiveCompetitionPageHeading: function (state, payload) {
        state.active_competition_page_heading = payload;
    },
    /**
     * Set the stored competition list
     */
    setCompetitionList: function (state, payload) {
        state.competitions_loaded = true;
        state.competition_list = payload;
    },
    /**
     * Set the stored search competition list
     */
    setCompetitionListSearch: function (state, payload) {
        state.competition_list_search = payload;
    },
    /**
     * Set the stored competition info
     *
     * @refactor: Appending to active competition - determine if used, valuable, or necessary and remove if not - this is used on comp info page
     */
    setCompetitionInformation: function (state, payload) {
        if (payload.competition && 'setInformation' in payload.competition) {
            // eslint-disable-next-line
            payload.competition.setInformation(payload.result);
        }
        state.competition_information = payload.result;
        state.active_competition_events = payload.result.events;
    },
    /**
     * Set the stored competition schedule
     *
     * @refactor: Appending to active competition - determine if used, valuable, or necessary and remove if not - this is used on comp info page
     */
    setCompetitionSchedule: function (state, payload) {
        state.active_schedule = payload.result;
        if (payload.competition && 'setSchedule' in payload.competition) {
            // eslint-disable-next-line
            payload.competition.setSchedule(payload.result);
        }
        state.schedule_loaded = true;
    },
    /**
     * Set override in state where competition schedule is available for the active competition
     */
    setCompetitionScheduleAvailableOverride: function (state, payload) {
        state.active_competition_schedule_available_override = payload;
    },
    /**
     * Set override in state where competition schedule is available for the active competition
     */
    setCompetitionMyScheduleAvailableOverride: function (state, payload) {
        state.active_competition_my_schedule_available_override = payload;
    },
    /**
     * Set the competition contacts in state
     *
     * @deprecated 2020-07-01; see: CompetitionPortalState
     */
    setCompetitionContacts: function (state, competition_contacts) {
        state.competition_contacts = competition_contacts;
    },
    /**
     * Set view competition competition data in state
     */
    setViewCompetitionCompetition: function (state, competition) {
        state.view_competition_competition = competition;
    },
    /**
     * Set volunteer information field on view competition
     */
    setViewCompetitionVolunteerCtaConfiguration: function (state, payload) {
        if (state.view_competition_competition) {
            state.view_competition_competition.volunteer_cta_configuration = payload;
        }
    },
    /**
     * Set user navigation on view competition
     */
    setViewCompetitionUserNavigation: function (state, payload) {
        if (state.view_competition_competition) {
            state.view_competition_competition.user_navigation = payload;
        }
    },
    /**
     * Update the completion state on a competition document in state
     *
     * @deprecated 2020-06-17
     */
    updateDocumentCompletion: function (state, payload) {
        payload.document.is_complete = payload.is_complete;
    }
};
/**
 * Export the state module
 */
var CompetitionState = {
    namespaced: true,
    state: new State(),
    getters: getters,
    mutations: mutations,
    actions: actions
};


/***/ }),

/***/ "./src/js/store/Modules/FormOptionsState.ts":
/*!**************************************************!*\
  !*** ./src/js/store/Modules/FormOptionsState.ts ***!
  \**************************************************/
/*! exports provided: State, FormOptionsState */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "State", function() { return State; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FormOptionsState", function() { return FormOptionsState; });
/* harmony import */ var _services_FormOptionService__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../services/FormOptionService */ "./src/js/services/FormOptionService.ts");

/**
 * Config outlining fetchers that complete the needs of child fetchers
 */
var FETCHER_CONFIG = {
    create_account: {
        children: [
            'states',
            'countries',
            'provinces',
            'federations',
            'categorized_skate_test_options',
        ]
    },
    edit_profile: {
        children: [
            'user_prefixes',
            'user_suffixes',
            'mobile_carriers'
        ]
    },
    billing_address: {
        children: [
            'states',
            'provinces',
            'billing_countries'
        ]
    }
};
var State = /** @class */ (function () {
    function State() {
        this.states = [];
        this.countries = [];
        this.federations = [];
        this.provinces = [];
        this.categorized_skate_test_options = {
            free_skating: [],
            pair: [],
            dance: [],
            free_dance: [],
            figure: [],
        };
        this.skate_test_disciplines = [];
        this.user_prefixes = [];
        this.user_suffixes = [];
        this.mobile_carriers = [];
        this.waiver_relationships = [];
        this.clubs = [];
        this.billing_countries = [];
        this.volunteer_request_experiences = [];
        /**
         * Fetchers in the process of retrieving data
         */
        this.active_fetchers = [];
        /**
         * Fetchers that have completed the process of retrieving data
         */
        this.completed_fetchers = [];
    }
    return State;
}());

var actions = {
    /**
     * Fetch form options for all create account screens
     */
    fetchCreateAccountOptions: function (context) {
        var active_key = 'create_account';
        return new Promise(function (resolve, reject) {
            if (context.getters['block_fetcher'](active_key)) {
                resolve();
                return;
            }
            context.commit('addActiveFetcher', active_key);
            _services_FormOptionService__WEBPACK_IMPORTED_MODULE_0__["FormOptionService"].GetCreateAccountOptions().then(function (result) {
                context.commit('removeActiveFetcher', active_key);
                context.commit('setCreateAccountOptions', result);
                context.commit('addCompletedFetcher', active_key);
                resolve();
            }).catch(function () {
                context.commit('removeActiveFetcher', active_key);
                reject();
            });
        });
    },
    fetchBillingAddressOptions: function (context) {
        var active_key = 'billing_address';
        return new Promise(function (resolve, reject) {
            if (context.getters['block_fetcher'](active_key)) {
                resolve();
                return;
            }
            context.commit('addActiveFetcher', active_key);
            _services_FormOptionService__WEBPACK_IMPORTED_MODULE_0__["FormOptionService"].getBillingAddressOptions().then(function (result) {
                context.commit('removeActiveFetcher', active_key);
                context.commit('setBillingAddressOptions', result);
                context.commit('addCompletedFetcher', active_key);
                resolve();
            }).catch(function () {
                context.commit('removeActiveFetcher', active_key);
                reject();
            });
        });
    },
    fetchEditProfileOptions: function (context) {
        var active_key = 'edit_profile';
        return new Promise(function (resolve, reject) {
            if (context.getters['block_fetcher'](active_key)) {
                resolve();
                return;
            }
            context.commit('addActiveFetcher', active_key);
            _services_FormOptionService__WEBPACK_IMPORTED_MODULE_0__["FormOptionService"].GetEditProfileOptions().then(function (result) {
                context.commit('removeActiveFetcher', active_key);
                context.commit('setEditProfileOptions', result);
                context.commit('addCompletedFetcher', active_key);
                resolve();
            }).catch(function () {
                context.commit('removeActiveFetcher', active_key);
                reject();
            });
        });
    },
    fetchClubs: function (context) {
        var active_key = 'clubs';
        return new Promise(function (resolve, reject) {
            if (context.getters['block_fetcher'](active_key)) {
                resolve();
                return;
            }
            context.commit('addActiveFetcher', active_key);
            _services_FormOptionService__WEBPACK_IMPORTED_MODULE_0__["FormOptionService"].getClubOptions().then(function (result) {
                context.commit('removeActiveFetcher', active_key);
                context.commit('setClubOptions', result);
                context.commit('addCompletedFetcher', active_key);
                resolve();
            }).catch(function () {
                context.commit('removeActiveFetcher', active_key);
                reject();
            });
        });
    }
};
var getters = {
    /**
     * Function to return skate test options by a supplied discipline key
     */
    skate_test_options: function (state) {
        return function (discipline_key) {
            return state.categorized_skate_test_options[discipline_key];
        };
    },
    /**
     * Whether a fetcher should be blocked based on current state
     */
    block_fetcher: function (state) {
        return function (fetcher_key) {
            return state.active_fetchers.indexOf(fetcher_key) !== -1 || state.completed_fetchers.indexOf(fetcher_key) !== -1;
        };
    },
    /**
     * State State options
     */
    states: function (state) {
        return state.states;
    },
    /**
     * State Country options
     */
    countries: function (state) {
        return state.countries;
    },
    /**
     * State Federation options
     */
    federations: function (state) {
        return state.federations;
    },
    /**
     * State Province options
     */
    provinces: function (state) {
        return state.provinces;
    },
    /**
     * State SkateTestDiscipline options
     */
    skate_test_disciplines: function (state) {
        return state.skate_test_disciplines;
    },
    edit_profile_options: function (state) {
        return {
            prefixes: state.user_prefixes,
            suffixes: state.user_suffixes,
            mobile_carriers: state.mobile_carriers
        };
    },
    billing_countries: function (state) {
        return state.billing_countries;
    },
    waiver_relationships: function (state) {
        return state.waiver_relationships;
    },
    clubs: function (state) {
        return state.clubs;
    },
    /**
     * Get the form option for a state by its value
     */
    state_from_value: function (state, getters) {
        return function (value) {
            var states = getters['states'];
            for (var i = 0; i < states.length; i++) {
                var state_option = states[i];
                if (state_option.value === value) {
                    return state_option;
                }
            }
            return null;
        };
    },
    /**
     * Get the form option for a country by its value
     */
    country_from_value: function (state, getters) {
        return function (value) {
            var countries = getters['countries'];
            for (var i = 0; i < countries.length; i++) {
                var country_option = countries[i];
                if (country_option.value === value) {
                    return country_option;
                }
            }
            return null;
        };
    },
    /**
     * Get the form option for a province by its value
     */
    province_from_value: function (state, getters) {
        return function (value) {
            var provinces = getters['provinces'];
            for (var i = 0; i < provinces.length; i++) {
                var province_option = provinces[i];
                if (province_option.value === value) {
                    return province_option;
                }
            }
            return null;
        };
    }
};
var mutations = {
    setStateOptions: function (state, value) {
        state.states = value;
    },
    setCountryOptions: function (state, value) {
        state.countries = value;
    },
    setFederationOptions: function (state, value) {
        state.federations = value;
    },
    setProvinceOptions: function (state, value) {
        state.provinces = value;
    },
    setCategorizedSkateTestOptions: function (state, value) {
        state.categorized_skate_test_options = value;
    },
    /**
     * Add active fetcher to state.  If fetcher has children, include them
     */
    addActiveFetcher: function (state, key) {
        state.active_fetchers.push(key);
        if (key in FETCHER_CONFIG) {
            var children = FETCHER_CONFIG[key].children;
            for (var i = 0; i < children.length; i++) {
                var child = children[i];
                state.active_fetchers.push(child);
            }
        }
    },
    /**
     * Remove active fetcher from state.  If fetcher has children, remove them as well
     */
    removeActiveFetcher: function (state, key) {
        state.active_fetchers.splice(state.active_fetchers.indexOf(key), 1);
        if (key in FETCHER_CONFIG) {
            var children = FETCHER_CONFIG[key].children;
            for (var i = 0; i < children.length; i++) {
                var child = children[i];
                state.active_fetchers.splice(state.active_fetchers.indexOf(child), 1);
            }
        }
    },
    /**
     * Add completed fetcher to state.  If fetcher has children, include them
     */
    addCompletedFetcher: function (state, key) {
        state.completed_fetchers.push(key);
        if (key in FETCHER_CONFIG) {
            var children = FETCHER_CONFIG[key].children;
            for (var i = 0; i < children.length; i++) {
                var child = children[i];
                state.completed_fetchers.push(child);
            }
        }
    },
    /**
     * Commit create account options to state
     */
    setCreateAccountOptions: function (state, payload) {
        var states = payload.states, countries = payload.countries, provinces = payload.provinces, federations = payload.federations, skate_tests = payload.skate_tests, skate_test_disciplines = payload.skate_test_disciplines;
        state.states = states;
        state.countries = countries;
        state.federations = federations;
        state.provinces = provinces;
        state.categorized_skate_test_options = skate_tests;
        state.skate_test_disciplines = skate_test_disciplines;
    },
    setBillingAddressOptions: function (state, payload) {
        var states = payload.states, countries = payload.countries, provinces = payload.provinces;
        state.states = states;
        state.billing_countries = countries;
        state.provinces = provinces;
    },
    setEditProfileOptions: function (state, payload) {
        var user_prefixes = payload.user_prefixes, user_suffixes = payload.user_suffixes, mobile_carriers = payload.mobile_carriers;
        state.user_prefixes = user_prefixes;
        state.user_suffixes = user_suffixes;
        state.mobile_carriers = mobile_carriers;
    },
    setWaiverRelationships: function (state, relationships) {
        state.waiver_relationships = relationships;
    },
    setClubOptions: function (state, options) {
        state.clubs = options;
    },
    setVolunteerRequestExperienceOptions: function (state, options) {
        state.volunteer_request_experiences = options;
    }
};
var FormOptionsState = {
    namespaced: true,
    state: new State(),
    actions: actions,
    getters: getters,
    mutations: mutations
};


/***/ }),

/***/ "./src/js/store/Modules/MemberSearchState.ts":
/*!***************************************************!*\
  !*** ./src/js/store/Modules/MemberSearchState.ts ***!
  \***************************************************/
/*! exports provided: State, MemberSearchState */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "State", function() { return State; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MemberSearchState", function() { return MemberSearchState; });
/* harmony import */ var _helpers_SearchResultHelpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../helpers/SearchResultHelpers */ "./src/js/helpers/SearchResultHelpers.ts");

var State = /** @class */ (function () {
    function State() {
        /**
         * Additional functions to validate search form
         */
        this.additional_form_validators = [];
        /**
         * Whether results are active
         */
        this.results_active = false;
        /**
         * Set of search results
         */
        this.results = [];
        /**
         * Array of member IDs to prevent selection (as already selected)
         */
        this.block_previous_selection = [];
        /**
         * State form options for search form
         */
        this.state_options = [];
        /**
         * Currently active amount of items per page
         */
        this.per_page = 10;
        /**
         * The index of the active page of results
         */
        this.active_page_index = 0;
        /**
         * The instruction to display in the ineligible member popup
         */
        this.ineligible_instruction = "Please choose another coach or leave blank";
        /**
         * The descriptor for the search entity type
         */
        this.entity_descriptor = "Member";
        /**
         * Function to determine if there was an error loading the search form
         */
        this.search_form_load_error_check = (function () {
            return false;
        });
    }
    return State;
}());

var actions = {
    /**
     * Run a search for members
     */
    runSearch: function (context, search_params) {
        return new Promise(function (resolve, reject) {
            var searchFunction = context.state.search_function;
            if (!searchFunction) {
                console.error("No member search function specified");
                reject();
                return;
            }
            searchFunction(search_params).then(function (member_results) {
                context.commit('setSearchResults', member_results);
                context.commit('setActivePageIndex', 0);
                context.commit('setPerPage', context.getters.per_page_options[0].value);
                resolve(member_results);
            }).catch(function () {
                reject();
            });
        });
    },
    /**
     * Handle selection of a member
     */
    handleSelection: function (context, member) {
        return new Promise(function (resolve, reject) {
            var selectionMethod = context.state.selection_method;
            if (!selectionMethod) {
                console.error('No selection method configured');
                reject('Error selecting member.');
                return;
            }
            selectionMethod(member).then(function () {
                resolve();
            }).catch(function (message) {
                reject(message);
            });
        });
    }
};
var getters = {
    /**
     * Determine if a result should be blocked for selection and display as already selected
     */
    previously_selected_selection_blocked: function (state) {
        return function (member_id) {
            return state.block_previous_selection.indexOf(member_id) !== -1;
        };
    },
    /**
     * The amount of results
     */
    result_count: function (state) {
        return state.results.length;
    },
    /**
     * The options for "per page" selection
     */
    per_page_options: function (state, getters) {
        var base_options = [10, 25];
        var result = [];
        for (var i = 0; i < base_options.length; i++) {
            var option = base_options[i];
            if (option <= getters.result_count) {
                result.push({
                    label: String(option),
                    value: option
                });
            }
        }
        result.push({
            label: "All",
            value: "all"
        });
        return result;
    },
    /**
     * The paginated set of search results
     */
    paginated_results: function (state) {
        var per_page = state.per_page;
        var result = [];
        return state.results.reduce(function (accumulator, item, index) {
            var result_index = 0;
            if (typeof per_page === "number") {
                result_index = Math.floor(index / per_page);
            }
            if (!accumulator[result_index]) {
                accumulator[result_index] = [];
            }
            accumulator[result_index].push(item);
            return accumulator;
        }, result);
    },
    /**
     * Form state options
     */
    state_options: function (state) {
        return state.state_options;
    },
    /**
     * Get the display results from the paginated list for the active page
     */
    active_results: function (state, getters) {
        return getters.paginated_results[state.active_page_index];
    },
    /**
     * Current begin and end page range
     */
    current_spread: function (state, getters) {
        return _helpers_SearchResultHelpers__WEBPACK_IMPORTED_MODULE_0__["default"].getSpread(getters.result_count, state.active_page_index, state.per_page);
    },
    /**
     * Options to show in pagination
     */
    pagination_options: function (state, getters) {
        return _helpers_SearchResultHelpers__WEBPACK_IMPORTED_MODULE_0__["default"].getPaginationOptions(getters.paginated_results, state.active_page_index);
    },
    /**
     * Whether pagination is available
     */
    pagination_available: function (state, getters) {
        return getters.pagination_options.length > 1;
    },
    /**
     * Get the string reason a member result is invalid, or false if the result is valid
     * Determined through additional validation functions added to state
     */
    memberResultInvalid: function (state, getters) {
        return function (member_result) {
            if (!state.result_validators) {
                return false;
            }
            for (var i = 0; i < state.result_validators.length; i++) {
                var memberValidator = state.result_validators[i];
                var error = memberValidator((member_result));
                if (error) {
                    return error;
                }
            }
            return false;
        };
    },
    search_form_load_error: function (state) {
        return state.search_form_load_error_check();
    }
};
var mutations = {
    setResultsActive: function (state, active) {
        state.results_active = active;
    },
    setSearchResults: function (state, member_results) {
        state.results = member_results;
    },
    setStateOptions: function (state, options) {
        state.state_options = options;
    },
    closeSearch: function (state) {
        var closeMethod = state.close_method;
        if (closeMethod) {
            closeMethod();
            return;
        }
        console.error('No close method configured');
    },
    setPerPage: function (state, per_page) {
        state.per_page = per_page;
    },
    setActivePageIndex: function (state, page_index) {
        state.active_page_index = page_index;
    },
    /**
     * Set the list of ids to display as previously selected
     */
    setBlockedPreviousSelection: function (state, previous_selection) {
        state.block_previous_selection = previous_selection;
    },
    /**
     * Configure the search
     */
    configure: function (state, config) {
        if (config.search_function) {
            state.search_function = config.search_function;
        }
        if (config.selection_method) {
            state.selection_method = config.selection_method;
        }
        if (config.close_method) {
            state.close_method = config.close_method;
        }
        if (config.ineligible_instruction) {
            state.ineligible_instruction = config.ineligible_instruction;
        }
        if (config.entity_descriptor) {
            state.entity_descriptor = config.entity_descriptor;
        }
        if (config.result_validators) {
            state.result_validators = config.result_validators;
        }
        if (config.form_validators) {
            state.additional_form_validators = config.form_validators;
        }
    },
    /**
     * Set function to evaluate to determine if there was a search form load error
     */
    setFormLoadErrorCheckFunction: function (state, payload) {
        state.search_form_load_error_check = payload;
    }
};
var MemberSearchState = {
    namespaced: true,
    state: new State(),
    actions: actions,
    getters: getters,
    mutations: mutations
};


/***/ }),

/***/ "./src/js/store/Modules/SessionState.ts":
/*!**********************************************!*\
  !*** ./src/js/store/Modules/SessionState.ts ***!
  \**********************************************/
/*! exports provided: State, SessionState */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "State", function() { return State; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SessionState", function() { return SessionState; });
/* harmony import */ var _models_Sessions_SelectedSession__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../models/Sessions/SelectedSession */ "./src/js/models/Sessions/SelectedSession.ts");
/* harmony import */ var _models_Sessions_SessionSelector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../models/Sessions/SessionSelector */ "./src/js/models/Sessions/SessionSelector.ts");
/* harmony import */ var _models_SessionValidator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../models/SessionValidator */ "./src/js/models/SessionValidator.ts");



/**
 * The reactive state of competitions
 */
var State = /** @class */ (function () {
    function State() {
    }
    return State;
}());

/**
 * Accessors for computed competition state properties
 */
var getters = {};
/**
 * Perform (potentially async) actions with the state
 */
var actions = {
    /**
     * Session selection global logic.
     * Needs to occur on the state layer due to the involvement of multiple state properties
     */
    select: function (context, session_args) {
        var active_sales_window = context.rootGetters['competitions/active_sales_window'];
        var competition_information = context.rootState.competitions.competition_information; //define var for legibility
        var scheduled_session;
        var session_validation_result;
        var session_selector_args;
        var session_selector;
        var selected_session;
        var compiled_session;
        /**
         * Compile selected session args to run validation against
         */
        compiled_session = {
            id: session_args.session.id,
            type_key: session_args.session.type_key,
            is_full: session_args.session.is_full,
            event_ids: session_args.selected_event_id ? [session_args.selected_event_id] : session_args.session.event_ids,
            credit_types: session_args.selected_session_type ? [session_args.selected_session_type] : session_args.session.credit_types
        };
        /**
         * Validate the selected session and any specified arguments
         */
        session_validation_result = new _models_SessionValidator__WEBPACK_IMPORTED_MODULE_2__["SessionValidator"](context.rootState.skater.skater, competition_information, context.rootGetters['competitions/active_sales_window']).validate(compiled_session);
        /**
         * If the session is in the schedule, get the scheduled version
         */
        if (session_validation_result.session_in_schedule) {
            scheduled_session = context.rootState.skater.active_schedule.findScheduledSession(session_args.session.id);
        }
        /**
         * Build the session selector
         */
        session_selector_args = {
            dispatcher: context.dispatch,
            competition_information: competition_information,
            skater_credits: context.rootState.skater.competition_credits,
            session_in_schedule: scheduled_session,
            session_in_cart: session_validation_result.session_in_cart,
            active_sales_window: active_sales_window
        };
        session_selector = new _models_Sessions_SessionSelector__WEBPACK_IMPORTED_MODULE_1__["SessionSelector"](session_selector_args);
        /**
         * Create a selected session out of state vars
         */
        selected_session = new _models_Sessions_SelectedSession__WEBPACK_IMPORTED_MODULE_0__["SelectedSession"](session_args, competition_information, session_validation_result);
        /**
         * Process the selection
         */
        return session_selector.processSelection(selected_session);
    },
};
/**
 * Change reactive data
 */
var mutations = {};
/**
 * Export the state module
 */
var SessionState = {
    namespaced: true,
    state: new State(),
    getters: getters,
    mutations: mutations,
    actions: actions
};


/***/ }),

/***/ "./src/js/store/Modules/SkateTestHistoryState.ts":
/*!*******************************************************!*\
  !*** ./src/js/store/Modules/SkateTestHistoryState.ts ***!
  \*******************************************************/
/*! exports provided: State, SkateTestHistoryState */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "State", function() { return State; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SkateTestHistoryState", function() { return SkateTestHistoryState; });
/* harmony import */ var _services_UserService__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../services/UserService */ "./src/js/services/UserService.ts");

/* eslint-enable */
var State = /** @class */ (function () {
    function State() {
        /**
         * The active discipline being modified with a new skate test
         */
        this.active_discipline = null;
        /**
         * The active user's skate test history
         */
        this.user_skate_test_history = null;
        /**
         * Action to use when saving a skate test instead of the default action
         */
        this.save_action = null;
        /**
         * Action to use when removing a skate test instead of the default action
         */
        this.remove_action = null;
    }
    return State;
}());

var actions = {
    /* eslint-disable */
    /**
     * Fetch a user's skate test history.  If partner_id is provided, fetch partner skate test
     */
    fetchSkateTestHistory: function (context, partner_id) {
        return new Promise(function (resolve, reject) {
            _services_UserService__WEBPACK_IMPORTED_MODULE_0__["UserService"].getSkateTestHistory(partner_id).then(function (user_skate_test_history) {
                context.commit('setActiveSkateTestHistory', user_skate_test_history);
                resolve();
            }).catch(function () {
                reject();
            });
        });
    },
    /* eslint-enable */
    /**
     * Save a skate test
     */
    saveTest: function (context, test_data) {
        var active_discipline = context.getters.active_discipline;
        return new Promise(function (resolve, reject) {
            var action = context.state.save_action || function (payload) {
                return _services_UserService__WEBPACK_IMPORTED_MODULE_0__["UserService"].addSkateTest(payload.test_data, payload.active_discipline.key);
            };
            var payload = {
                test_data: test_data,
                active_discipline: active_discipline
            };
            action(payload)
                .then(function (updated_test_history) {
                context.commit('setActiveSkateTestHistory', updated_test_history);
                resolve();
            })
                .catch(function (error_message) {
                reject(error_message);
            });
        });
    },
    /**
     * Remove a skate test
     */
    removeTest: function (context, remove_data) {
        return new Promise(function (resolve, reject) {
            var action = context.state.remove_action || _services_UserService__WEBPACK_IMPORTED_MODULE_0__["UserService"].removeSkateTest;
            action(remove_data)
                .then(function (updated_test_history) {
                context.commit('setActiveSkateTestHistory', updated_test_history);
                resolve();
            })
                .catch(function (error_message) {
                reject(error_message);
            });
        });
    }
};
/* eslint-disable */
var getters = {
    /**
     * Get the active discipline if it exists
     */
    active_discipline: function (state) {
        return state.active_discipline;
    },
    /**
     * Get the active skate test history, if it's been fetched
     */
    user_skate_test_history: function (state) {
        return state.user_skate_test_history;
    },
    /**
     * Get the list of skate test disciplines containing self-reported skate tests
     */
    user_self_reported_test_disciplines: function (state) {
        var userSkateTestHistory = state.user_skate_test_history;
        if (!userSkateTestHistory) {
            return [];
        }
        return userSkateTestHistory.disciplines.filter(function (discipline) {
            return discipline.self_reported_tests.length;
        });
    },
    /**
     * Get the list of available test options for the active discipline
     */
    active_discipline_test_options: function (state) {
        if (!state.active_discipline) {
            return [];
        }
        return state.active_discipline.available_tests;
    }
};
/* eslint-enable */
var mutations = {
    /* eslint-disable */
    setActiveDiscipline: function (state, discipline) {
        state.active_discipline = discipline;
    },
    setActiveSkateTestHistory: function (state, skate_test_history) {
        state.user_skate_test_history = skate_test_history;
    },
    /* eslint-enable */
    /**
     * Set the remove action to use in state
     */
    setRemoveAction: function (state, payload) {
        state.remove_action = payload;
    },
    /**
     * Set the save action to use in state
     */
    setSaveAction: function (state, payload) {
        state.save_action = payload;
    },
    /**
     * Reset state to defaults
     */
    reset: function (state) {
        state.save_action = null;
        state.remove_action = null;
    }
    /* eslint-disable */
};
var SkateTestHistoryState = {
    namespaced: true,
    state: new State(),
    actions: actions,
    getters: getters,
    mutations: mutations
};


/***/ }),

/***/ "./src/js/store/Modules/SkaterState.ts":
/*!*********************************************!*\
  !*** ./src/js/store/Modules/SkaterState.ts ***!
  \*********************************************/
/*! exports provided: State, SkaterState */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "State", function() { return State; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SkaterState", function() { return SkaterState; });
/* harmony import */ var _services_SkaterService__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../services/SkaterService */ "./src/js/services/SkaterService.ts");
/* harmony import */ var _models_Schedule_SkaterSchedule__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../models/Schedule/SkaterSchedule */ "./src/js/models/Schedule/SkaterSchedule.ts");
/* harmony import */ var _models_Credits_SkaterCredits__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../models/Credits/SkaterCredits */ "./src/js/models/Credits/SkaterCredits.ts");
/* harmony import */ var _models_Skater__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../models/Skater */ "./src/js/models/Skater.ts");
/* harmony import */ var _models_Collections_SkaterCoachedEventCollection__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../models/Collections/SkaterCoachedEventCollection */ "./src/js/models/Collections/SkaterCoachedEventCollection.ts");
var __assign = (undefined && undefined.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};





var State = /** @class */ (function () {
    function State() {
        this.active_schedule = new _models_Schedule_SkaterSchedule__WEBPACK_IMPORTED_MODULE_1__["SkaterSchedule"]([], []);
        this.competition_credits = new _models_Credits_SkaterCredits__WEBPACK_IMPORTED_MODULE_2__["SkaterCredits"]();
        this.active_competition_registered_event_ids = [];
        this.schedule_loaded = false;
        this.billing_addresses = [];
        this.credits_loaded = false;
        this.active_competition_coach_events = new _models_Collections_SkaterCoachedEventCollection__WEBPACK_IMPORTED_MODULE_4__["SkaterCoachedEventCategoryCollection"]();
        this.active_skating_event_segments = [];
        this.skater = new _models_Skater__WEBPACK_IMPORTED_MODULE_3__["Skater"]({ schedule: this.active_schedule, credits: this.competition_credits });
    }
    return State;
}());

var actions = {
    /**
     * Fetch basic information about the active skater
     * @deprecated 5/27/19 - this returned basic name and address info and has been superseded by User Profile info
     */
    fetchSkaterInfo: function (context) {
        return new Promise(function (resolve, reject) {
            _services_SkaterService__WEBPACK_IMPORTED_MODULE_0__["SkaterService"].getSkaterInfo().then(function (info) {
                context.commit('setSkaterInfo', info);
                resolve();
            }).catch(function () {
                reject();
            });
        });
    },
    /**
     * Fetch the active skater's competition schedule
     *
     * @deprecated 2020-08-04
     */
    fetchCompetitionSchedule: function (context, id) {
        context.state.schedule_loaded = false;
        return new Promise(function (resolve, reject) {
            _services_SkaterService__WEBPACK_IMPORTED_MODULE_0__["SkaterService"].getCompetitionSchedule(id).then(function (result) {
                context.commit('setActiveSchedule', result);
                resolve();
            }).catch(function () {
                reject();
            });
        });
    },
    /**
     * Called from Competition Information Page
     */
    fetchCompetitionRegisteredEventIDs: function (context, competition_id) {
        return new Promise(function (resolve, reject) {
            _services_SkaterService__WEBPACK_IMPORTED_MODULE_0__["SkaterService"].getCompetitionRegisteredEventIDs(competition_id).then(function (event_ids) {
                context.commit('setActiveCompetitionEventIDs', event_ids);
                resolve();
            }).catch(function () {
                reject();
            });
        });
    },
    /**
     * Get the skater's unscheduled credits for the competition
     * Called from Practice Ice Schedule
     */
    fetchCompetitionCredits: function (context, id) {
        context.state.credits_loaded = false;
        return new Promise(function (resolve, reject) {
            _services_SkaterService__WEBPACK_IMPORTED_MODULE_0__["SkaterService"].getCompetitionCredits(id).then(function (result) {
                context.commit('setCompetitionCredits', result);
                resolve();
            }).catch(function () {
                reject();
            });
        });
    },
    /**
     * Add a session to the skater's schedule
     */
    addSessionToSchedule: function (context, payload) {
        return new Promise(function (resolve, reject) {
            _services_SkaterService__WEBPACK_IMPORTED_MODULE_0__["SkaterService"].addSessionToSchedule(payload.scheduled_session).then(function () {
                function addSessionToAppSchedule() {
                    context.commit('addSessionToSchedule', payload.scheduled_session);
                    context.commit('decrementCredit', {
                        type: payload.scheduled_session.scheduled_as,
                        event_id: payload.scheduled_session.scheduled_event_id
                    });
                }
                resolve(addSessionToAppSchedule);
            }).catch(function () {
                reject();
            });
        });
    },
    /**
     * Remove a session from the skater's schedule
     */
    removeSessionFromSchedule: function (context, payload) {
        return new Promise(function (resolve, reject) {
            _services_SkaterService__WEBPACK_IMPORTED_MODULE_0__["SkaterService"].removeSessionFromSchedule(payload.scheduled_session).then(function () {
                function removeSessionFromAppSchedule() {
                    context.commit('removeSessionFromSchedule', payload.scheduled_session);
                    context.commit('incrementCredit', {
                        type: payload.scheduled_session.scheduled_as,
                        event_id: payload.scheduled_session.scheduled_event_id
                    });
                }
                resolve(removeSessionFromAppSchedule);
            }).catch(function () {
                reject();
            });
        });
    },
    /**
     * Fetch the saved list of billing addresses for the skater
     */
    fetchBillingAddresses: function (context) {
        return new Promise(function (resolve, reject) {
            _services_SkaterService__WEBPACK_IMPORTED_MODULE_0__["SkaterService"].getBillingAddresses().then(function (result) {
                context.commit('setBillingAddresses', result);
                resolve();
            }).catch(function () {
                reject();
            });
        });
    },
    /**
     * Edit an address
     *
     * Resolves with the edited BillingAddress
     */
    editAddress: function (context, edit_payload) {
        var source = edit_payload.source, data = edit_payload.data;
        return new Promise(function (resolve, reject) {
            _services_SkaterService__WEBPACK_IMPORTED_MODULE_0__["SkaterService"].updateBillingAddress(edit_payload).then(function (updated_address) {
                context.commit('editAddress', updated_address);
                if (data.is_default) {
                    context.commit('clearDefaults', source.id);
                }
                resolve(updated_address);
            }).catch(function () {
                reject();
            });
        });
    },
    /**
     * Create an address
     *
     * Resolves with the created BillingAddress
     */
    createAddress: function (context, create_payload) {
        return new Promise(function (resolve, reject) {
            _services_SkaterService__WEBPACK_IMPORTED_MODULE_0__["SkaterService"].createBillingAddress(create_payload).then(function (result) {
                context.commit('addAddress', result);
                if (result.is_default) {
                    context.commit('clearDefaults', result.id);
                }
                resolve(result);
            }).catch(function () {
                reject();
            });
        });
    },
    /**
     * Get the events and associated coaches for a skater for a given competition
     *
     * @deprecated 2020-07-28
     */
    fetchCompetitionEventCoaches: function (context, competition_id) {
        return new Promise(function (resolve, reject) {
            _services_SkaterService__WEBPACK_IMPORTED_MODULE_0__["SkaterService"].getCompetitionEventCoaches(competition_id).then(function (result) {
                context.commit('setCompetitionEventCoaches', result);
                resolve();
            }).catch(function () {
                reject();
            });
        });
    },
    /**
     * Remove a coach for a skater
     */
    removeCoach: function (context, payload) {
        return new Promise(function (resolve, reject) {
            _services_SkaterService__WEBPACK_IMPORTED_MODULE_0__["SkaterService"].removeCoach(payload).then(function () {
                context.commit('removeCoach', payload);
                resolve();
            }).catch(function () {
                reject();
            });
        });
    },
    /**
     * Add a coach for a skater
     */
    addCoach: function (context, payload) {
        return new Promise(function (resolve, reject) {
            _services_SkaterService__WEBPACK_IMPORTED_MODULE_0__["SkaterService"].addCoach(payload).then(function () {
                context.commit('addCoach', payload);
                resolve();
            }).catch(function () {
                reject();
            });
        });
    },
    replaceCoach: function (context, payload) {
        return new Promise(function (resolve, reject) {
            _services_SkaterService__WEBPACK_IMPORTED_MODULE_0__["SkaterService"].replaceCoach(payload).then(function () {
                context.commit('replaceCoach', payload);
                resolve();
            }).catch(function () {
                reject();
            });
        });
    },
    /**
     * Fetch the skater's skating event segments for a given competition
     */
    fetchSkatingEventSegments: function (context, competition_id) {
        return new Promise(function (resolve, reject) {
            _services_SkaterService__WEBPACK_IMPORTED_MODULE_0__["SkaterService"].getSkatingEventSegments(competition_id).then(function (result) {
                context.commit("setActiveSkatingEventSegments", result);
                resolve();
            }).catch(function () {
                reject();
            });
        });
    }
};
var getters = {
    saved_address_count: function (state) {
        return state.billing_addresses.length;
    },
    available_credits: function (state) {
        return state.competition_credits.available_credits;
    },
    available_credit_list: function (state) {
        var intermediate = state.competition_credits.getAvailableCreditList();
        var result = [];
        for (var i = 0; i < intermediate.length; i++) {
            var event_credit_list = intermediate[i];
            var event = state.active_schedule.findEvent(event_credit_list.event_id);
            if (event) {
                result.push(__assign({}, event_credit_list, { event_name: event.name }));
            }
        }
        return result;
    },
    /**
     * Get the available credits list for a skater with credit types of limit 0 removed
     */
    pruned_available_credit_list: function (state, getters, rootState, rootGetters) {
        var indexed_skater_event_credit_limits = rootGetters['indexed_skater_event_credit_limits'];
        var skater_available_credit_list_complete = getters['available_credit_list'];
        return skater_available_credit_list_complete.reduce(function (accumulator, item) {
            var event_limits = indexed_skater_event_credit_limits[item.event_id];
            var item_result = {
                event_name: item.event_name,
                credits: {
                    upi: item.upi,
                    opi: item.opi,
                    wu: item.wu
                }
            };
            for (var i in event_limits) {
                var limit = event_limits[i];
                if (limit < 1) {
                    delete item_result.credits[i];
                }
            }
            if (Object.keys(item_result.credits).length) {
                accumulator.push(item_result);
            }
            return accumulator;
        }, []);
    },
    package_purchased: function (state, getters) {
        return function (credit_package) {
            return getters['purchased_package_ids'].indexOf(credit_package.id) !== -1;
        };
    },
    purchased_package_ids: function (state) {
        return state.competition_credits.purchased_package_ids;
    },
    has_unscheduled_credits: function (state) {
        return state.competition_credits.unscheduled_credits();
    },
    categoryCoachSelected: function (state) {
        return function (event_id, coach_id) {
            return state.active_competition_coach_events.containsEventCategoryCoach(event_id, coach_id);
        };
    },
    /**
     * Get the active event segments from state
     */
    active_event_segments: function (state) {
        return state.active_skating_event_segments;
    }
};
var mutations = {
    clearDefaults: function (state, default_id) {
        state.billing_addresses.forEach(function (address) {
            if (default_id !== address.id) {
                address.is_default = false;
            }
        });
    },
    /**
     * @deprecated 5/27/19 - this returned basic name and address info and has been superseded by User Profile info
     */
    setSkaterInfo: function (state, info) {
        state.info = info;
    },
    setBillingAddresses: function (state, billing_addresses) {
        state.billing_addresses = billing_addresses;
    },
    setActiveCompetitionEventIDs: function (state, event_ids) {
        state.active_competition_registered_event_ids = event_ids;
    },
    addSessionToSchedule: function (state, scheduled_session) {
        state.active_schedule.add(scheduled_session);
    },
    removeSessionFromSchedule: function (state, scheduled_session) {
        state.active_schedule.remove(scheduled_session);
    },
    decrementCredit: function (state, _a) {
        var event_id = _a.event_id, type = _a.type;
        state.competition_credits.decrement(event_id, type);
    },
    incrementCredit: function (state, _a) {
        var event_id = _a.event_id, type = _a.type;
        state.competition_credits.increment(event_id, type);
    },
    setActiveSchedule: function (state, payload) {
        state.active_schedule = new _models_Schedule_SkaterSchedule__WEBPACK_IMPORTED_MODULE_1__["SkaterSchedule"](payload.sessions, payload.events);
        state.skater.schedule = state.active_schedule;
        state.active_competition_registered_event_ids = payload.events.map(function (event) {
            return event.id;
        });
        state.schedule_loaded = true;
    },
    setCompetitionCredits: function (state, payload) {
        state.competition_credits = payload;
        state.skater.credits = payload;
        state.credits_loaded = true;
    },
    /**
     * Called from Cart State
     */
    setSkaterCart: function (state, payload) {
        state.skater.cart = payload;
    },
    /**
     * Commit the edit of a BillingAddress to State
     */
    editAddress: function (state, updated_address) {
        for (var i = 0; i < state.billing_addresses.length; i++) {
            var billing_address = state.billing_addresses[i];
            if (billing_address.id === updated_address.id) {
                state.billing_addresses[i] = updated_address;
                break;
            }
        }
    },
    /**
     * Commit the creation of a BillingAddress to State
     */
    addAddress: function (state, billing_address) {
        state.billing_addresses.push(billing_address);
    },
    setCompetitionEventCoaches: function (state, event_coaches) {
        state.active_competition_coach_events = event_coaches;
    },
    removeCoach: function (state, payload) {
        var coach = payload.coach, event_category_id = payload.event_category_id;
        var coach_id = coach.id;
        state.active_competition_coach_events.remove(event_category_id, coach_id);
    },
    addCoach: function (state, payload) {
        var coach = payload.coach, event_category_id = payload.event_category_id;
        state.active_competition_coach_events.add(event_category_id, coach);
    },
    replaceCoach: function (state, payload) {
        var coach = payload.coach, event_category_id = payload.event_category_id, previous_coach_id = payload.previous_coach_id;
        state.active_competition_coach_events.replace(event_category_id, previous_coach_id, coach);
    },
    /**
     * Commit a set of active skating event segments to state
     */
    setActiveSkatingEventSegments: function (state, skating_event_segments) {
        state.active_skating_event_segments = skating_event_segments;
    }
};
var SkaterState = {
    namespaced: true,
    state: new State(),
    actions: actions,
    getters: getters,
    mutations: mutations
};


/***/ }),

/***/ "./src/js/store/Modules/UserState.ts":
/*!*******************************************!*\
  !*** ./src/js/store/Modules/UserState.ts ***!
  \*******************************************/
/*! exports provided: State, UserState */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "State", function() { return State; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UserState", function() { return UserState; });
/* harmony import */ var _services_UserService__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../services/UserService */ "./src/js/services/UserService.ts");
/* harmony import */ var _models_User__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../models/User */ "./src/js/models/User.ts");
var __assign = (undefined && undefined.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};


var State = /** @class */ (function () {
    function State() {
        this.user = _models_User__WEBPACK_IMPORTED_MODULE_1__["User"].blank();
        this.user_info_endpoint_request_completed = false;
        this.profile = null;
        this.waivers = [];
        this.emergency_contact = null;
    }
    return State;
}());

var actions = {
    fetchUserInfo: function (context) {
        var active_competition_id = context.rootState.competitions.active_competition_id;
        context.commit('setUserInfoEndpointCompleted', false);
        if (active_competition_id === -1) {
            active_competition_id = false;
        }
        return new Promise(function (resolve, reject) {
            _services_UserService__WEBPACK_IMPORTED_MODULE_0__["UserService"].getUserInfo(active_competition_id).then(function (user) {
                context.commit('setUser', user);
                context.commit('setUserInfoEndpointCompleted', true);
                resolve();
            }).catch(function () {
                context.commit('setUserInfoEndpointCompleted', true);
                reject();
            });
        });
    },
    fetchUserProfile: function (context) {
        return new Promise(function (resolve, reject) {
            _services_UserService__WEBPACK_IMPORTED_MODULE_0__["UserService"].getProfile().then(function (user_profile) {
                context.commit('setUserProfile', user_profile);
                resolve();
                return;
            }).catch(function () {
                reject();
            });
        });
    },
    saveProfile: function (context, profile_data) {
        return new Promise(function (resolve, reject) {
            _services_UserService__WEBPACK_IMPORTED_MODULE_0__["UserService"].saveProfile(profile_data).then(function (updated_profile) {
                context.commit('setUserProfile', updated_profile);
                resolve();
            }).catch(function (error_message) {
                reject(error_message);
            });
        });
    },
    saveWaivers: function (context, waiver_data) {
        return new Promise(function (resolve, reject) {
            _services_UserService__WEBPACK_IMPORTED_MODULE_0__["UserService"].saveWaivers(waiver_data).then(function () {
                resolve();
            }).catch(function (error_message) {
                reject(error_message);
            });
        });
    },
    /**
     * Update user profile in state
     */
    updateProfile: function (context, update_args) {
        var current_profile = __assign({}, context.getters.profile);
        for (var property in update_args) {
            if (!Object.prototype.hasOwnProperty.call(update_args, property)) {
                continue;
            }
            var property_value = update_args[property];
            if (!Object.prototype.hasOwnProperty.call(current_profile, property)) {
                console.warn('Update property not present in profile:', property);
                continue;
            }
            current_profile[property] = property_value;
        }
        context.commit('setUserProfile', current_profile);
    },
    /**
     * Update emergency contact in state
     */
    updateEmergencyContact: function (context, update_args) {
        var current_contact = __assign({}, context.getters.emergency_contact);
        for (var property in update_args) {
            if (!Object.prototype.hasOwnProperty.call(update_args, property)) {
                continue;
            }
            var property_value = update_args[property];
            if (!Object.prototype.hasOwnProperty.call(current_contact, property)) {
                console.warn('Update property not present in emergency contact:', property);
                continue;
            }
            current_contact[property] = property_value;
        }
        context.commit('setUserEmergencyContact', current_contact);
    }
};
var getters = {
    user: function (state) {
        return state.user;
    },
    user_roles: function (state) {
        return state.user.roles;
    },
    upload_file_capability: function (state) {
        return state.user.upload_file_capability;
    },
    profile: function (state) {
        return state.profile;
    },
    emergency_contact: function (state) {
        return state.emergency_contact;
    },
    /**
     * Active non-null LTS information for the active user
     */
    lts_information: function (state, getters) {
        var active_profile = getters['profile'];
        if (active_profile) {
            return active_profile.lts_programs;
        }
        return {
            summary: {
                description: "",
                validity_date_formatted: "",
            },
            programs: []
        };
    },
    waivers: function (state) {
        return state.waivers;
    }
};
var mutations = {
    setUserInfoEndpointCompleted: function (state, payload) {
        state.user_info_endpoint_request_completed = payload;
    },
    setUser: function (state, user) {
        state.user = user;
    },
    setUserProfile: function (state, user_profile) {
        state.profile = user_profile;
    },
    setUserWaivers: function (state, user_waivers) {
        state.waivers = user_waivers;
    },
    setUserEmergencyContact: function (state, emergency_contact) {
        state.emergency_contact = emergency_contact;
    }
};
var UserState = {
    namespaced: true,
    state: new State(),
    actions: actions,
    getters: getters,
    mutations: mutations
};


/***/ }),

/***/ "./src/js/store/index.ts":
/*!*******************************!*\
  !*** ./src/js/store/index.ts ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
/* harmony import */ var vuex__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vuex */ "./node_modules/vuex/dist/vuex.esm.js");
/* harmony import */ var _Modules_CompetitionsState__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Modules/CompetitionsState */ "./src/js/store/Modules/CompetitionsState.ts");
/* harmony import */ var _Modules_SkaterState__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Modules/SkaterState */ "./src/js/store/Modules/SkaterState.ts");
/* harmony import */ var _Modules_CartState__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Modules/CartState */ "./src/js/store/Modules/CartState.ts");
/* harmony import */ var _Modules_SessionState__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Modules/SessionState */ "./src/js/store/Modules/SessionState.ts");
/* harmony import */ var _Modules_AppState__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Modules/AppState */ "./src/js/store/Modules/AppState.ts");
/* harmony import */ var _Modules_CoachState__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Modules/CoachState */ "./src/js/store/Modules/CoachState.ts");
/* harmony import */ var _Modules_UserState__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Modules/UserState */ "./src/js/store/Modules/UserState.ts");
/* harmony import */ var _services_AppService__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../services/AppService */ "./src/js/services/AppService.ts");
/* harmony import */ var _Teams_TeamsState__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../Teams/TeamsState */ "./src/js/Teams/TeamsState.ts");
/* harmony import */ var _CompetitionPortal_store_CompetitionPortalState__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../CompetitionPortal/_store/CompetitionPortalState */ "./src/js/CompetitionPortal/_store/CompetitionPortalState.ts");
var __assign = (undefined && undefined.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};












vue__WEBPACK_IMPORTED_MODULE_0__["default"].use(vuex__WEBPACK_IMPORTED_MODULE_1__["default"]);
/* harmony default export */ __webpack_exports__["default"] = (new vuex__WEBPACK_IMPORTED_MODULE_1__["default"].Store({
    modules: {
        app: _Modules_AppState__WEBPACK_IMPORTED_MODULE_6__["AppState"],
        cart: _Modules_CartState__WEBPACK_IMPORTED_MODULE_4__["CartState"],
        coach: _Modules_CoachState__WEBPACK_IMPORTED_MODULE_7__["CoachState"],
        competition_portal: _CompetitionPortal_store_CompetitionPortalState__WEBPACK_IMPORTED_MODULE_11__["CompetitionPortalState"],
        competitions: _Modules_CompetitionsState__WEBPACK_IMPORTED_MODULE_2__["CompetitionState"],
        session: _Modules_SessionState__WEBPACK_IMPORTED_MODULE_5__["SessionState"],
        skater: _Modules_SkaterState__WEBPACK_IMPORTED_MODULE_3__["SkaterState"],
        teams: _Teams_TeamsState__WEBPACK_IMPORTED_MODULE_10__["TeamsState"],
        user: _Modules_UserState__WEBPACK_IMPORTED_MODULE_8__["UserState"]
    },
    actions: {
        /**
         * Get the Skater and Competition Schedules for Practice Ice
         *
         * @deprecated 2020-07-13: see src/js/CompetitionPortal/_store/CompetitionPortalPracticeIceState.ts:13
         */
        getPracticeIceSchedulesData: function (context, competition_id) {
            return new Promise(function (resolve, reject) {
                _services_AppService__WEBPACK_IMPORTED_MODULE_9__["AppService"].getPracticeIceSchedules(competition_id).then(function (parsed_schedules) {
                    var competition_schedule_args = {
                        result: parsed_schedules.competition_schedule,
                        competition: context.rootGetters['competitions/active_competition']
                    };
                    var skater_schedule_args = parsed_schedules.skater_schedule_args;
                    context.commit('competitions/setCompetitionSchedule', competition_schedule_args, { root: true });
                    context.commit('skater/setActiveSchedule', skater_schedule_args, { root: true });
                    resolve();
                }).catch(function () {
                    reject();
                });
            });
        }
    },
    getters: {
        credit_purchase_available: function (state, getters) {
            return !!getters['purchasable_credits'].length;
        },
        skater_events: function (state) {
            var skater_event_ids = state.skater.active_schedule.event_ids;
            var competition_events = state.competitions.active_competition_events;
            return competition_events.filter(function (event) {
                return skater_event_ids.indexOf(event.id) !== -1;
            });
        },
        /**
         * Get an EventID-indexed collection of credit limits for each event for which the skater is registered for
         */
        indexed_skater_event_credit_limits: function (state, getters) {
            return getters['skater_events'].reduce(function (accumulator, event) {
                accumulator[event.id] = event.getCreditLimits();
                return accumulator;
            }, {});
        },
        available_credit_packages: function (state, getters) {
            return getters['skater_events'].reduce(function (accumulator, event) {
                if (event.credit_packages.length) {
                    accumulator.push({
                        name: event.name,
                        competition_id: event.competition_id,
                        id: event.id,
                        packages: event.credit_packages
                    });
                }
                return accumulator;
            }, []);
        },
        /**
         * Get a list of EventCreditConfigs containing each event for which the skater is registered and how many
         * credits of each type are still available for purchase, along with their costs.
         *
         * Do not include credit types that are not available (limit=0)
         * Do not include events with available credit types
         *
         * For every event for which the skater is registered...
         *  For every type within the event for which one can buy credits (competition configuration/sales window)
         *      Return the event, and each associated CreditRule with its limits reduced by the spent credits
         */
        purchasable_credits: function (state, getters) {
            var purchasable_credit_types = getters['competitions/purchasable_credit_types'];
            /**
             * If there's not any non selectable types, no credits are available for purchase
             */
            if (purchasable_credit_types.length === 0) {
                return [];
            }
            var skater_events = getters['skater_events'];
            var used_credits = state.skater.skater.getAcquiredCredits();
            // create array with skater's events as the base
            return skater_events.reduce(function (array, event) {
                var event_purchasable_credit_rules = event.getCreditRules(purchasable_credit_types);
                var event_used_credits = used_credits[event.id];
                // create list of credit rules, with limits set by configured limit reduced by skater's used amount
                // if a defined credit limit is 0, do not include it
                var reduced_credit_rules = event_purchasable_credit_rules.reduce(function (accumulator, credit_rule) {
                    if (credit_rule.limit > 0) {
                        var reduced_limit = credit_rule.limit - event_used_credits[credit_rule.key];
                        var result = __assign({}, credit_rule, { limit: reduced_limit >= 0 ? reduced_limit : 0 });
                        accumulator.push(result);
                    }
                    return accumulator;
                }, []);
                if (reduced_credit_rules.length > 0) {
                    array.push({
                        event: {
                            name: event.name,
                            id: event.id
                        },
                        purchasable_credits: reduced_credit_rules
                    });
                }
                return array;
            }, []);
        }
    }
}));


/***/ }),

/***/ 3:
/*!**************************************************!*\
  !*** multi ./src/js/competition-registration.ts ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! D:\Test\Figure\hawkeye-ems\src\js\competition-registration.ts */"./src/js/competition-registration.ts");


/***/ })

},[[3,"/js/manifest","/js/vendor"]]]);